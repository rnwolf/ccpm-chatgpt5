import "./chunk-DYWWDCTU.js";
import {
  derived,
  writable
} from "./chunk-ZBZPQC57.js";
import "./chunk-X7HCJ7ZS.js";
import {
  HtmlTag,
  SvelteComponentDev,
  action_destroyer,
  add_iframe_resize_listener,
  add_location,
  add_render_callback,
  append_dev,
  append_styles,
  assign,
  attr_dev,
  binding_callbacks,
  bubble,
  check_outros,
  component_subscribe,
  compute_rest_props,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  null_to_empty,
  onDestroy,
  onMount,
  outro_and_destroy_block,
  run_all,
  safe_not_equal,
  setContext,
  set_data_dev,
  set_store_value,
  set_style,
  space,
  src_url_equal,
  stop_propagation,
  svg_element,
  text,
  tick,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-GHDDQEMC.js";
import "./chunk-672HPU4M.js";
import {
  __export,
  __publicField
} from "./chunk-6KBIBHQC.js";

// node_modules/svelte-gantt/svelte/core/store.js
function createEntityStore() {
  const { subscribe, set, update } = writable({ ids: [], entities: {} });
  return {
    set,
    _update: update,
    subscribe,
    add: (item) => update(({ ids, entities }) => ({
      ids: [...ids, item.model.id],
      entities: {
        ...entities,
        [item.model.id]: item
      }
    })),
    delete: (id) => update((state) => {
      const { [id]: _, ...entities } = state.entities;
      return {
        ids: state.ids.filter((i) => i !== id),
        entities
      };
    }),
    deleteAll: (ids) => update((state) => {
      const entities = { ...state.entities };
      const idSet = new Set(ids);
      for (let i = 0; i < state.ids.length; i++) {
        if (idSet.has(state.ids[i])) {
          delete entities[state.ids[i]];
        }
      }
      return {
        ids: state.ids.filter((i) => !idSet.has(i)),
        entities
      };
    }),
    update: (item) => update(({ ids, entities }) => ({
      ids,
      entities: {
        ...entities,
        [item.model.id]: item
      }
    })),
    upsert: (item) => update(({ ids, entities }) => {
      const hasIndex = ids.indexOf(item.model.id) !== -1;
      return {
        ids: hasIndex ? ids : [...ids, item.model.id],
        entities: {
          ...entities,
          [item.model.id]: item
        }
      };
    }),
    upsertAll: (items) => update((state) => {
      const entities = { ...state.entities };
      const ids = [...state.ids];
      for (let i = 0; i < items.length; i++) {
        if (ids.indexOf(items[i].model.id) === -1) {
          ids.push(items[i].model.id);
        }
        entities[items[i].model.id] = items[i];
      }
      return {
        ids,
        entities
      };
    }),
    addAll: (items) => {
      const ids = [];
      const entities = {};
      for (let i = 0; i < items.length; i++) {
        ids.push(items[i].model.id);
        entities[items[i].model.id] = items[i];
      }
      set({ ids, entities });
    },
    refresh: () => update((store) => ({ ...store }))
  };
}
function all(store) {
  return derived(store, ({ ids, entities }) => {
    const results = [];
    for (let i = 0; i < ids.length; i++) {
      results.push(entities[ids[i]]);
    }
    return results;
  });
}
function createDataStore() {
  const taskStore = createEntityStore();
  const rowStore = createEntityStore();
  const timeRangeStore = createEntityStore();
  const allTasks = all(taskStore);
  const allRows = all(rowStore);
  const allTimeRanges = all(timeRangeStore);
  const rowTaskCache = derived(allTasks, ($allTasks) => {
    const cache = {};
    for (let i = 0; i < $allTasks.length; i++) {
      const task = $allTasks[i];
      if (!cache[task.model.resourceId]) {
        cache[task.model.resourceId] = [];
      }
      cache[task.model.resourceId].push(task.model.id);
    }
    return cache;
  });
  return {
    taskStore,
    rowStore,
    timeRangeStore,
    allTasks,
    allRows,
    allTimeRanges,
    rowTaskCache
  };
}

// node_modules/svelte-gantt/svelte/utils/dom.js
function isLeftClick(event) {
  return event.which === 1;
}
function getRelativePos(node, event) {
  const rect = node.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  return {
    x,
    y
  };
}
function getRelativePosition(node, event) {
  const rect = node.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  return [x, y];
}
function addEventListenerOnce(target, type2, listener, addOptions, removeOptions) {
  target.addEventListener(type2, function fn() {
    target.removeEventListener(type2, fn, removeOptions);
    listener.apply(this, arguments, addOptions);
  });
}
function setCursor(cursor, node = document.body) {
  node.style.cursor = cursor;
}
function normalizeClassAttr(classes) {
  if (!classes) {
    return "";
  }
  if (typeof classes === "string") {
    return classes;
  }
  if (Array.isArray(classes)) {
    return classes.join(" ");
  }
  return "";
}
function throttle(func, limit) {
  let wait = false;
  return function() {
    if (!wait) {
      func.apply(null, arguments);
      wait = true;
      setTimeout(function() {
        wait = false;
      }, limit);
    }
  };
}
var DRAGGING_TO_SCROLL_TRESHOLD = 40;
var DRAGGING_TO_SCROLL_DELTA = 40;
function outOfBounds(event, rect) {
  return {
    left: event.clientX - rect.left < 0 + DRAGGING_TO_SCROLL_TRESHOLD,
    top: event.clientY - rect.top < 0 + DRAGGING_TO_SCROLL_TRESHOLD,
    right: event.clientX - rect.left > rect.width - DRAGGING_TO_SCROLL_TRESHOLD,
    bottom: event.clientY - rect.top > rect.height - DRAGGING_TO_SCROLL_TRESHOLD
  };
}
var scrollIfOutOfBounds = throttle((event, scrollable) => {
  const mainContainerRect = scrollable.getBoundingClientRect();
  const bounds = outOfBounds(event, mainContainerRect);
  if (bounds.left || bounds.right) {
    scrollable.scrollTo({
      left: scrollable.scrollLeft + (bounds.left ? -DRAGGING_TO_SCROLL_DELTA : DRAGGING_TO_SCROLL_DELTA),
      behavior: "smooth"
    });
  }
  if (bounds.top || bounds.bottom) {
    scrollable.scrollTo({
      top: scrollable.scrollTop + (bounds.top ? -DRAGGING_TO_SCROLL_DELTA : DRAGGING_TO_SCROLL_DELTA),
      behavior: "smooth"
    });
  }
}, 250);
function getRowAtPoint(event) {
  const elements = document.elementsFromPoint(event.clientX, event.clientY);
  const rowElement = elements.find((element2) => !!element2.getAttribute("data-row-id"));
  if (rowElement !== void 0) {
    const rowId = rowElement.getAttribute("data-row-id");
    return rowId;
  }
  return null;
}
function whenEnterPress(callback) {
  return (e) => {
    if (e.key === "Enter") {
      callback(e);
    }
  };
}

// node_modules/svelte-gantt/svelte/utils/utils.js
function createUtils(params) {
  return {
    /**
     * Returns position of date on a line if from and to represent length of width
     * @param {*} date
     */
    getPositionByDate(date) {
      return getPositionByDate(date, params.from, params.to, params.width);
    },
    getDateByPosition(x) {
      return getDateByPosition(x, params.from, params.to, params.width);
    },
    roundTo(date) {
      if (params.dateAdapter) {
        return params.dateAdapter.roundTo(date, params.magnetUnit, params.magnetOffset);
      }
      return null;
    }
  };
}
function getPositionByDate(date, from, to, width) {
  if (!date) {
    return void 0;
  }
  const durationTo = date - from;
  const durationToEnd = to - from;
  return durationTo / durationToEnd * width;
}
function getDateByPosition(x, from, to, width) {
  const durationTo = x / width * (to - from);
  const dateAtPosition = from + durationTo;
  return dateAtPosition;
}
function getIndicesOnly(input, value, comparer, strict) {
  let lo = -1;
  let hi = input.length;
  while (hi - lo > 1) {
    const mid = Math.floor((lo + hi) / 2);
    if (strict ? comparer(input[mid]) < value : comparer(input[mid]) <= value) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  if (!strict && input[lo] !== void 0 && comparer(input[lo]) === value) {
    hi = lo;
  }
  return [lo, hi];
}
function get(input, value, comparer, strict) {
  const res = getIndicesOnly(input, value, comparer, strict);
  return [input[res[0]], input[res[1]]];
}
function isDraggable(item) {
  return item.draggable ?? item.enableDragging ?? true;
}
function isResizable(item) {
  return item.resizable ?? item.enableResize ?? true;
}

// node_modules/svelte-gantt/svelte/entities/Task.svelte
var file = "node_modules\\svelte-gantt\\svelte\\entities\\Task.svelte";
function add_css(target) {
  append_styles(target, "svelte-e1wt24", ".sg-label-bottom.svelte-e1wt24.svelte-e1wt24{position:absolute;top:calc(100% + 10px);color:#888}.sg-task.svelte-e1wt24.svelte-e1wt24{position:absolute;border-radius:2px;white-space:nowrap;transition:background-color 0.2s,\n            opacity 0.2s;pointer-events:all;touch-action:none}.sg-task-background.svelte-e1wt24.svelte-e1wt24{position:absolute;height:100%;top:0}.sg-task-content.svelte-e1wt24.svelte-e1wt24{position:absolute;height:100%;top:0;padding-left:14px;font-size:14px;display:flex;align-items:center;justify-content:flex-start;user-select:none}.sg-task.animating.svelte-e1wt24.svelte-e1wt24:not(.moving),.sg-task--sticky.svelte-e1wt24.svelte-e1wt24:not(.moving){transition:left 0.2s,\n            top 0.2s,\n            transform 0.2s,\n            background-color 0.2s,\n            width 0.2s,\n            height 0.2s}.sg-task--sticky.svelte-e1wt24>.sg-task-content.svelte-e1wt24{position:sticky;left:0;max-width:100px}.sg-task.moving.svelte-e1wt24.svelte-e1wt24{z-index:10000;opacity:0.5}.sg-task.resize-enabled.svelte-e1wt24.svelte-e1wt24:hover::before,.sg-task.resize-enabled.svelte-e1wt24.svelte-e1wt24:hover::after{content:'';width:4px;height:50%;top:25%;position:absolute;border-style:solid;border-color:var(--sg-task-resize-color);cursor:ew-resize;border-width:0 1px;z-index:1}.sg-task.resize-enabled.svelte-e1wt24.svelte-e1wt24:hover::before{margin-left:3px;left:0}.sg-task.resize-enabled.svelte-e1wt24.svelte-e1wt24:hover::after{margin-right:3px;right:0}.sg-task-reflected.svelte-e1wt24.svelte-e1wt24{opacity:0.5}.sg-task-instant.svelte-e1wt24.svelte-e1wt24{width:2px !important;margin-left:-1px}.sg-task-background.svelte-e1wt24.svelte-e1wt24{background:rgba(0, 0, 0, 0.2)}.sg-task-default{color:white;background:rgb(116, 191, 255)}.sg-task-default:hover{background:rgb(98, 161, 216)}.sg-task-default.selected{background:rgb(69, 112, 150)}.sg-task-selected{outline:2px solid var(--sg-task-selected-outline-color);outline-offset:3px;z-index:1}.sg-milestone.svelte-e1wt24.svelte-e1wt24{width:20px !important;min-width:40px;margin-left:-20px}.sg-task.sg-milestone.svelte-e1wt24.svelte-e1wt24{background:transparent}.sg-milestone.svelte-e1wt24 .sg-milestone__diamond.svelte-e1wt24{position:relative}.sg-milestone.svelte-e1wt24 .sg-milestone__diamond.svelte-e1wt24:before{position:absolute;top:0;left:50%;content:' ';height:28px;width:28px;transform-origin:0 0;transform:rotate(45deg)}.sg-milestone__diamond:before{background:rgb(116, 191, 255)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFzay5zdmVsdGUiLCJzb3VyY2VzIjpbIlRhc2suc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+aW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5pbXBvcnQgeyBub3JtYWxpemVDbGFzc0F0dHIgfSBmcm9tICcuLi91dGlscy9kb20nO1xuaW1wb3J0IHsgaXNSZXNpemFibGUgfSBmcm9tICcuLi91dGlscy91dGlscyc7XG5leHBvcnQgbGV0IG1vZGVsO1xuZXhwb3J0IGxldCBoZWlnaHQ7XG5leHBvcnQgbGV0IGxlZnQ7XG5leHBvcnQgbGV0IHRvcDtcbmV4cG9ydCBsZXQgd2lkdGg7XG5leHBvcnQgbGV0IHJlZmxlY3RlZCA9IGZhbHNlO1xuZXhwb3J0IGxldCBhbmltYXRpbmcgPSB0cnVlO1xuZXhwb3J0IGxldCBkcmFnZ2luZyA9IGZhbHNlO1xuZXhwb3J0IGxldCByZXNpemluZyA9IGZhbHNlO1xuY29uc3QgeyByb3dTdG9yZSB9ID0gZ2V0Q29udGV4dCgnZGF0YVN0b3JlJyk7XG5jb25zdCB7IHRhc2tDb250ZW50LCBvblRhc2tCdXR0b25DbGljaywgdGFza0VsZW1lbnRIb29rIH0gPSBnZXRDb250ZXh0KCdvcHRpb25zJyk7XG5jb25zdCB7IHNlbGVjdGlvbk1hbmFnZXIgfSA9IGdldENvbnRleHQoJ3NlcnZpY2VzJyk7XG5jb25zdCBzZWxlY3RlZFRhc2tzID0gc2VsZWN0aW9uTWFuYWdlci5fc2VsZWN0ZWRUYXNrcztcbmxldCBfaWdub3JlQ2xpY2sgPSBmYWxzZTtcbmZ1bmN0aW9uIHRhc2tFbGVtZW50KG5vZGUsIG1vZGVsKSB7XG4gICAgaWYgKHRhc2tFbGVtZW50SG9vaykge1xuICAgICAgICByZXR1cm4gdGFza0VsZW1lbnRIb29rKG5vZGUsIG1vZGVsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBvbkNsaWNrKGV2ZW50KSB7XG4gICAgaWYgKG9uVGFza0J1dHRvbkNsaWNrKSB7XG4gICAgICAgIG9uVGFza0J1dHRvbkNsaWNrKG1vZGVsLCBldmVudCk7XG4gICAgfVxufVxuJDogY2xhc3NlcyA9IG1vZGVsLmNsYXNzZXMgPyBub3JtYWxpemVDbGFzc0F0dHIobW9kZWwuY2xhc3NlcykgOiAnc2ctdGFzay1kZWZhdWx0JztcbmxldCByZXNpemVFbmFibGVkO1xuJDoge1xuICAgIGNvbnN0IHJvdyA9ICRyb3dTdG9yZS5lbnRpdGllc1ttb2RlbC5yZXNvdXJjZUlkXTtcbiAgICByZXNpemVFbmFibGVkID0gbW9kZWwudHlwZSAhPT0gJ21pbGVzdG9uZScgJiYgcm93ICYmIGlzUmVzaXphYmxlKHJvdy5tb2RlbCkgJiYgaXNSZXNpemFibGUobW9kZWwpO1xufVxubGV0IF9tb3Zpbmc7XG4kOiB7XG4gICAgX21vdmluZyA9IGRyYWdnaW5nIHx8IHJlc2l6aW5nO1xufVxuPC9zY3JpcHQ+XG5cbjxkaXZcbiAgICBkYXRhLXRhc2staWQ9e21vZGVsLmlkfVxuICAgIHVzZTp0YXNrRWxlbWVudD17bW9kZWx9XG4gICAgY2xhc3M9XCJzZy10YXNrIHtjbGFzc2VzfVwiXG4gICAgY2xhc3M6c2ctbWlsZXN0b25lPXttb2RlbC50eXBlID09PSAnbWlsZXN0b25lJ31cbiAgICBzdHlsZT1cIndpZHRoOnt3aWR0aH1weDsgaGVpZ2h0OntoZWlnaHR9cHg7IGxlZnQ6IHtsZWZ0fXB4OyB0b3A6IHt0b3B9cHg7XCJcbiAgICBjbGFzczptb3Zpbmc9e19tb3Zpbmd9XG4gICAgY2xhc3M6YW5pbWF0aW5nPXthbmltYXRpbmd9XG4gICAgY2xhc3M6c2ctdGFzay1yZWZsZWN0ZWQ9e3JlZmxlY3RlZH1cbiAgICBjbGFzczpzZy10YXNrLXNlbGVjdGVkPXskc2VsZWN0ZWRUYXNrc1ttb2RlbC5pZF19XG4gICAgY2xhc3M6cmVzaXplLWVuYWJsZWQ9e3Jlc2l6ZUVuYWJsZWR9XG4gICAgY2xhc3M6c2ctdGFzay0tc3RpY2t5PXttb2RlbC5zdGlja3lMYWJlbH1cbiAgICBjbGFzczpzZy1pZ25vcmUtY2xpY2s9e19pZ25vcmVDbGlja31cbiAgICBjbGFzczpzZy10YXNrLWluc3RhbnQ9e3dpZHRoID09PSAwfVxuICAgIG9uOnBvaW50ZXJkb3duXG4+XG4gICAgeyNpZiBtb2RlbC50eXBlID09PSAnbWlsZXN0b25lJ31cbiAgICAgICAgPGRpdiBjbGFzcz1cInNnLW1pbGVzdG9uZV9fZGlhbW9uZFwiPjwvZGl2PlxuICAgIHsvaWZ9XG4gICAgeyNpZiBtb2RlbC5hbW91bnREb25lfVxuICAgICAgICA8ZGl2IGNsYXNzPVwic2ctdGFzay1iYWNrZ3JvdW5kXCIgc3R5bGU9XCJ3aWR0aDp7bW9kZWwuYW1vdW50RG9uZX0lXCIgLz5cbiAgICB7L2lmfVxuICAgIDxkaXYgY2xhc3M9XCJzZy10YXNrLWNvbnRlbnRcIj5cbiAgICAgICAgeyNpZiBtb2RlbC5odG1sfVxuICAgICAgICAgICAge0BodG1sIG1vZGVsLmh0bWx9XG4gICAgICAgIHs6ZWxzZSBpZiB0YXNrQ29udGVudH1cbiAgICAgICAgICAgIHtAaHRtbCB0YXNrQ29udGVudChtb2RlbCl9XG4gICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgIHttb2RlbC5sYWJlbH1cbiAgICAgICAgey9pZn1cbiAgICAgICAgeyNpZiBtb2RlbC5zaG93QnV0dG9ufVxuICAgICAgICAgICAgPCEtLSBzdmVsdGUtaWdub3JlIGExMXktY2xpY2stZXZlbnRzLWhhdmUta2V5LWV2ZW50cyAtLT5cbiAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJzZy10YXNrLWJ1dHRvbiB7bW9kZWwuYnV0dG9uQ2xhc3Nlc31cIlxuICAgICAgICAgICAgICAgIG9uOmNsaWNrPXtvbkNsaWNrfVxuICAgICAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge0BodG1sIG1vZGVsLmJ1dHRvbkh0bWx9XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIHsvaWZ9XG4gICAgPC9kaXY+XG5cbiAgICB7I2lmIG1vZGVsLmxhYmVsQm90dG9tfVxuICAgICAgICA8c3BhbiBjbGFzcz1cInNnLWxhYmVsLWJvdHRvbVwiPnttb2RlbC5sYWJlbEJvdHRvbX08L3NwYW4+XG4gICAgey9pZn1cbjwvZGl2PlxuXG48c3R5bGU+XG4gICAgLnNnLWxhYmVsLWJvdHRvbSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiBjYWxjKDEwMCUgKyAxMHB4KTtcbiAgICAgICAgY29sb3I6ICM4ODg7XG4gICAgfVxuXG4gICAgLnNnLXRhc2sge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcblxuICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgICAgICAvKiBvdmVyZmxvdzogaGlkZGVuOyAqL1xuXG4gICAgICAgIHRyYW5zaXRpb246XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yIDAuMnMsXG4gICAgICAgICAgICBvcGFjaXR5IDAuMnM7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XG4gICAgICAgIC8qIGRpc2FibGUgbW9iaWxlIHBhbi96b29tIG9uIGRyYWcgKi9cbiAgICAgICAgdG91Y2gtYWN0aW9uOiBub25lO1xuICAgIH1cblxuICAgIC5zZy10YXNrLWJhY2tncm91bmQge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgdG9wOiAwO1xuICAgIH1cblxuICAgIC5zZy10YXNrLWNvbnRlbnQge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgdG9wOiAwO1xuXG4gICAgICAgIHBhZGRpbmctbGVmdDogMTRweDtcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgIH1cblxuICAgIC5zZy10YXNrLmFuaW1hdGluZzpub3QoLm1vdmluZyksXG4gICAgLnNnLXRhc2stLXN0aWNreTpub3QoLm1vdmluZykge1xuICAgICAgICB0cmFuc2l0aW9uOlxuICAgICAgICAgICAgbGVmdCAwLjJzLFxuICAgICAgICAgICAgdG9wIDAuMnMsXG4gICAgICAgICAgICB0cmFuc2Zvcm0gMC4ycyxcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3IgMC4ycyxcbiAgICAgICAgICAgIHdpZHRoIDAuMnMsXG4gICAgICAgICAgICBoZWlnaHQgMC4ycztcbiAgICB9XG5cbiAgICAuc2ctdGFzay0tc3RpY2t5ID4gLnNnLXRhc2stY29udGVudCB7XG4gICAgICAgIHBvc2l0aW9uOiBzdGlja3k7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIG1heC13aWR0aDogMTAwcHg7XG4gICAgfVxuXG4gICAgLnNnLXRhc2subW92aW5nIHtcbiAgICAgICAgei1pbmRleDogMTAwMDA7XG4gICAgICAgIG9wYWNpdHk6IDAuNTtcbiAgICB9XG5cbiAgICAuc2ctdGFzay5yZXNpemUtZW5hYmxlZDpob3Zlcjo6YmVmb3JlLFxuICAgIC5zZy10YXNrLnJlc2l6ZS1lbmFibGVkOmhvdmVyOjphZnRlciB7XG4gICAgICAgIGNvbnRlbnQ6ICcnO1xuICAgICAgICB3aWR0aDogNHB4O1xuICAgICAgICBoZWlnaHQ6IDUwJTtcbiAgICAgICAgdG9wOiAyNSU7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1zZy10YXNrLXJlc2l6ZS1jb2xvcik7XG4gICAgICAgIGN1cnNvcjogZXctcmVzaXplO1xuICAgICAgICBib3JkZXItd2lkdGg6IDAgMXB4O1xuICAgICAgICB6LWluZGV4OiAxO1xuICAgIH1cblxuICAgIC5zZy10YXNrLnJlc2l6ZS1lbmFibGVkOmhvdmVyOjpiZWZvcmUge1xuICAgICAgICBtYXJnaW4tbGVmdDogM3B4O1xuICAgICAgICBsZWZ0OiAwO1xuICAgIH1cblxuICAgIC5zZy10YXNrLnJlc2l6ZS1lbmFibGVkOmhvdmVyOjphZnRlciB7XG4gICAgICAgIG1hcmdpbi1yaWdodDogM3B4O1xuICAgICAgICByaWdodDogMDtcbiAgICB9XG5cbiAgICAuc2ctdGFzay1yZWZsZWN0ZWQge1xuICAgICAgICBvcGFjaXR5OiAwLjU7XG4gICAgfVxuXG4gICAgLnNnLXRhc2staW5zdGFudCB7XG4gICAgICAgIHdpZHRoOiAycHggIWltcG9ydGFudDtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IC0xcHg7XG4gICAgfVxuXG4gICAgLnNnLXRhc2stYmFja2dyb3VuZCB7XG4gICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4yKTtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5zZy10YXNrLWRlZmF1bHQpIHtcbiAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICBiYWNrZ3JvdW5kOiByZ2IoMTE2LCAxOTEsIDI1NSk7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguc2ctdGFzay1kZWZhdWx0OmhvdmVyKSB7XG4gICAgICAgIGJhY2tncm91bmQ6IHJnYig5OCwgMTYxLCAyMTYpO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLnNnLXRhc2stZGVmYXVsdC5zZWxlY3RlZCkge1xuICAgICAgICBiYWNrZ3JvdW5kOiByZ2IoNjksIDExMiwgMTUwKTtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5zZy10YXNrLXNlbGVjdGVkKSB7XG4gICAgICAgIG91dGxpbmU6IDJweCBzb2xpZCB2YXIoLS1zZy10YXNrLXNlbGVjdGVkLW91dGxpbmUtY29sb3IpO1xuICAgICAgICBvdXRsaW5lLW9mZnNldDogM3B4O1xuICAgICAgICB6LWluZGV4OiAxO1xuICAgIH1cblxuICAgIC5zZy1taWxlc3RvbmUge1xuICAgICAgICAvKiBoZWlnaHQ6IDIwcHg7ICovXG4gICAgICAgIHdpZHRoOiAyMHB4ICFpbXBvcnRhbnQ7XG4gICAgICAgIG1pbi13aWR0aDogNDBweDtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IC0yMHB4O1xuICAgIH1cblxuICAgIC5zZy10YXNrLnNnLW1pbGVzdG9uZSB7XG4gICAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICAgIH1cblxuICAgIC5zZy1taWxlc3RvbmUgLnNnLW1pbGVzdG9uZV9fZGlhbW9uZCB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB9XG5cbiAgICAuc2ctbWlsZXN0b25lIC5zZy1taWxlc3RvbmVfX2RpYW1vbmQ6YmVmb3JlIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDUwJTtcbiAgICAgICAgY29udGVudDogJyAnO1xuICAgICAgICBoZWlnaHQ6IDI4cHg7XG4gICAgICAgIHdpZHRoOiAyOHB4O1xuICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiAwIDA7XG4gICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5zZy1taWxlc3RvbmVfX2RpYW1vbmQ6YmVmb3JlKSB7XG4gICAgICAgIGJhY2tncm91bmQ6IHJnYigxMTYsIDE5MSwgMjU1KTtcbiAgICB9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXdGSSw0Q0FBaUIsQ0FDYixRQUFRLENBQUUsUUFBUSxDQUNsQixHQUFHLENBQUUsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUN0QixLQUFLLENBQUUsSUFDWCxDQUVBLG9DQUFTLENBQ0wsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsYUFBYSxDQUFFLEdBQUcsQ0FFbEIsV0FBVyxDQUFFLE1BQU0sQ0FHbkIsVUFBVSxDQUNOLGdCQUFnQixDQUFDLElBQUk7QUFDakMsWUFBWSxPQUFPLENBQUMsSUFBSSxDQUNoQixjQUFjLENBQUUsR0FBRyxDQUVuQixZQUFZLENBQUUsSUFDbEIsQ0FFQSwrQ0FBb0IsQ0FDaEIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsTUFBTSxDQUFFLElBQUksQ0FDWixHQUFHLENBQUUsQ0FDVCxDQUVBLDRDQUFpQixDQUNiLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLE1BQU0sQ0FBRSxJQUFJLENBQ1osR0FBRyxDQUFFLENBQUMsQ0FFTixZQUFZLENBQUUsSUFBSSxDQUNsQixTQUFTLENBQUUsSUFBSSxDQUNmLE9BQU8sQ0FBRSxJQUFJLENBQ2IsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsZUFBZSxDQUFFLFVBQVUsQ0FDM0IsV0FBVyxDQUFFLElBQ2pCLENBRUEsUUFBUSxzQ0FBVSxLQUFLLE9BQU8sQ0FBQyxDQUMvQiw0Q0FBZ0IsS0FBSyxPQUFPLENBQUUsQ0FDMUIsVUFBVSxDQUNOLElBQUksQ0FBQyxJQUFJO0FBQ3JCLFlBQVksR0FBRyxDQUFDLElBQUk7QUFDcEIsWUFBWSxTQUFTLENBQUMsSUFBSTtBQUMxQixZQUFZLGdCQUFnQixDQUFDLElBQUk7QUFDakMsWUFBWSxLQUFLLENBQUMsSUFBSTtBQUN0QixZQUFZLE1BQU0sQ0FBQyxJQUNmLENBRUEsOEJBQWdCLENBQUcsOEJBQWlCLENBQ2hDLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLElBQUksQ0FBRSxDQUFDLENBQ1AsU0FBUyxDQUFFLEtBQ2YsQ0FFQSxRQUFRLG1DQUFRLENBQ1osT0FBTyxDQUFFLEtBQUssQ0FDZCxPQUFPLENBQUUsR0FDYixDQUVBLFFBQVEsMkNBQWUsTUFBTSxRQUFRLENBQ3JDLFFBQVEsMkNBQWUsTUFBTSxPQUFRLENBQ2pDLE9BQU8sQ0FBRSxFQUFFLENBQ1gsS0FBSyxDQUFFLEdBQUcsQ0FDVixNQUFNLENBQUUsR0FBRyxDQUNYLEdBQUcsQ0FBRSxHQUFHLENBQ1IsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsWUFBWSxDQUFFLEtBQUssQ0FDbkIsWUFBWSxDQUFFLElBQUksc0JBQXNCLENBQUMsQ0FDekMsTUFBTSxDQUFFLFNBQVMsQ0FDakIsWUFBWSxDQUFFLENBQUMsQ0FBQyxHQUFHLENBQ25CLE9BQU8sQ0FBRSxDQUNiLENBRUEsUUFBUSwyQ0FBZSxNQUFNLFFBQVMsQ0FDbEMsV0FBVyxDQUFFLEdBQUcsQ0FDaEIsSUFBSSxDQUFFLENBQ1YsQ0FFQSxRQUFRLDJDQUFlLE1BQU0sT0FBUSxDQUNqQyxZQUFZLENBQUUsR0FBRyxDQUNqQixLQUFLLENBQUUsQ0FDWCxDQUVBLDhDQUFtQixDQUNmLE9BQU8sQ0FBRSxHQUNiLENBRUEsNENBQWlCLENBQ2IsS0FBSyxDQUFFLEdBQUcsQ0FBQyxVQUFVLENBQ3JCLFdBQVcsQ0FBRSxJQUNqQixDQUVBLCtDQUFvQixDQUNoQixVQUFVLENBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQ2pDLENBRVEsZ0JBQWtCLENBQ3RCLEtBQUssQ0FBRSxLQUFLLENBQ1osVUFBVSxDQUFFLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUNqQyxDQUVRLHNCQUF3QixDQUM1QixVQUFVLENBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQ2hDLENBRVEseUJBQTJCLENBQy9CLFVBQVUsQ0FBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FDaEMsQ0FFUSxpQkFBbUIsQ0FDdkIsT0FBTyxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxnQ0FBZ0MsQ0FBQyxDQUN4RCxjQUFjLENBQUUsR0FBRyxDQUNuQixPQUFPLENBQUUsQ0FDYixDQUVBLHlDQUFjLENBRVYsS0FBSyxDQUFFLElBQUksQ0FBQyxVQUFVLENBQ3RCLFNBQVMsQ0FBRSxJQUFJLENBQ2YsV0FBVyxDQUFFLEtBQ2pCLENBRUEsUUFBUSx5Q0FBYyxDQUNsQixVQUFVLENBQUUsV0FDaEIsQ0FFQSwyQkFBYSxDQUFDLG9DQUF1QixDQUNqQyxRQUFRLENBQUUsUUFDZCxDQUVBLDJCQUFhLENBQUMsb0NBQXNCLE9BQVEsQ0FDeEMsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLENBQUMsQ0FDTixJQUFJLENBQUUsR0FBRyxDQUNULE9BQU8sQ0FBRSxHQUFHLENBQ1osTUFBTSxDQUFFLElBQUksQ0FDWixLQUFLLENBQUUsSUFBSSxDQUNYLGdCQUFnQixDQUFFLENBQUMsQ0FBQyxDQUFDLENBQ3JCLFNBQVMsQ0FBRSxPQUFPLEtBQUssQ0FDM0IsQ0FFUSw2QkFBK0IsQ0FDbkMsVUFBVSxDQUFFLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUNqQyJ9 */");
}
function create_if_block_5(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "sg-milestone__diamond svelte-e1wt24");
      add_location(div, file, 56, 8, 1772);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(56:4) {#if model.type === 'milestone'}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "sg-task-background svelte-e1wt24");
      set_style(
        div,
        "width",
        /*model*/
        ctx[0].amountDone + "%"
      );
      add_location(div, file, 59, 8, 1859);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*model*/
      1) {
        set_style(
          div,
          "width",
          /*model*/
          ctx2[0].amountDone + "%"
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(59:4) {#if model.amountDone}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let t_value = (
    /*model*/
    ctx[0].label + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*model*/
      1 && t_value !== (t_value = /*model*/
      ctx2[0].label + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(67:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let html_tag;
  let raw_value = (
    /*taskContent*/
    ctx[12](
      /*model*/
      ctx[0]
    ) + ""
  );
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*model*/
      1 && raw_value !== (raw_value = /*taskContent*/
      ctx2[12](
        /*model*/
        ctx2[0]
      ) + "")) html_tag.p(raw_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(65:30) ",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let html_tag;
  let raw_value = (
    /*model*/
    ctx[0].html + ""
  );
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*model*/
      1 && raw_value !== (raw_value = /*model*/
      ctx2[0].html + "")) html_tag.p(raw_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(63:8) {#if model.html}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let span;
  let raw_value = (
    /*model*/
    ctx[0].buttonHtml + ""
  );
  let span_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      span = element("span");
      attr_dev(span, "class", span_class_value = "sg-task-button " + /*model*/
      ctx[0].buttonClasses + " svelte-e1wt24");
      attr_dev(span, "role", "button");
      attr_dev(span, "tabindex", "0");
      add_location(span, file, 71, 12, 2266);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      span.innerHTML = raw_value;
      if (!mounted) {
        dispose = listen_dev(
          span,
          "click",
          /*onClick*/
          ctx[16],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*model*/
      1 && raw_value !== (raw_value = /*model*/
      ctx2[0].buttonHtml + "")) span.innerHTML = raw_value;
      ;
      if (dirty & /*model*/
      1 && span_class_value !== (span_class_value = "sg-task-button " + /*model*/
      ctx2[0].buttonClasses + " svelte-e1wt24")) {
        attr_dev(span, "class", span_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(70:8) {#if model.showButton}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let span;
  let t_value = (
    /*model*/
    ctx[0].labelBottom + ""
  );
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      attr_dev(span, "class", "sg-label-bottom svelte-e1wt24");
      add_location(span, file, 83, 8, 2564);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*model*/
      1 && t_value !== (t_value = /*model*/
      ctx2[0].labelBottom + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(83:4) {#if model.labelBottom}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div1;
  let t0;
  let t1;
  let div0;
  let t2;
  let t3;
  let div1_data_task_id_value;
  let div1_class_value;
  let taskElement_action;
  let mounted;
  let dispose;
  let if_block0 = (
    /*model*/
    ctx[0].type === "milestone" && create_if_block_5(ctx)
  );
  let if_block1 = (
    /*model*/
    ctx[0].amountDone && create_if_block_4(ctx)
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*model*/
      ctx2[0].html
    ) return create_if_block_2;
    if (
      /*taskContent*/
      ctx2[12]
    ) return create_if_block_3;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block2 = current_block_type(ctx);
  let if_block3 = (
    /*model*/
    ctx[0].showButton && create_if_block_1(ctx)
  );
  let if_block4 = (
    /*model*/
    ctx[0].labelBottom && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      div0 = element("div");
      if_block2.c();
      t2 = space();
      if (if_block3) if_block3.c();
      t3 = space();
      if (if_block4) if_block4.c();
      attr_dev(div0, "class", "sg-task-content svelte-e1wt24");
      add_location(div0, file, 61, 4, 1942);
      attr_dev(div1, "data-task-id", div1_data_task_id_value = /*model*/
      ctx[0].id);
      attr_dev(div1, "class", div1_class_value = "sg-task " + /*classes*/
      ctx[9] + " svelte-e1wt24");
      set_style(
        div1,
        "width",
        /*width*/
        ctx[4] + "px"
      );
      set_style(
        div1,
        "height",
        /*height*/
        ctx[1] + "px"
      );
      set_style(
        div1,
        "left",
        /*left*/
        ctx[2] + "px"
      );
      set_style(
        div1,
        "top",
        /*top*/
        ctx[3] + "px"
      );
      toggle_class(
        div1,
        "sg-milestone",
        /*model*/
        ctx[0].type === "milestone"
      );
      toggle_class(
        div1,
        "moving",
        /*_moving*/
        ctx[8]
      );
      toggle_class(
        div1,
        "animating",
        /*animating*/
        ctx[6]
      );
      toggle_class(
        div1,
        "sg-task-reflected",
        /*reflected*/
        ctx[5]
      );
      toggle_class(
        div1,
        "sg-task-selected",
        /*$selectedTasks*/
        ctx[10][
          /*model*/
          ctx[0].id
        ]
      );
      toggle_class(
        div1,
        "resize-enabled",
        /*resizeEnabled*/
        ctx[7]
      );
      toggle_class(
        div1,
        "sg-task--sticky",
        /*model*/
        ctx[0].stickyLabel
      );
      toggle_class(
        div1,
        "sg-ignore-click",
        /*_ignoreClick*/
        ctx[14]
      );
      toggle_class(
        div1,
        "sg-task-instant",
        /*width*/
        ctx[4] === 0
      );
      add_location(div1, file, 39, 0, 1164);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      if (if_block0) if_block0.m(div1, null);
      append_dev(div1, t0);
      if (if_block1) if_block1.m(div1, null);
      append_dev(div1, t1);
      append_dev(div1, div0);
      if_block2.m(div0, null);
      append_dev(div0, t2);
      if (if_block3) if_block3.m(div0, null);
      append_dev(div1, t3);
      if (if_block4) if_block4.m(div1, null);
      if (!mounted) {
        dispose = [
          action_destroyer(taskElement_action = /*taskElement*/
          ctx[15].call(
            null,
            div1,
            /*model*/
            ctx[0]
          )),
          listen_dev(
            div1,
            "pointerdown",
            /*pointerdown_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*model*/
        ctx2[0].type === "milestone"
      ) {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_5(ctx2);
          if_block0.c();
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*model*/
        ctx2[0].amountDone
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_4(ctx2);
          if_block1.c();
          if_block1.m(div1, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block2) {
        if_block2.p(ctx2, dirty);
      } else {
        if_block2.d(1);
        if_block2 = current_block_type(ctx2);
        if (if_block2) {
          if_block2.c();
          if_block2.m(div0, t2);
        }
      }
      if (
        /*model*/
        ctx2[0].showButton
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_1(ctx2);
          if_block3.c();
          if_block3.m(div0, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (
        /*model*/
        ctx2[0].labelBottom
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block(ctx2);
          if_block4.c();
          if_block4.m(div1, null);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (dirty & /*model*/
      1 && div1_data_task_id_value !== (div1_data_task_id_value = /*model*/
      ctx2[0].id)) {
        attr_dev(div1, "data-task-id", div1_data_task_id_value);
      }
      if (dirty & /*classes*/
      512 && div1_class_value !== (div1_class_value = "sg-task " + /*classes*/
      ctx2[9] + " svelte-e1wt24")) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (dirty & /*width*/
      16) {
        set_style(
          div1,
          "width",
          /*width*/
          ctx2[4] + "px"
        );
      }
      if (dirty & /*height*/
      2) {
        set_style(
          div1,
          "height",
          /*height*/
          ctx2[1] + "px"
        );
      }
      if (dirty & /*left*/
      4) {
        set_style(
          div1,
          "left",
          /*left*/
          ctx2[2] + "px"
        );
      }
      if (dirty & /*top*/
      8) {
        set_style(
          div1,
          "top",
          /*top*/
          ctx2[3] + "px"
        );
      }
      if (taskElement_action && is_function(taskElement_action.update) && dirty & /*model*/
      1) taskElement_action.update.call(
        null,
        /*model*/
        ctx2[0]
      );
      if (dirty & /*classes, model*/
      513) {
        toggle_class(
          div1,
          "sg-milestone",
          /*model*/
          ctx2[0].type === "milestone"
        );
      }
      if (dirty & /*classes, _moving*/
      768) {
        toggle_class(
          div1,
          "moving",
          /*_moving*/
          ctx2[8]
        );
      }
      if (dirty & /*classes, animating*/
      576) {
        toggle_class(
          div1,
          "animating",
          /*animating*/
          ctx2[6]
        );
      }
      if (dirty & /*classes, reflected*/
      544) {
        toggle_class(
          div1,
          "sg-task-reflected",
          /*reflected*/
          ctx2[5]
        );
      }
      if (dirty & /*classes, $selectedTasks, model*/
      1537) {
        toggle_class(
          div1,
          "sg-task-selected",
          /*$selectedTasks*/
          ctx2[10][
            /*model*/
            ctx2[0].id
          ]
        );
      }
      if (dirty & /*classes, resizeEnabled*/
      640) {
        toggle_class(
          div1,
          "resize-enabled",
          /*resizeEnabled*/
          ctx2[7]
        );
      }
      if (dirty & /*classes, model*/
      513) {
        toggle_class(
          div1,
          "sg-task--sticky",
          /*model*/
          ctx2[0].stickyLabel
        );
      }
      if (dirty & /*classes, _ignoreClick*/
      16896) {
        toggle_class(
          div1,
          "sg-ignore-click",
          /*_ignoreClick*/
          ctx2[14]
        );
      }
      if (dirty & /*classes, width*/
      528) {
        toggle_class(
          div1,
          "sg-task-instant",
          /*width*/
          ctx2[4] === 0
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if_block2.d();
      if (if_block3) if_block3.d();
      if (if_block4) if_block4.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let classes;
  let $rowStore;
  let $selectedTasks;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Task", slots, []);
  let { model } = $$props;
  let { height } = $$props;
  let { left } = $$props;
  let { top } = $$props;
  let { width } = $$props;
  let { reflected = false } = $$props;
  let { animating = true } = $$props;
  let { dragging = false } = $$props;
  let { resizing = false } = $$props;
  const { rowStore } = getContext("dataStore");
  validate_store(rowStore, "rowStore");
  component_subscribe($$self, rowStore, (value) => $$invalidate(19, $rowStore = value));
  const { taskContent, onTaskButtonClick, taskElementHook } = getContext("options");
  const { selectionManager } = getContext("services");
  const selectedTasks = selectionManager._selectedTasks;
  validate_store(selectedTasks, "selectedTasks");
  component_subscribe($$self, selectedTasks, (value) => $$invalidate(10, $selectedTasks = value));
  let _ignoreClick = false;
  function taskElement(node, model2) {
    if (taskElementHook) {
      return taskElementHook(node, model2);
    }
  }
  function onClick(event) {
    if (onTaskButtonClick) {
      onTaskButtonClick(model, event);
    }
  }
  let resizeEnabled;
  let _moving;
  $$self.$$.on_mount.push(function() {
    if (model === void 0 && !("model" in $$props || $$self.$$.bound[$$self.$$.props["model"]])) {
      console.warn("<Task> was created without expected prop 'model'");
    }
    if (height === void 0 && !("height" in $$props || $$self.$$.bound[$$self.$$.props["height"]])) {
      console.warn("<Task> was created without expected prop 'height'");
    }
    if (left === void 0 && !("left" in $$props || $$self.$$.bound[$$self.$$.props["left"]])) {
      console.warn("<Task> was created without expected prop 'left'");
    }
    if (top === void 0 && !("top" in $$props || $$self.$$.bound[$$self.$$.props["top"]])) {
      console.warn("<Task> was created without expected prop 'top'");
    }
    if (width === void 0 && !("width" in $$props || $$self.$$.bound[$$self.$$.props["width"]])) {
      console.warn("<Task> was created without expected prop 'width'");
    }
  });
  const writable_props = [
    "model",
    "height",
    "left",
    "top",
    "width",
    "reflected",
    "animating",
    "dragging",
    "resizing"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Task> was created with unknown prop '${key}'`);
  });
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2) $$invalidate(0, model = $$props2.model);
    if ("height" in $$props2) $$invalidate(1, height = $$props2.height);
    if ("left" in $$props2) $$invalidate(2, left = $$props2.left);
    if ("top" in $$props2) $$invalidate(3, top = $$props2.top);
    if ("width" in $$props2) $$invalidate(4, width = $$props2.width);
    if ("reflected" in $$props2) $$invalidate(5, reflected = $$props2.reflected);
    if ("animating" in $$props2) $$invalidate(6, animating = $$props2.animating);
    if ("dragging" in $$props2) $$invalidate(17, dragging = $$props2.dragging);
    if ("resizing" in $$props2) $$invalidate(18, resizing = $$props2.resizing);
  };
  $$self.$capture_state = () => ({
    getContext,
    normalizeClassAttr,
    isResizable,
    model,
    height,
    left,
    top,
    width,
    reflected,
    animating,
    dragging,
    resizing,
    rowStore,
    taskContent,
    onTaskButtonClick,
    taskElementHook,
    selectionManager,
    selectedTasks,
    _ignoreClick,
    taskElement,
    onClick,
    resizeEnabled,
    _moving,
    classes,
    $rowStore,
    $selectedTasks
  });
  $$self.$inject_state = ($$props2) => {
    if ("model" in $$props2) $$invalidate(0, model = $$props2.model);
    if ("height" in $$props2) $$invalidate(1, height = $$props2.height);
    if ("left" in $$props2) $$invalidate(2, left = $$props2.left);
    if ("top" in $$props2) $$invalidate(3, top = $$props2.top);
    if ("width" in $$props2) $$invalidate(4, width = $$props2.width);
    if ("reflected" in $$props2) $$invalidate(5, reflected = $$props2.reflected);
    if ("animating" in $$props2) $$invalidate(6, animating = $$props2.animating);
    if ("dragging" in $$props2) $$invalidate(17, dragging = $$props2.dragging);
    if ("resizing" in $$props2) $$invalidate(18, resizing = $$props2.resizing);
    if ("_ignoreClick" in $$props2) $$invalidate(14, _ignoreClick = $$props2._ignoreClick);
    if ("resizeEnabled" in $$props2) $$invalidate(7, resizeEnabled = $$props2.resizeEnabled);
    if ("_moving" in $$props2) $$invalidate(8, _moving = $$props2._moving);
    if ("classes" in $$props2) $$invalidate(9, classes = $$props2.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*model*/
    1) {
      $: $$invalidate(9, classes = model.classes ? normalizeClassAttr(model.classes) : "sg-task-default");
    }
    if ($$self.$$.dirty & /*$rowStore, model*/
    524289) {
      $: {
        const row = $rowStore.entities[model.resourceId];
        $$invalidate(7, resizeEnabled = model.type !== "milestone" && row && isResizable(row.model) && isResizable(model));
      }
    }
    if ($$self.$$.dirty & /*dragging, resizing*/
    393216) {
      $: {
        $$invalidate(8, _moving = dragging || resizing);
      }
    }
  };
  return [
    model,
    height,
    left,
    top,
    width,
    reflected,
    animating,
    resizeEnabled,
    _moving,
    classes,
    $selectedTasks,
    rowStore,
    taskContent,
    selectedTasks,
    _ignoreClick,
    taskElement,
    onClick,
    dragging,
    resizing,
    $rowStore,
    pointerdown_handler
  ];
}
var Task = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        model: 0,
        height: 1,
        left: 2,
        top: 3,
        width: 4,
        reflected: 5,
        animating: 6,
        dragging: 17,
        resizing: 18
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Task",
      options,
      id: create_fragment.name
    });
  }
  get model() {
    throw new Error("<Task>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set model(value) {
    throw new Error("<Task>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Task>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Task>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get left() {
    throw new Error("<Task>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set left(value) {
    throw new Error("<Task>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get top() {
    throw new Error("<Task>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set top(value) {
    throw new Error("<Task>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Task>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Task>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reflected() {
    throw new Error("<Task>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reflected(value) {
    throw new Error("<Task>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animating() {
    throw new Error("<Task>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animating(value) {
    throw new Error("<Task>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dragging() {
    throw new Error("<Task>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dragging(value) {
    throw new Error("<Task>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizing() {
    throw new Error("<Task>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizing(value) {
    throw new Error("<Task>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Task_default = Task;

// node_modules/svelte-gantt/svelte/entities/Row.svelte
var file2 = "node_modules\\svelte-gantt\\svelte\\entities\\Row.svelte";
function add_css2(target) {
  append_styles(target, "svelte-7u5y5s", ".sg-row.svelte-7u5y5s{position:relative;width:100%;box-sizing:border-box}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUm93LnN2ZWx0ZSIsInNvdXJjZXMiOlsiUm93LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PmltcG9ydCB7IG5vcm1hbGl6ZUNsYXNzQXR0ciB9IGZyb20gJy4uL3V0aWxzL2RvbSc7XG5pbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcbmV4cG9ydCBsZXQgcm93O1xuY29uc3QgeyBob3ZlcmVkUm93LCBzZWxlY3RlZFJvdyB9ID0gZ2V0Q29udGV4dCgnZ2FudHQnKTtcbiQ6IGNsYXNzZXMgPSBub3JtYWxpemVDbGFzc0F0dHIocm93Lm1vZGVsLmNsYXNzZXMpO1xuPC9zY3JpcHQ+XG5cbjxkaXZcbiAgICBjbGFzcz1cInNnLXJvdyB7Y2xhc3Nlc31cIlxuICAgIGRhdGEtcm93LWlkPXtyb3cubW9kZWwuaWR9XG4gICAgY2xhc3M6c2ctaG92ZXI9eyRob3ZlcmVkUm93ID09IHJvdy5tb2RlbC5pZH1cbiAgICBjbGFzczpzZy1zZWxlY3RlZD17JHNlbGVjdGVkUm93ID09IHJvdy5tb2RlbC5pZH1cbiAgICBzdHlsZT1cImhlaWdodDp7cm93LmhlaWdodH1weFwiXG4+XG4gICAgeyNpZiByb3cubW9kZWwuY29udGVudEh0bWx9XG4gICAgICAgIHtAaHRtbCByb3cubW9kZWwuY29udGVudEh0bWx9XG4gICAgey9pZn1cbjwvZGl2PlxuXG48c3R5bGU+XG4gICAgLnNnLXJvdyB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFvQkkscUJBQVEsQ0FDSixRQUFRLENBQUUsUUFBUSxDQUNsQixLQUFLLENBQUUsSUFBSSxDQUNYLFVBQVUsQ0FBRSxVQUNoQiJ9 */");
}
function create_if_block2(ctx) {
  let html_tag;
  let raw_value = (
    /*row*/
    ctx[0].model.contentHtml + ""
  );
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*row*/
      1 && raw_value !== (raw_value = /*row*/
      ctx2[0].model.contentHtml + "")) html_tag.p(raw_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(15:4) {#if row.model.contentHtml}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div;
  let div_class_value;
  let div_data_row_id_value;
  let if_block = (
    /*row*/
    ctx[0].model.contentHtml && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block) if_block.c();
      attr_dev(div, "class", div_class_value = "sg-row " + /*classes*/
      ctx[1] + " svelte-7u5y5s");
      attr_dev(div, "data-row-id", div_data_row_id_value = /*row*/
      ctx[0].model.id);
      set_style(
        div,
        "height",
        /*row*/
        ctx[0].height + "px"
      );
      toggle_class(
        div,
        "sg-hover",
        /*$hoveredRow*/
        ctx[2] == /*row*/
        ctx[0].model.id
      );
      toggle_class(
        div,
        "sg-selected",
        /*$selectedRow*/
        ctx[3] == /*row*/
        ctx[0].model.id
      );
      add_location(div, file2, 7, 0, 232);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block) if_block.m(div, null);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*row*/
        ctx2[0].model.contentHtml
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*classes*/
      2 && div_class_value !== (div_class_value = "sg-row " + /*classes*/
      ctx2[1] + " svelte-7u5y5s")) {
        attr_dev(div, "class", div_class_value);
      }
      if (dirty & /*row*/
      1 && div_data_row_id_value !== (div_data_row_id_value = /*row*/
      ctx2[0].model.id)) {
        attr_dev(div, "data-row-id", div_data_row_id_value);
      }
      if (dirty & /*row*/
      1) {
        set_style(
          div,
          "height",
          /*row*/
          ctx2[0].height + "px"
        );
      }
      if (dirty & /*classes, $hoveredRow, row*/
      7) {
        toggle_class(
          div,
          "sg-hover",
          /*$hoveredRow*/
          ctx2[2] == /*row*/
          ctx2[0].model.id
        );
      }
      if (dirty & /*classes, $selectedRow, row*/
      11) {
        toggle_class(
          div,
          "sg-selected",
          /*$selectedRow*/
          ctx2[3] == /*row*/
          ctx2[0].model.id
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let classes;
  let $hoveredRow;
  let $selectedRow;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Row", slots, []);
  let { row } = $$props;
  const { hoveredRow, selectedRow } = getContext("gantt");
  validate_store(hoveredRow, "hoveredRow");
  component_subscribe($$self, hoveredRow, (value) => $$invalidate(2, $hoveredRow = value));
  validate_store(selectedRow, "selectedRow");
  component_subscribe($$self, selectedRow, (value) => $$invalidate(3, $selectedRow = value));
  $$self.$$.on_mount.push(function() {
    if (row === void 0 && !("row" in $$props || $$self.$$.bound[$$self.$$.props["row"]])) {
      console.warn("<Row> was created without expected prop 'row'");
    }
  });
  const writable_props = ["row"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Row> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("row" in $$props2) $$invalidate(0, row = $$props2.row);
  };
  $$self.$capture_state = () => ({
    normalizeClassAttr,
    getContext,
    row,
    hoveredRow,
    selectedRow,
    classes,
    $hoveredRow,
    $selectedRow
  });
  $$self.$inject_state = ($$props2) => {
    if ("row" in $$props2) $$invalidate(0, row = $$props2.row);
    if ("classes" in $$props2) $$invalidate(1, classes = $$props2.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*row*/
    1) {
      $: $$invalidate(1, classes = normalizeClassAttr(row.model.classes));
    }
  };
  return [row, classes, $hoveredRow, $selectedRow, hoveredRow, selectedRow];
}
var Row = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { row: 0 }, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Row",
      options,
      id: create_fragment2.name
    });
  }
  get row() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set row(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Row_default = Row;

// node_modules/svelte-gantt/svelte/entities/TimeRange.svelte
var file3 = "node_modules\\svelte-gantt\\svelte\\entities\\TimeRange.svelte";
function add_css3(target) {
  append_styles(target, "svelte-gvpa16", ".sg-time-range.svelte-gvpa16{height:100%;position:absolute;display:flex;flex-direction:column;align-items:center;background-image:linear-gradient(\n            -45deg,\n            transparent 46%,\n            #e03218 49%,\n            #e03218 51%,\n            transparent 55%\n        );background-size:6px 6px !important;font-weight:400}.sg-time-range-label.svelte-gvpa16{margin-top:10px;background:#fff;color:red;white-space:nowrap;padding:4px;font-weight:400;font-size:10px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGltZVJhbmdlLnN2ZWx0ZSIsInNvdXJjZXMiOlsiVGltZVJhbmdlLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PmltcG9ydCB7IG5vcm1hbGl6ZUNsYXNzQXR0ciB9IGZyb20gJy4uL3V0aWxzL2RvbSc7XG5leHBvcnQgbGV0IG1vZGVsO1xuZXhwb3J0IGxldCBsZWZ0O1xuZXhwb3J0IGxldCB3aWR0aDtcbmV4cG9ydCBsZXQgcmVzaXppbmcgPSBmYWxzZTtcbiQ6IGNsYXNzZXMgPSBub3JtYWxpemVDbGFzc0F0dHIobW9kZWwuY2xhc3Nlcyk7XG48L3NjcmlwdD5cblxuPGRpdlxuICAgIGNsYXNzPVwic2ctdGltZS1yYW5nZSB7Y2xhc3Nlc31cIlxuICAgIGNsYXNzOm1vdmluZz17cmVzaXppbmd9XG4gICAgc3R5bGU9XCJ3aWR0aDp7d2lkdGh9cHg7bGVmdDp7bGVmdH1weFwiXG4+XG4gICAgeyNpZiBtb2RlbC5sYWJlbH1cbiAgICAgICAgPGRpdiBjbGFzcz1cInNnLXRpbWUtcmFuZ2UtbGFiZWxcIj57bW9kZWwubGFiZWx9PC9kaXY+XG4gICAgey9pZn1cbjwvZGl2PlxuXG48c3R5bGU+XG4gICAgLnNnLXRpbWUtcmFuZ2Uge1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcblxuICAgICAgICBiYWNrZ3JvdW5kLWltYWdlOiBsaW5lYXItZ3JhZGllbnQoXG4gICAgICAgICAgICAtNDVkZWcsXG4gICAgICAgICAgICB0cmFuc3BhcmVudCA0NiUsXG4gICAgICAgICAgICAjZTAzMjE4IDQ5JSxcbiAgICAgICAgICAgICNlMDMyMTggNTElLFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQgNTUlXG4gICAgICAgICk7XG4gICAgICAgIGJhY2tncm91bmQtc2l6ZTogNnB4IDZweCAhaW1wb3J0YW50O1xuICAgICAgICBmb250LXdlaWdodDogNDAwO1xuICAgIH1cblxuICAgIC5zZy10aW1lLXJhbmdlLWxhYmVsIHtcbiAgICAgICAgbWFyZ2luLXRvcDogMTBweDtcbiAgICAgICAgYmFja2dyb3VuZDogI2ZmZjtcbiAgICAgICAgY29sb3I6IHJlZDtcbiAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICAgICAgcGFkZGluZzogNHB4O1xuICAgICAgICBmb250LXdlaWdodDogNDAwO1xuICAgICAgICBmb250LXNpemU6IDEwcHg7XG4gICAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFtQkksNEJBQWUsQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsY0FBYyxDQUFFLE1BQU0sQ0FDdEIsV0FBVyxDQUFFLE1BQU0sQ0FFbkIsZ0JBQWdCLENBQUU7QUFDMUIsWUFBWSxNQUFNO0FBQ2xCLFlBQVksV0FBVyxDQUFDLEdBQUc7QUFDM0IsWUFBWSxPQUFPLENBQUMsR0FBRztBQUN2QixZQUFZLE9BQU8sQ0FBQyxHQUFHO0FBQ3ZCLFlBQVksV0FBVyxDQUFDO0FBQ3hCLFNBQVMsQ0FDRCxlQUFlLENBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQ25DLFdBQVcsQ0FBRSxHQUNqQixDQUVBLGtDQUFxQixDQUNqQixVQUFVLENBQUUsSUFBSSxDQUNoQixVQUFVLENBQUUsSUFBSSxDQUNoQixLQUFLLENBQUUsR0FBRyxDQUNWLFdBQVcsQ0FBRSxNQUFNLENBQ25CLE9BQU8sQ0FBRSxHQUFHLENBQ1osV0FBVyxDQUFFLEdBQUcsQ0FDaEIsU0FBUyxDQUFFLElBQ2YifQ== */");
}
function create_if_block3(ctx) {
  let div;
  let t_value = (
    /*model*/
    ctx[0].label + ""
  );
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(t_value);
      attr_dev(div, "class", "sg-time-range-label svelte-gvpa16");
      add_location(div, file3, 14, 8, 343);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*model*/
      1 && t_value !== (t_value = /*model*/
      ctx2[0].label + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(14:4) {#if model.label}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let div;
  let div_class_value;
  let if_block = (
    /*model*/
    ctx[0].label && create_if_block3(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block) if_block.c();
      attr_dev(div, "class", div_class_value = "sg-time-range " + /*classes*/
      ctx[4] + " svelte-gvpa16");
      set_style(
        div,
        "width",
        /*width*/
        ctx[2] + "px"
      );
      set_style(
        div,
        "left",
        /*left*/
        ctx[1] + "px"
      );
      toggle_class(
        div,
        "moving",
        /*resizing*/
        ctx[3]
      );
      add_location(div, file3, 8, 0, 200);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block) if_block.m(div, null);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*model*/
        ctx2[0].label
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*classes*/
      16 && div_class_value !== (div_class_value = "sg-time-range " + /*classes*/
      ctx2[4] + " svelte-gvpa16")) {
        attr_dev(div, "class", div_class_value);
      }
      if (dirty & /*width*/
      4) {
        set_style(
          div,
          "width",
          /*width*/
          ctx2[2] + "px"
        );
      }
      if (dirty & /*left*/
      2) {
        set_style(
          div,
          "left",
          /*left*/
          ctx2[1] + "px"
        );
      }
      if (dirty & /*classes, resizing*/
      24) {
        toggle_class(
          div,
          "moving",
          /*resizing*/
          ctx2[3]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let classes;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TimeRange", slots, []);
  let { model } = $$props;
  let { left } = $$props;
  let { width } = $$props;
  let { resizing = false } = $$props;
  $$self.$$.on_mount.push(function() {
    if (model === void 0 && !("model" in $$props || $$self.$$.bound[$$self.$$.props["model"]])) {
      console.warn("<TimeRange> was created without expected prop 'model'");
    }
    if (left === void 0 && !("left" in $$props || $$self.$$.bound[$$self.$$.props["left"]])) {
      console.warn("<TimeRange> was created without expected prop 'left'");
    }
    if (width === void 0 && !("width" in $$props || $$self.$$.bound[$$self.$$.props["width"]])) {
      console.warn("<TimeRange> was created without expected prop 'width'");
    }
  });
  const writable_props = ["model", "left", "width", "resizing"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<TimeRange> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2) $$invalidate(0, model = $$props2.model);
    if ("left" in $$props2) $$invalidate(1, left = $$props2.left);
    if ("width" in $$props2) $$invalidate(2, width = $$props2.width);
    if ("resizing" in $$props2) $$invalidate(3, resizing = $$props2.resizing);
  };
  $$self.$capture_state = () => ({
    normalizeClassAttr,
    model,
    left,
    width,
    resizing,
    classes
  });
  $$self.$inject_state = ($$props2) => {
    if ("model" in $$props2) $$invalidate(0, model = $$props2.model);
    if ("left" in $$props2) $$invalidate(1, left = $$props2.left);
    if ("width" in $$props2) $$invalidate(2, width = $$props2.width);
    if ("resizing" in $$props2) $$invalidate(3, resizing = $$props2.resizing);
    if ("classes" in $$props2) $$invalidate(4, classes = $$props2.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*model*/
    1) {
      $: $$invalidate(4, classes = normalizeClassAttr(model.classes));
    }
  };
  return [model, left, width, resizing, classes];
}
var TimeRange = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { model: 0, left: 1, width: 2, resizing: 3 }, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TimeRange",
      options,
      id: create_fragment3.name
    });
  }
  get model() {
    throw new Error("<TimeRange>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set model(value) {
    throw new Error("<TimeRange>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get left() {
    throw new Error("<TimeRange>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set left(value) {
    throw new Error("<TimeRange>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<TimeRange>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<TimeRange>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizing() {
    throw new Error("<TimeRange>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizing(value) {
    throw new Error("<TimeRange>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TimeRange_default = TimeRange;

// node_modules/svelte-gantt/svelte/core/constants.js
var MIN_DRAG_X = 2;
var MIN_DRAG_Y = 2;

// node_modules/svelte-gantt/svelte/core/drag/draggable.js
function getAccessor(accessor) {
  if (accessor instanceof Function) {
    return () => accessor();
  } else {
    return () => accessor;
  }
}
function useDraggable(node, options) {
  const onMousedown = createDraggable(options);
  node.addEventListener("pointerdown", onMousedown);
  return {
    destroy() {
      node.removeEventListener("pointerdown", onMousedown, false);
    }
  };
}
function createDraggable(options) {
  let mouseStartPosX;
  let mouseStartPosY;
  let mouseStartRight;
  let direction;
  let dragging = false;
  let resizing = false;
  let initialX;
  let initialY;
  let triggered = false;
  const dragAllowed = getAccessor(options.dragAllowed);
  const resizeAllowed = getAccessor(options.resizeAllowed);
  function onMousedown(event) {
    if (!isLeftClick(event)) {
      return;
    }
    event.stopPropagation();
    event.preventDefault();
    const canDrag = dragAllowed();
    const canResize = resizeAllowed();
    if (!canDrag && !canResize) {
      return;
    }
    const x = options.getX(event);
    const y = options.getY(event);
    const width = options.getWidth();
    initialX = event.clientX;
    initialY = event.clientY;
    mouseStartRight = x + width;
    mouseStartPosX = getRelativePos(options.container, event).x - x;
    mouseStartPosY = getRelativePos(options.container, event).y - y;
    if (canResize && mouseStartPosX <= options.resizeHandleWidth) {
      direction = "left";
      resizing = true;
    }
    if (canResize && mouseStartPosX >= width - options.resizeHandleWidth) {
      direction = "right";
      resizing = true;
    }
    if (canDrag && !resizing) {
      dragging = true;
    }
    if ((dragging || resizing) && options.onDown) {
      options.onDown({
        mouseEvent: event,
        x,
        width,
        y,
        resizing,
        dragging
      });
    }
    window.addEventListener("pointermove", onMousemove, false);
    addEventListenerOnce(window, "pointerup", onMouseup);
  }
  ;
  function onMousemove(event) {
    if (!triggered) {
      if (Math.abs(event.clientX - initialX) > MIN_DRAG_X || Math.abs(event.clientY - initialY) > MIN_DRAG_Y) {
        triggered = true;
      } else {
        return;
      }
    }
    event.preventDefault();
    if (resizing) {
      const mousePos = getRelativePos(options.container, event);
      const x = options.getX(event);
      const width = options.getWidth();
      let resultX;
      let resultWidth;
      if (direction === "left") {
        if (mouseStartRight - mousePos.x <= 0) {
          direction = "right";
          resultX = mouseStartRight;
          resultWidth = mouseStartRight - mousePos.x;
          mouseStartRight = mouseStartRight + width;
        } else {
          resultX = mousePos.x;
          resultWidth = mouseStartRight - mousePos.x;
        }
      } else if (direction === "right") {
        if (mousePos.x - x <= 0) {
          direction = "left";
          resultX = mousePos.x;
          resultWidth = mousePos.x - x;
          mouseStartRight = x;
        } else {
          resultX = x;
          resultWidth = mousePos.x - x;
        }
      }
      if (options.onResize) {
        options.onResize({
          x: resultX,
          width: resultWidth,
          event
        });
      }
    }
    if (dragging && options.onDrag) {
      const mousePos = getRelativePos(options.container, event);
      options.onDrag({
        x: mousePos.x - mouseStartPosX,
        // maybe this is the rounding error
        y: mousePos.y - mouseStartPosY,
        event
      });
    }
  }
  ;
  function onMouseup(event) {
    const x = options.getX(event);
    const y = options.getY(event);
    const width = options.getWidth();
    options.onMouseUp && options.onMouseUp();
    if (triggered && options.onDrop) {
      options.onDrop({
        mouseEvent: event,
        x,
        y,
        width,
        dragging,
        resizing
      });
    }
    mouseStartPosX = null;
    mouseStartPosY = null;
    mouseStartRight = null;
    dragging = false;
    resizing = false;
    initialX = null;
    initialY = null;
    triggered = false;
    window.removeEventListener("pointermove", onMousemove, false);
  }
  ;
  return onMousedown;
}

// node_modules/svelte-gantt/svelte/core/drag/DraggableGroup.svelte
var { Object: Object_1 } = globals;
var get_default_slot_changes = (dirty) => ({});
var get_default_slot_context = (ctx) => ({ context: (
  /*context*/
  ctx[6]
) });
function create_fragment4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let $rowPadding;
  let $rowStore;
  let $root;
  let $taskStore;
  let $_active;
  let $selectedTasks;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DraggableGroup", slots, ["default"]);
  let { items = {} } = $$props;
  let _taskIds = [];
  const _active = writable(false);
  validate_store(_active, "_active");
  component_subscribe($$self, _active, (value) => $$invalidate(15, $_active = value));
  const root = writable({});
  validate_store(root, "root");
  component_subscribe($$self, root, (value) => $$invalidate(13, $root = value));
  const { taskStore, rowStore } = getContext("dataStore");
  validate_store(taskStore, "taskStore");
  component_subscribe($$self, taskStore, (value) => $$invalidate(14, $taskStore = value));
  validate_store(rowStore, "rowStore");
  component_subscribe($$self, rowStore, (value) => $$invalidate(12, $rowStore = value));
  const gantt = getContext("gantt");
  const { rowPadding } = getContext("options");
  validate_store(rowPadding, "rowPadding");
  component_subscribe($$self, rowPadding, (value) => $$invalidate(11, $rowPadding = value));
  const { api, utils, columnService, selectionManager } = getContext("services");
  const dispatcher = createEventDispatcher();
  const selectedTasks = selectionManager._selectedTasks;
  validate_store(selectedTasks, "selectedTasks");
  component_subscribe($$self, selectedTasks, (value) => $$invalidate(16, $selectedTasks = value));
  const context = {
    rootState: root,
    dragAllowed({ model }) {
      const row = $rowStore.entities[model.resourceId];
      return row && isDraggable(row.model) && isDraggable(model);
    },
    resizeAllowed({ model }) {
      const row = $rowStore.entities[model.resourceId];
      return model.type !== "milestone" && row && isResizable(row.model) && isResizable(model);
    },
    off(taskId) {
      delete $root[taskId];
    },
    save(start, task, event) {
      setCursor(event.dragging ? "move" : "e-resize");
      const { mouseEvent } = event;
      let tasks = [task];
      if (mouseEvent.ctrlKey) {
        for (const [taskId, isSelected] of Object.entries($selectedTasks)) {
          if (isSelected && taskId !== String(task.model.id)) {
            tasks.push($taskStore.entities[taskId]);
          }
        }
      }
      _taskIds = [];
      for (const task2 of tasks) {
        _taskIds.push(task2.model.id);
        set_store_value(
          root,
          $root[task2.model.id] = {
            xDelta: task2.left - start.x,
            yDelta: task2.top - start.y,
            width: task2.width,
            bWidth: start.width,
            widthDelta: task2.width - start.width
          },
          $root
        );
      }
      dispatcher("itemsChange", { items: $root });
    },
    dropAll(event) {
      if (!event.dragging && !event.resizing) {
        return;
      }
      set_store_value(_active, $_active = false, $_active);
      const changes = [];
      for (const taskId of _taskIds) {
        const state = $root[taskId];
        const task = $taskStore.entities[taskId];
        const isTarget = task.model.id === taskId;
        const change = onDropSingle(
          {
            ...event,
            mouseEvent: {
              ...event.mouseEvent,
              clientX: event.mouseEvent.clientX + state.xDelta,
              clientY: event.mouseEvent.clientY + state.yDelta
            },
            x: event.x + state.xDelta,
            y: event.y + state.yDelta,
            width: Math.abs((isTarget ? event.width : state.bWidth) + state.widthDelta)
          },
          task
        );
        changes.push({
          valid: change.valid,
          task: change.task,
          targetRow: change.targetRow,
          sourceRow: change.sourceRow,
          current: change.current,
          previous: change.previous
        });
      }
      dispatcher("change", { changes });
      set_store_value(root, $root = {}, $root);
      _taskIds = [];
      dispatcher("itemsChange", { items: $root });
    },
    moveAll({ x, y, width, event }, task, state) {
      var _a;
      scrollIfOutOfBounds(event, gantt.mainContainer);
      if (state.dragging) {
        api.tasks.raise.move(task.model);
      }
      if (state.resizing) {
        api.tasks.raise.resize(task.model);
      }
      for (const taskId of _taskIds) {
        const rootState = $root[taskId];
        const isTarget = task.model.id === taskId;
        const event2 = {
          x: x != null ? x + rootState.xDelta : null,
          y: y != null ? y + rootState.yDelta : null,
          width: width != null ? Math.abs((isTarget ? width : rootState.bWidth) + rootState.widthDelta) : null
          // pos.width + (width - pos.bWidth) // wDelta
        };
        set_store_value(
          root,
          $root[taskId] = {
            ...$root[taskId],
            ...state,
            x: event2.x,
            y: event2.y,
            width: event2.width ?? ((_a = $root[taskId]) == null ? void 0 : _a.width)
          },
          $root
        );
      }
    },
    setState(task, state) {
      set_store_value(root, $root[task.model.id] = { ...$root[task.model.id], ...state }, $root);
    },
    mouseUp({ model }) {
      setCursor("default");
      api.tasks.raise.moveEnd(model);
    }
  };
  function setState(state, id) {
    set_store_value(root, $root[id] = { ...$root[id], ...state }, $root);
  }
  function onDropSingle(event, task) {
    const model = task.model;
    const sourceRow = $rowStore.entities[model.resourceId];
    let targetRow;
    if (event.dragging) {
      const rowId = getRowAtPoint(event.mouseEvent);
      const row = $rowStore.entities[rowId];
      if (row && isDraggable(row.model)) {
        targetRow = row;
      }
    } else {
      targetRow = $rowStore.entities[model.resourceId];
    }
    setState({ dragging: false, resizing: false }, model.id);
    setTimeout(() => {
      setState({ ignoreClick: false }, model.id);
    });
    const newFrom = utils.roundTo(columnService.getDateByPosition(event.x));
    const newTo = utils.roundTo(columnService.getDateByPosition(event.x + event.width));
    const newLeft = columnService.getPositionByDate(newFrom) | 0;
    const newRight = columnService.getPositionByDate(newTo) | 0;
    const left = newLeft;
    const width = newRight - newLeft;
    const top = $rowPadding + ((targetRow == null ? void 0 : targetRow.y) ?? 0);
    const current = {
      left,
      top,
      width,
      from: newFrom,
      to: newTo
    };
    const previous = {
      left: task.left,
      width: task.width,
      top: task.top,
      from: model.from,
      to: model.to
    };
    return {
      valid: true,
      task,
      current,
      previous,
      dragging: event.dragging,
      resizing: event.resizing,
      sourceRow,
      targetRow
    };
  }
  setContext("drag", context);
  const writable_props = ["items"];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<DraggableGroup> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2) $$invalidate(7, items = $$props2.items);
    if ("$$scope" in $$props2) $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    writable,
    createEventDispatcher,
    getContext,
    scrollIfOutOfBounds,
    setCursor,
    getRowAtPoint,
    isDraggable,
    isResizable,
    items,
    _taskIds,
    _active,
    root,
    taskStore,
    rowStore,
    gantt,
    rowPadding,
    api,
    utils,
    columnService,
    selectionManager,
    dispatcher,
    selectedTasks,
    context,
    setState,
    onDropSingle,
    $rowPadding,
    $rowStore,
    $root,
    $taskStore,
    $_active,
    $selectedTasks
  });
  $$self.$inject_state = ($$props2) => {
    if ("items" in $$props2) $$invalidate(7, items = $$props2.items);
    if ("_taskIds" in $$props2) _taskIds = $$props2._taskIds;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*items*/
    128) {
      $: set_store_value(root, $root = items, $root);
    }
  };
  return [
    _active,
    root,
    taskStore,
    rowStore,
    rowPadding,
    selectedTasks,
    context,
    items,
    $$scope,
    slots
  ];
}
var DraggableGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { items: 7 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DraggableGroup",
      options,
      id: create_fragment4.name
    });
  }
  get items() {
    throw new Error("<DraggableGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<DraggableGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DraggableGroup_default = DraggableGroup;

// node_modules/svelte-gantt/svelte/core/drag/Draggable.svelte
var get_default_slot_changes2 = (dirty) => ({ state: dirty & /*_state*/
1 });
var get_default_slot_context2 = (ctx) => ({
  state: (
    /*_state*/
    ctx[0]
  ),
  onPointerDown: (
    /*onPointerDown*/
    ctx[2]
  )
});
function create_fragment5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_default_slot_context2
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, _state*/
        8193)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let state;
  let _dragging;
  let _resizing;
  let _ignoreClick;
  let _state;
  let $root;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Draggable", slots, ["default"]);
  let { task } = $$props;
  let _x;
  let _y;
  let _width;
  const { rowContainer, mainContainer } = getContext("gantt");
  const { resizeHandleWidth } = getContext("options");
  const context = getContext("drag");
  const root = context.rootState;
  validate_store(root, "root");
  component_subscribe($$self, root, (value) => $$invalidate(12, $root = value));
  const dragAllowed = null;
  const resizeAllowed = null;
  const onPointerDown = createDraggable({
    container: rowContainer,
    resizeHandleWidth,
    getX: () => _x,
    getY: () => _y,
    getWidth: () => _width,
    dragAllowed() {
      const fn = dragAllowed ?? context.dragAllowed ?? (() => true);
      return fn(task);
    },
    resizeAllowed() {
      const fn = resizeAllowed ?? context.resizeAllowed ?? (() => true);
      return fn(task);
    },
    onDown(event) {
      context.save(event, task, event);
    },
    onMouseUp() {
      context.mouseUp(task);
    },
    onResize(event) {
      context.moveAll(event, task, {
        x: event.x,
        y: event.width,
        resizing: true,
        ignoreClick: true
      });
    },
    onDrag(event) {
      context.moveAll(event, task, {
        x: event.x,
        y: event.y,
        dragging: true,
        ignoreClick: true
      });
      scrollIfOutOfBounds(event.event, mainContainer);
    },
    onDrop(event) {
      context.dropAll(event);
    }
  });
  onDestroy(() => {
    context.off(task.model.id);
  });
  $$self.$$.on_mount.push(function() {
    if (task === void 0 && !("task" in $$props || $$self.$$.bound[$$self.$$.props["task"]])) {
      console.warn("<Draggable> was created without expected prop 'task'");
    }
  });
  const writable_props = ["task"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Draggable> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("task" in $$props2) $$invalidate(3, task = $$props2.task);
    if ("$$scope" in $$props2) $$invalidate(13, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    createDraggable,
    scrollIfOutOfBounds,
    onDestroy,
    task,
    _x,
    _y,
    _width,
    rowContainer,
    mainContainer,
    resizeHandleWidth,
    context,
    root,
    dragAllowed,
    resizeAllowed,
    onPointerDown,
    state,
    _resizing,
    _dragging,
    _state,
    _ignoreClick,
    $root
  });
  $$self.$inject_state = ($$props2) => {
    if ("task" in $$props2) $$invalidate(3, task = $$props2.task);
    if ("_x" in $$props2) $$invalidate(6, _x = $$props2._x);
    if ("_y" in $$props2) $$invalidate(7, _y = $$props2._y);
    if ("_width" in $$props2) $$invalidate(8, _width = $$props2._width);
    if ("state" in $$props2) $$invalidate(9, state = $$props2.state);
    if ("_resizing" in $$props2) $$invalidate(10, _resizing = $$props2._resizing);
    if ("_dragging" in $$props2) $$invalidate(11, _dragging = $$props2._dragging);
    if ("_state" in $$props2) $$invalidate(0, _state = $$props2._state);
    if ("_ignoreClick" in $$props2) _ignoreClick = $$props2._ignoreClick;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$root, task*/
    4104) {
      $: $$invalidate(9, state = $root[task.model.id]);
    }
    if ($$self.$$.dirty & /*state*/
    512) {
      $: $$invalidate(11, _dragging = (state == null ? void 0 : state.dragging) ?? false);
    }
    if ($$self.$$.dirty & /*state*/
    512) {
      $: $$invalidate(10, _resizing = (state == null ? void 0 : state.resizing) ?? false);
    }
    if ($$self.$$.dirty & /*state*/
    512) {
      $: _ignoreClick = (state == null ? void 0 : state.ignoreClick) ?? false;
    }
    if ($$self.$$.dirty & /*_dragging, _resizing, state, task*/
    3592) {
      $: {
        if (_dragging || _resizing) {
          $$invalidate(6, _x = (state == null ? void 0 : state.x) ?? task.left);
          $$invalidate(7, _y = (state == null ? void 0 : state.y) ?? task.top);
          $$invalidate(8, _width = (state == null ? void 0 : state.width) ?? task.width);
        } else {
          $$invalidate(6, _x = task.left);
          $$invalidate(7, _y = task.top);
          $$invalidate(8, _width = task.width);
        }
      }
    }
    if ($$self.$$.dirty & /*_x, _y, _width, _dragging, _resizing*/
    3520) {
      $: $$invalidate(0, _state = {
        x: _x,
        y: _y,
        width: _width,
        dragging: _dragging,
        resizing: _resizing
      });
    }
  };
  return [
    _state,
    root,
    onPointerDown,
    task,
    dragAllowed,
    resizeAllowed,
    _x,
    _y,
    _width,
    state,
    _resizing,
    _dragging,
    $root,
    $$scope,
    slots
  ];
}
var Draggable = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      task: 3,
      dragAllowed: 4,
      resizeAllowed: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Draggable",
      options,
      id: create_fragment5.name
    });
  }
  get task() {
    throw new Error("<Draggable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set task(value) {
    throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dragAllowed() {
    return this.$$.ctx[4];
  }
  set dragAllowed(value) {
    throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizeAllowed() {
    return this.$$.ctx[5];
  }
  set resizeAllowed(value) {
    throw new Error("<Draggable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Draggable_default = Draggable;

// node_modules/svelte-gantt/svelte/entities/TimeRangeHeader.svelte
var { Object: Object_12 } = globals;
var file4 = "node_modules\\svelte-gantt\\svelte\\entities\\TimeRangeHeader.svelte";
function add_css4(target) {
  append_styles(target, "svelte-w4nglp", ".sg-time-range-control.svelte-w4nglp{position:absolute}.sg-time-range-handle-left.svelte-w4nglp{position:absolute;left:0}.sg-time-range-handle-right.svelte-w4nglp{position:absolute;right:0}.sg-time-range-disabled.svelte-w4nglp{display:none}.sg-time-range-handle-left.svelte-w4nglp::before,.sg-time-range-handle-right.svelte-w4nglp::before{position:absolute;content:'';bottom:4px;border-radius:6px 6px 6px 0;border:2px solid #b0b0b7;width:9px;height:9px;transform:translateX(-50%) rotate(-45deg);background-color:#fff;border-color:#e03218;cursor:ew-resize}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGltZVJhbmdlSGVhZGVyLnN2ZWx0ZSIsInNvdXJjZXMiOlsiVGltZVJhbmdlSGVhZGVyLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PmltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuaW1wb3J0IHsgdXNlRHJhZ2dhYmxlIH0gZnJvbSAnLi4vY29yZS9kcmFnJztcbmltcG9ydCB7IG5vcm1hbGl6ZUNsYXNzQXR0ciB9IGZyb20gJy4uL3V0aWxzL2RvbSc7XG5pbXBvcnQgeyBpc1Jlc2l6YWJsZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcbmNvbnN0IHsgcm93Q29udGFpbmVyIH0gPSBnZXRDb250ZXh0KCdnYW50dCcpO1xuY29uc3QgeyBhcGksIHV0aWxzLCBjb2x1bW5TZXJ2aWNlIH0gPSBnZXRDb250ZXh0KCdzZXJ2aWNlcycpO1xuY29uc3QgeyByZXNpemVIYW5kbGVXaWR0aCB9ID0gZ2V0Q29udGV4dCgnb3B0aW9ucycpO1xuY29uc3QgeyB0aW1lUmFuZ2VTdG9yZSB9ID0gZ2V0Q29udGV4dCgnZGF0YVN0b3JlJyk7XG5leHBvcnQgbGV0IG1vZGVsO1xuZXhwb3J0IGxldCB3aWR0aDtcbmV4cG9ydCBsZXQgbGVmdDtcbmNvbnN0IF9wb3NpdGlvbiA9IHtcbiAgICB3aWR0aCxcbiAgICB4OiBsZWZ0XG59O1xuJDoge1xuICAgIChfcG9zaXRpb24ueCA9IGxlZnQpLCAoX3Bvc2l0aW9uLndpZHRoID0gd2lkdGgpO1xufVxuZnVuY3Rpb24gZHJhZyhub2RlKSB7XG4gICAgY29uc3Qgb25kcm9wID0gZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBuZXdGcm9tID0gdXRpbHMucm91bmRUbyhjb2x1bW5TZXJ2aWNlLmdldERhdGVCeVBvc2l0aW9uKGV2ZW50LngpKTtcbiAgICAgICAgY29uc3QgbmV3VG8gPSB1dGlscy5yb3VuZFRvKGNvbHVtblNlcnZpY2UuZ2V0RGF0ZUJ5UG9zaXRpb24oZXZlbnQueCArIGV2ZW50LndpZHRoKSk7XG4gICAgICAgIGNvbnN0IG5ld0xlZnQgPSBjb2x1bW5TZXJ2aWNlLmdldFBvc2l0aW9uQnlEYXRlKG5ld0Zyb20pO1xuICAgICAgICBjb25zdCBuZXdSaWdodCA9IGNvbHVtblNlcnZpY2UuZ2V0UG9zaXRpb25CeURhdGUobmV3VG8pO1xuICAgICAgICBPYmplY3QuYXNzaWduKG1vZGVsLCB7XG4gICAgICAgICAgICBmcm9tOiBuZXdGcm9tLFxuICAgICAgICAgICAgdG86IG5ld1RvXG4gICAgICAgIH0pO1xuICAgICAgICB1cGRhdGUoe1xuICAgICAgICAgICAgbGVmdDogbmV3TGVmdCxcbiAgICAgICAgICAgIHdpZHRoOiBuZXdSaWdodCAtIG5ld0xlZnQsXG4gICAgICAgICAgICBtb2RlbCxcbiAgICAgICAgICAgIHJlc2l6aW5nOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgYXBpLnRpbWVyYW5nZXMucmFpc2UuY2hhbmdlZCh7IG1vZGVsLCBsZWZ0OiBldmVudC54LCB3aWR0aDogZXZlbnQud2lkdGggfSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIG9ubW91c2Vtb3ZlLCBmYWxzZSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB1cGRhdGUoc3RhdGUpIHtcbiAgICAgICAgdGltZVJhbmdlU3RvcmUudXBkYXRlKHN0YXRlKTtcbiAgICAgICAgX3Bvc2l0aW9uLnggPSBzdGF0ZS5sZWZ0O1xuICAgICAgICBfcG9zaXRpb24ud2lkdGggPSBzdGF0ZS53aWR0aDtcbiAgICB9XG4gICAgY29uc3QgZHJhZ2dhYmxlID0gdXNlRHJhZ2dhYmxlKG5vZGUsIHtcbiAgICAgICAgb25Eb3duOiBldmVudCA9PiB7XG4gICAgICAgICAgICBhcGkudGltZXJhbmdlcy5yYWlzZS5jbGlja2VkKHsgbW9kZWwgfSk7XG4gICAgICAgICAgICB1cGRhdGUoe1xuICAgICAgICAgICAgICAgIGxlZnQ6IGV2ZW50LngsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGV2ZW50LndpZHRoLFxuICAgICAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgICAgIHJlc2l6aW5nOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25SZXNpemU6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGFwaS50aW1lcmFuZ2VzLnJhaXNlLnJlc2l6ZWQoeyBtb2RlbCwgbGVmdDogZXZlbnQueCwgd2lkdGg6IGV2ZW50LndpZHRoIH0pO1xuICAgICAgICAgICAgdXBkYXRlKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBldmVudC54LFxuICAgICAgICAgICAgICAgIHdpZHRoOiBldmVudC53aWR0aCxcbiAgICAgICAgICAgICAgICBtb2RlbCxcbiAgICAgICAgICAgICAgICByZXNpemluZzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYWdBbGxvd2VkOiBmYWxzZSxcbiAgICAgICAgcmVzaXplQWxsb3dlZDogKCkgPT4gaXNSZXNpemFibGUobW9kZWwpLFxuICAgICAgICBvbkRyb3A6IG9uZHJvcCxcbiAgICAgICAgY29udGFpbmVyOiByb3dDb250YWluZXIsXG4gICAgICAgIHJlc2l6ZUhhbmRsZVdpZHRoLFxuICAgICAgICBnZXRYOiAoKSA9PiBfcG9zaXRpb24ueCxcbiAgICAgICAgZ2V0WTogKCkgPT4gMCxcbiAgICAgICAgZ2V0V2lkdGg6ICgpID0+IF9wb3NpdGlvbi53aWR0aFxuICAgIH0pO1xuICAgIHJldHVybiB7IGRlc3Ryb3k6ICgpID0+IGRyYWdnYWJsZS5kZXN0cm95KCkgfTtcbn1cbmxldCBjbGFzc2VzO1xuJDoge1xuICAgIGNsYXNzZXMgPSBub3JtYWxpemVDbGFzc0F0dHIobW9kZWwuY2xhc3Nlcyk7XG59XG48L3NjcmlwdD5cblxuPGRpdlxuICAgIGNsYXNzPVwic2ctdGltZS1yYW5nZS1jb250cm9sIHtjbGFzc2VzfVwiXG4gICAgc3R5bGU9XCJ3aWR0aDp7X3Bvc2l0aW9uLndpZHRofXB4O2xlZnQ6e19wb3NpdGlvbi54fXB4XCJcbiAgICBjbGFzczpzZy10aW1lLXJhbmdlLWRpc2FibGVkPXshaXNSZXNpemFibGUobW9kZWwpfVxuPlxuICAgIDxkaXYgY2xhc3M9XCJzZy10aW1lLXJhbmdlLWhhbmRsZS1sZWZ0XCIgdXNlOmRyYWc+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInNnLXRpbWUtcmFuZ2UtaGFuZGxlLXJpZ2h0XCIgdXNlOmRyYWc+PC9kaXY+XG48L2Rpdj5cblxuPHN0eWxlPlxuICAgIC5zZy10aW1lLXJhbmdlLWNvbnRyb2wge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgfVxuXG4gICAgLnNnLXRpbWUtcmFuZ2UtaGFuZGxlLWxlZnQge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgfVxuXG4gICAgLnNnLXRpbWUtcmFuZ2UtaGFuZGxlLXJpZ2h0IHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICByaWdodDogMDtcbiAgICB9XG5cbiAgICAuc2ctdGltZS1yYW5nZS1kaXNhYmxlZCB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuXG4gICAgLnNnLXRpbWUtcmFuZ2UtaGFuZGxlLWxlZnQ6OmJlZm9yZSxcbiAgICAuc2ctdGltZS1yYW5nZS1oYW5kbGUtcmlnaHQ6OmJlZm9yZSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgY29udGVudDogJyc7XG4gICAgICAgIGJvdHRvbTogNHB4O1xuICAgICAgICBib3JkZXItcmFkaXVzOiA2cHggNnB4IDZweCAwO1xuICAgICAgICBib3JkZXI6IDJweCBzb2xpZCAjYjBiMGI3O1xuICAgICAgICB3aWR0aDogOXB4O1xuICAgICAgICBoZWlnaHQ6IDlweDtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpIHJvdGF0ZSgtNDVkZWcpO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xuXG4gICAgICAgIGJvcmRlci1jb2xvcjogI2UwMzIxODtcbiAgICAgICAgY3Vyc29yOiBldy1yZXNpemU7XG4gICAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUF3Rkksb0NBQXVCLENBQ25CLFFBQVEsQ0FBRSxRQUNkLENBRUEsd0NBQTJCLENBQ3ZCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLElBQUksQ0FBRSxDQUNWLENBRUEseUNBQTRCLENBQ3hCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEtBQUssQ0FBRSxDQUNYLENBRUEscUNBQXdCLENBQ3BCLE9BQU8sQ0FBRSxJQUNiLENBRUEsd0NBQTBCLFFBQVEsQ0FDbEMseUNBQTJCLFFBQVMsQ0FDaEMsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsT0FBTyxDQUFFLEVBQUUsQ0FDWCxNQUFNLENBQUUsR0FBRyxDQUNYLGFBQWEsQ0FBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQzVCLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FDekIsS0FBSyxDQUFFLEdBQUcsQ0FDVixNQUFNLENBQUUsR0FBRyxDQUNYLFNBQVMsQ0FBRSxXQUFXLElBQUksQ0FBQyxDQUFDLE9BQU8sTUFBTSxDQUFDLENBQzFDLGdCQUFnQixDQUFFLElBQUksQ0FFdEIsWUFBWSxDQUFFLE9BQU8sQ0FDckIsTUFBTSxDQUFFLFNBQ1oifQ== */");
}
function create_fragment6(ctx) {
  let div2;
  let div0;
  let drag_action;
  let t;
  let div1;
  let drag_action_1;
  let div2_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t = space();
      div1 = element("div");
      attr_dev(div0, "class", "sg-time-range-handle-left svelte-w4nglp");
      add_location(div0, file4, 83, 4, 2603);
      attr_dev(div1, "class", "sg-time-range-handle-right svelte-w4nglp");
      add_location(div1, file4, 84, 4, 2662);
      attr_dev(div2, "class", div2_class_value = "sg-time-range-control " + /*classes*/
      ctx[2] + " svelte-w4nglp");
      set_style(
        div2,
        "width",
        /*_position*/
        ctx[1].width + "px"
      );
      set_style(
        div2,
        "left",
        /*_position*/
        ctx[1].x + "px"
      );
      toggle_class(div2, "sg-time-range-disabled", !isResizable(
        /*model*/
        ctx[0]
      ));
      add_location(div2, file4, 78, 0, 2434);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div0);
      append_dev(div2, t);
      append_dev(div2, div1);
      if (!mounted) {
        dispose = [
          action_destroyer(drag_action = /*drag*/
          ctx[3].call(null, div0)),
          action_destroyer(drag_action_1 = /*drag*/
          ctx[3].call(null, div1))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*classes*/
      4 && div2_class_value !== (div2_class_value = "sg-time-range-control " + /*classes*/
      ctx2[2] + " svelte-w4nglp")) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (dirty & /*_position*/
      2) {
        set_style(
          div2,
          "width",
          /*_position*/
          ctx2[1].width + "px"
        );
      }
      if (dirty & /*_position*/
      2) {
        set_style(
          div2,
          "left",
          /*_position*/
          ctx2[1].x + "px"
        );
      }
      if (dirty & /*classes, model*/
      5) {
        toggle_class(div2, "sg-time-range-disabled", !isResizable(
          /*model*/
          ctx2[0]
        ));
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TimeRangeHeader", slots, []);
  const { rowContainer } = getContext("gantt");
  const { api, utils, columnService } = getContext("services");
  const { resizeHandleWidth } = getContext("options");
  const { timeRangeStore } = getContext("dataStore");
  let { model } = $$props;
  let { width } = $$props;
  let { left } = $$props;
  const _position = { width, x: left };
  function drag(node) {
    const ondrop = (event) => {
      const newFrom = utils.roundTo(columnService.getDateByPosition(event.x));
      const newTo = utils.roundTo(columnService.getDateByPosition(event.x + event.width));
      const newLeft = columnService.getPositionByDate(newFrom);
      const newRight = columnService.getPositionByDate(newTo);
      Object.assign(model, { from: newFrom, to: newTo });
      update({
        left: newLeft,
        width: newRight - newLeft,
        model,
        resizing: false
      });
      api.timeranges.raise.changed({ model, left: event.x, width: event.width });
      window.removeEventListener("pointermove", onmousemove, false);
    };
    function update(state) {
      timeRangeStore.update(state);
      $$invalidate(1, _position.x = state.left, _position);
      $$invalidate(1, _position.width = state.width, _position);
    }
    const draggable = useDraggable(node, {
      onDown: (event) => {
        api.timeranges.raise.clicked({ model });
        update({
          left: event.x,
          width: event.width,
          model,
          resizing: true
        });
      },
      onResize: (event) => {
        api.timeranges.raise.resized({ model, left: event.x, width: event.width });
        update({
          left: event.x,
          width: event.width,
          model,
          resizing: true
        });
      },
      dragAllowed: false,
      resizeAllowed: () => isResizable(model),
      onDrop: ondrop,
      container: rowContainer,
      resizeHandleWidth,
      getX: () => _position.x,
      getY: () => 0,
      getWidth: () => _position.width
    });
    return { destroy: () => draggable.destroy() };
  }
  let classes;
  $$self.$$.on_mount.push(function() {
    if (model === void 0 && !("model" in $$props || $$self.$$.bound[$$self.$$.props["model"]])) {
      console.warn("<TimeRangeHeader> was created without expected prop 'model'");
    }
    if (width === void 0 && !("width" in $$props || $$self.$$.bound[$$self.$$.props["width"]])) {
      console.warn("<TimeRangeHeader> was created without expected prop 'width'");
    }
    if (left === void 0 && !("left" in $$props || $$self.$$.bound[$$self.$$.props["left"]])) {
      console.warn("<TimeRangeHeader> was created without expected prop 'left'");
    }
  });
  const writable_props = ["model", "width", "left"];
  Object_12.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<TimeRangeHeader> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2) $$invalidate(0, model = $$props2.model);
    if ("width" in $$props2) $$invalidate(4, width = $$props2.width);
    if ("left" in $$props2) $$invalidate(5, left = $$props2.left);
  };
  $$self.$capture_state = () => ({
    getContext,
    useDraggable,
    normalizeClassAttr,
    isResizable,
    rowContainer,
    api,
    utils,
    columnService,
    resizeHandleWidth,
    timeRangeStore,
    model,
    width,
    left,
    _position,
    drag,
    classes
  });
  $$self.$inject_state = ($$props2) => {
    if ("model" in $$props2) $$invalidate(0, model = $$props2.model);
    if ("width" in $$props2) $$invalidate(4, width = $$props2.width);
    if ("left" in $$props2) $$invalidate(5, left = $$props2.left);
    if ("classes" in $$props2) $$invalidate(2, classes = $$props2.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*left, width*/
    48) {
      $: {
        $$invalidate(1, _position.x = left, _position), $$invalidate(1, _position.width = width, _position);
      }
    }
    if ($$self.$$.dirty & /*model*/
    1) {
      $: {
        $$invalidate(2, classes = normalizeClassAttr(model.classes));
      }
    }
  };
  return [model, _position, classes, drag, width, left];
}
var TimeRangeHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { model: 0, width: 4, left: 5 }, add_css4);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TimeRangeHeader",
      options,
      id: create_fragment6.name
    });
  }
  get model() {
    throw new Error("<TimeRangeHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set model(value) {
    throw new Error("<TimeRangeHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<TimeRangeHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<TimeRangeHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get left() {
    throw new Error("<TimeRangeHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set left(value) {
    throw new Error("<TimeRangeHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TimeRangeHeader_default = TimeRangeHeader;

// node_modules/svelte-gantt/svelte/utils/date.js
function getDuration(unit, offset = 1) {
  switch (unit) {
    case "y":
    case "year":
      return offset * 31536e6;
    case "month":
      return offset * 30 * 24 * 60 * 60 * 1e3;
    case "week":
      return offset * 7 * 24 * 60 * 60 * 1e3;
    case "d":
    case "day":
      return offset * 24 * 60 * 60 * 1e3;
    case "h":
    case "hour":
      return offset * 60 * 60 * 1e3;
    case "m":
    case "minute":
      return offset * 60 * 1e3;
    case "s":
    case "second":
      return offset * 1e3;
    default:
      throw new Error(`Unknown unit: ${unit}`);
  }
}
function addSeconds(date, offset = 1) {
  date.setSeconds(date.getSeconds() + offset);
  return date;
}
function addMinutes(date, offset = 1) {
  date.setMinutes(date.getMinutes() + offset);
  return date;
}
function addHours(date, offset = 1) {
  date.setHours(date.getHours() + offset);
  return date;
}
function addDays(date, offset = 1) {
  date.setDate(date.getDate() + offset);
  date.setHours(0, 0, 0);
  return date;
}
function addWeeks(date, offset = 1) {
  const d = date;
  const day = d.getDay();
  const diff = d.getDate() - day + (day == 0 ? -6 : 1);
  d.setDate(diff);
  d.setHours(0, 0, 0);
  d.setDate(d.getDate() + 7 * offset);
  return d;
}
function addMonths(date, offset = 1) {
  date.setMonth(date.getMonth() + offset);
  date.setDate(1);
  date.setHours(0, 0, 0);
  return date;
}
function addYears(date, offset = 1) {
  date.setFullYear(date.getFullYear() + offset);
  date.setMonth(0);
  date.setDate(1);
  date.setHours(0, 0, 0);
  return date;
}
function getNextDate(date, unit, offset) {
  switch (unit) {
    case "y":
    case "year":
      return addYears(date, offset);
    case "month":
      return addMonths(date, offset);
    case "week":
      return addWeeks(date, offset);
    case "d":
    case "day":
      return addDays(date, offset);
    case "h":
    case "hour":
      return addHours(date, offset);
    case "m":
    case "minute":
      return addMinutes(date, offset);
    case "s":
    case "second":
      return addSeconds(date, offset);
    default:
      break;
  }
}
var units = ["y", "year", "month", "week", "d", "day", "h", "hour", "m", "minute", "s", "second"];
function getAllPeriods(from, to, unit, offset = 1, highlightedDurations) {
  if (units.indexOf(unit) !== -1) {
    let tmsWorkOld = 0;
    let interval_duration = 0;
    const start = new Date(from);
    const dateWork = new Date(from);
    let nextDate = getNextDate(dateWork, unit, offset);
    let tmsWork = nextDate.getTime();
    const firstDuration = nextDate.getTime() - from;
    const all_periods = [
      {
        // start: start,
        // end: nextDate,
        from,
        // from: startOf(from, unit), // incorrect if not circled down to the unit eg. 6:30
        // TODO: think about offsetting the whole row, so for example if timeline starts at 6:30, the headers still show times for 6:00, 7:00 etc, and not 6:30, 7:30...
        to: nextDate.getTime(),
        duration: firstDuration,
        // check whether duration is highlighted
        isHighlighted: highlightedDurations && isUnitFraction(start, highlightedDurations)
      }
    ];
    if (tmsWork < to) {
      while (tmsWork < to) {
        tmsWorkOld = tmsWork;
        nextDate = getNextDate(new Date(tmsWork), unit, offset);
        interval_duration = nextDate.getTime() - tmsWork;
        all_periods.push({
          from: tmsWork,
          to: nextDate.getTime(),
          duration: interval_duration,
          //check whether duration is highlighted
          isHighlighted: highlightedDurations && isUnitFraction(new Date(tmsWork), highlightedDurations)
        });
        tmsWork = nextDate.getTime();
      }
      const last_day_duration = to - tmsWorkOld;
      all_periods[all_periods.length - 1].to = to;
      all_periods[all_periods.length - 1].duration = last_day_duration;
    }
    return all_periods;
  }
  throw new Error(`Unknown unit: ${unit}`);
}
function isUnitFraction(localDate, highlightedDurations) {
  let timeInUnit;
  switch (highlightedDurations.unit) {
    case "m":
    case "minute":
      timeInUnit = localDate.getMinutes();
      return highlightedDurations.fractions.includes(timeInUnit);
    case "h":
    case "hour":
      timeInUnit = localDate.getHours();
      return highlightedDurations.fractions.includes(timeInUnit);
    case "d":
    case "day":
      timeInUnit = localDate.getDay();
      return highlightedDurations.fractions.includes(timeInUnit);
    case "week":
      return highlightedDurations.fractions.includes(timeInUnit);
    case "dayinMonth":
      timeInUnit = localDate.getDate();
      return highlightedDurations.fractions.includes(timeInUnit);
    case "month":
      timeInUnit = localDate.getMonth();
      return highlightedDurations.fractions.includes(timeInUnit);
    case "y":
    case "year":
      timeInUnit = localDate.getFullYear();
      return highlightedDurations.fractions.includes(timeInUnit);
    default:
      throw new Error(`Invalid unit: ${highlightedDurations.unit}`);
  }
}

// node_modules/svelte-gantt/svelte/column/ColumnHeaderRow.svelte
var file5 = "node_modules\\svelte-gantt\\svelte\\column\\ColumnHeaderRow.svelte";
function add_css5(target) {
  append_styles(target, "svelte-wuuadr", ".column-header-row.svelte-wuuadr.svelte-wuuadr{position:relative;white-space:nowrap;height:32px}.column-header-cell.svelte-wuuadr.svelte-wuuadr{position:absolute;height:100%;box-sizing:border-box;text-overflow:clip;text-align:center;display:inline-flex;justify-content:center;align-items:center;font-size:1em;font-size:14px;font-weight:300;transition:background 0.2s;cursor:pointer;user-select:none;border-right:var(--sg-column-header-border-color) 1px solid;border-bottom:var(--sg-column-header-border-color) 1px solid}.column-header-cell.svelte-wuuadr.svelte-wuuadr:hover{background:var(--sg-column-header-bg-hover)}.column-header-cell.sticky.svelte-wuuadr>.column-header-cell-label.svelte-wuuadr{position:sticky;left:1rem}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29sdW1uSGVhZGVyUm93LnN2ZWx0ZSIsInNvdXJjZXMiOlsiQ29sdW1uSGVhZGVyUm93LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PmltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciwgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5jb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuaW1wb3J0IHsgZ2V0QWxsUGVyaW9kcyB9IGZyb20gJy4uL3V0aWxzL2RhdGUnO1xuaW1wb3J0IHsgZ2V0UG9zaXRpb25CeURhdGUgfSBmcm9tICcuLi91dGlscy91dGlscyc7XG5pbXBvcnQgeyB3aGVuRW50ZXJQcmVzcyB9IGZyb20gJy4uL3V0aWxzL2RvbSc7XG5jb25zdCB7IGZyb20sIHRvLCB3aWR0aCB9ID0gZ2V0Q29udGV4dCgnZGltZW5zaW9ucycpO1xuY29uc3QgeyBkYXRlQWRhcHRlciB9ID0gZ2V0Q29udGV4dCgnb3B0aW9ucycpO1xuZXhwb3J0IGxldCBoZWFkZXI7XG5leHBvcnQgbGV0IGdhbnR0Qm9keUNvbHVtbnM7XG5leHBvcnQgbGV0IGdhbnR0Qm9keVVuaXQ7XG4kOiB7XG4gICAgaWYgKGhlYWRlci51bml0ID09PSBnYW50dEJvZHlVbml0KSB7XG4gICAgICAgIGhlYWRlci5jb2x1bW5zID0gZ2FudHRCb2R5Q29sdW1ucy5tYXAoY29sdW1uID0+ICh7XG4gICAgICAgICAgICAuLi5jb2x1bW4sXG4gICAgICAgICAgICBsYWJlbDogZGF0ZUFkYXB0ZXIuZm9ybWF0KGNvbHVtbi5mcm9tLCBoZWFkZXIuZm9ybWF0KVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBwZXJpb2RzID0gZ2V0QWxsUGVyaW9kcygkZnJvbS52YWx1ZU9mKCksICR0by52YWx1ZU9mKCksIGhlYWRlci51bml0LCBoZWFkZXIub2Zmc2V0KTtcbiAgICAgICAgbGV0IGRpc3RhbmNlX3BvaW50ID0gMDtcbiAgICAgICAgbGV0IGxlZnQgPSAwO1xuICAgICAgICBoZWFkZXIuY29sdW1ucyA9IHBlcmlvZHMubWFwKHBlcmlvZCA9PiB7XG4gICAgICAgICAgICBsZWZ0ID0gZGlzdGFuY2VfcG9pbnQ7XG4gICAgICAgICAgICBkaXN0YW5jZV9wb2ludCA9IGdldFBvc2l0aW9uQnlEYXRlKHBlcmlvZC50bywgJGZyb20udmFsdWVPZigpLCAkdG8udmFsdWVPZigpLCAkd2lkdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogTWF0aC5taW4oZGlzdGFuY2VfcG9pbnQgLSBsZWZ0LCAkd2lkdGgpLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBkYXRlQWRhcHRlci5mb3JtYXQocGVyaW9kLmZyb20sIGhlYWRlci5mb3JtYXQpLFxuICAgICAgICAgICAgICAgIGZyb206IHBlcmlvZC5mcm9tLFxuICAgICAgICAgICAgICAgIHRvOiBwZXJpb2QudG8sXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gb25IZWFkZXJDbGljayhfaGVhZGVyKSB7XG4gICAgZGlzcGF0Y2goJ2RhdGVTZWxlY3RlZCcsIHsgZnJvbTogX2hlYWRlci5mcm9tLCB0bzogX2hlYWRlci50bywgdW5pdDogaGVhZGVyLnVuaXQgfSk7XG59XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cImNvbHVtbi1oZWFkZXItcm93XCI+XG4gICAgeyNlYWNoIGhlYWRlci5jb2x1bW5zIGFzIF9oZWFkZXJ9XG4gICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzPVwiY29sdW1uLWhlYWRlci1jZWxsXCJcbiAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgIGNsYXNzOnN0aWNreT17aGVhZGVyLnN0aWNreX1cbiAgICAgICAgICAgIHN0eWxlPVwibGVmdDp7X2hlYWRlci5sZWZ0fXB4O3dpZHRoOntfaGVhZGVyLndpZHRofXB4XCJcbiAgICAgICAgICAgIG9uOmNsaWNrPXsoKSA9PiBvbkhlYWRlckNsaWNrKF9oZWFkZXIpfVxuICAgICAgICAgICAgb246a2V5ZG93bj17d2hlbkVudGVyUHJlc3MoKCkgPT4gb25IZWFkZXJDbGljayhfaGVhZGVyKSl9XG4gICAgICAgID5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4taGVhZGVyLWNlbGwtbGFiZWxcIj57X2hlYWRlci5sYWJlbCB8fCAnTi9BJ308L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgey9lYWNofVxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgICAuY29sdW1uLWhlYWRlci1yb3cge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cbiAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICAgICAgaGVpZ2h0OiAzMnB4O1xuICAgIH1cblxuICAgIC5jb2x1bW4taGVhZGVyLWNlbGwge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG5cbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICB0ZXh0LW92ZXJmbG93OiBjbGlwO1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG5cbiAgICAgICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG5cbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgZm9udC1zaXplOiAxZW07XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDMwMDtcbiAgICAgICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZCAwLjJzO1xuXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG5cbiAgICAgICAgYm9yZGVyLXJpZ2h0OiB2YXIoLS1zZy1jb2x1bW4taGVhZGVyLWJvcmRlci1jb2xvcikgMXB4IHNvbGlkO1xuICAgICAgICBib3JkZXItYm90dG9tOiB2YXIoLS1zZy1jb2x1bW4taGVhZGVyLWJvcmRlci1jb2xvcikgMXB4IHNvbGlkO1xuICAgIH1cblxuICAgIC5jb2x1bW4taGVhZGVyLWNlbGw6aG92ZXIge1xuICAgICAgICBiYWNrZ3JvdW5kOiB2YXIoLS1zZy1jb2x1bW4taGVhZGVyLWJnLWhvdmVyKTtcbiAgICB9XG5cbiAgICAuY29sdW1uLWhlYWRlci1jZWxsLnN0aWNreSA+IC5jb2x1bW4taGVhZGVyLWNlbGwtbGFiZWwge1xuICAgICAgICBwb3NpdGlvbjogc3RpY2t5O1xuICAgICAgICBsZWZ0OiAxcmVtO1xuICAgIH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBd0RJLDhDQUFtQixDQUNmLFFBQVEsQ0FBRSxRQUFRLENBRWxCLFdBQVcsQ0FBRSxNQUFNLENBQ25CLE1BQU0sQ0FBRSxJQUNaLENBRUEsK0NBQW9CLENBQ2hCLFFBQVEsQ0FBRSxRQUFRLENBRWxCLE1BQU0sQ0FBRSxJQUFJLENBQ1osVUFBVSxDQUFFLFVBQVUsQ0FDdEIsYUFBYSxDQUFFLElBQUksQ0FDbkIsVUFBVSxDQUFFLE1BQU0sQ0FFbEIsT0FBTyxDQUFFLFdBQVcsQ0FFcEIsZUFBZSxDQUFFLE1BQU0sQ0FDdkIsV0FBVyxDQUFFLE1BQU0sQ0FFbkIsU0FBUyxDQUFFLEdBQUcsQ0FDZCxTQUFTLENBQUUsSUFBSSxDQUNmLFdBQVcsQ0FBRSxHQUFHLENBQ2hCLFVBQVUsQ0FBRSxVQUFVLENBQUMsSUFBSSxDQUUzQixNQUFNLENBQUUsT0FBTyxDQUNmLFdBQVcsQ0FBRSxJQUFJLENBRWpCLFlBQVksQ0FBRSxJQUFJLCtCQUErQixDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FDNUQsYUFBYSxDQUFFLElBQUksK0JBQStCLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FDNUQsQ0FFQSwrQ0FBbUIsTUFBTyxDQUN0QixVQUFVLENBQUUsSUFBSSwyQkFBMkIsQ0FDL0MsQ0FFQSxtQkFBbUIscUJBQU8sQ0FBRyx1Q0FBMEIsQ0FDbkQsUUFBUSxDQUFFLE1BQU0sQ0FDaEIsSUFBSSxDQUFFLElBQ1YifQ== */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let div1;
  let div0;
  let t0_value = (
    /*_header*/
    (ctx[14].label || "N/A") + ""
  );
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[10](
        /*_header*/
        ctx[14]
      )
    );
  }
  function keydown_handler() {
    return (
      /*keydown_handler*/
      ctx[11](
        /*_header*/
        ctx[14]
      )
    );
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      attr_dev(div0, "class", "column-header-cell-label svelte-wuuadr");
      add_location(div0, file5, 50, 12, 1835);
      attr_dev(div1, "class", "column-header-cell svelte-wuuadr");
      attr_dev(div1, "role", "button");
      attr_dev(div1, "tabindex", "0");
      set_style(
        div1,
        "left",
        /*_header*/
        ctx[14].left + "px"
      );
      set_style(
        div1,
        "width",
        /*_header*/
        ctx[14].width + "px"
      );
      toggle_class(
        div1,
        "sticky",
        /*header*/
        ctx[0].sticky
      );
      add_location(div1, file5, 41, 8, 1489);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      append_dev(div0, t0);
      append_dev(div1, t1);
      if (!mounted) {
        dispose = [
          listen_dev(div1, "click", click_handler, false, false, false, false),
          listen_dev(
            div1,
            "keydown",
            function() {
              if (is_function(whenEnterPress(keydown_handler))) whenEnterPress(keydown_handler).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*header*/
      1 && t0_value !== (t0_value = /*_header*/
      (ctx[14].label || "N/A") + "")) set_data_dev(t0, t0_value);
      if (dirty & /*header*/
      1) {
        set_style(
          div1,
          "left",
          /*_header*/
          ctx[14].left + "px"
        );
      }
      if (dirty & /*header*/
      1) {
        set_style(
          div1,
          "width",
          /*_header*/
          ctx[14].width + "px"
        );
      }
      if (dirty & /*header*/
      1) {
        toggle_class(
          div1,
          "sticky",
          /*header*/
          ctx[0].sticky
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(41:4) {#each header.columns as _header}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let div;
  let each_value = ensure_array_like_dev(
    /*header*/
    ctx[0].columns
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "class", "column-header-row svelte-wuuadr");
      add_location(div, file5, 39, 0, 1411);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*header, onHeaderClick*/
      17) {
        each_value = ensure_array_like_dev(
          /*header*/
          ctx2[0].columns
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let $width;
  let $to;
  let $from;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ColumnHeaderRow", slots, []);
  const dispatch = createEventDispatcher();
  const { from, to, width } = getContext("dimensions");
  validate_store(from, "from");
  component_subscribe($$self, from, (value) => $$invalidate(9, $from = value));
  validate_store(to, "to");
  component_subscribe($$self, to, (value) => $$invalidate(8, $to = value));
  validate_store(width, "width");
  component_subscribe($$self, width, (value) => $$invalidate(7, $width = value));
  const { dateAdapter } = getContext("options");
  let { header } = $$props;
  let { ganttBodyColumns } = $$props;
  let { ganttBodyUnit } = $$props;
  function onHeaderClick(_header) {
    dispatch("dateSelected", {
      from: _header.from,
      to: _header.to,
      unit: header.unit
    });
  }
  $$self.$$.on_mount.push(function() {
    if (header === void 0 && !("header" in $$props || $$self.$$.bound[$$self.$$.props["header"]])) {
      console.warn("<ColumnHeaderRow> was created without expected prop 'header'");
    }
    if (ganttBodyColumns === void 0 && !("ganttBodyColumns" in $$props || $$self.$$.bound[$$self.$$.props["ganttBodyColumns"]])) {
      console.warn("<ColumnHeaderRow> was created without expected prop 'ganttBodyColumns'");
    }
    if (ganttBodyUnit === void 0 && !("ganttBodyUnit" in $$props || $$self.$$.bound[$$self.$$.props["ganttBodyUnit"]])) {
      console.warn("<ColumnHeaderRow> was created without expected prop 'ganttBodyUnit'");
    }
  });
  const writable_props = ["header", "ganttBodyColumns", "ganttBodyUnit"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ColumnHeaderRow> was created with unknown prop '${key}'`);
  });
  const click_handler = (_header) => onHeaderClick(_header);
  const keydown_handler = (_header) => onHeaderClick(_header);
  $$self.$$set = ($$props2) => {
    if ("header" in $$props2) $$invalidate(0, header = $$props2.header);
    if ("ganttBodyColumns" in $$props2) $$invalidate(5, ganttBodyColumns = $$props2.ganttBodyColumns);
    if ("ganttBodyUnit" in $$props2) $$invalidate(6, ganttBodyUnit = $$props2.ganttBodyUnit);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    getContext,
    dispatch,
    getAllPeriods,
    getPositionByDate,
    whenEnterPress,
    from,
    to,
    width,
    dateAdapter,
    header,
    ganttBodyColumns,
    ganttBodyUnit,
    onHeaderClick,
    $width,
    $to,
    $from
  });
  $$self.$inject_state = ($$props2) => {
    if ("header" in $$props2) $$invalidate(0, header = $$props2.header);
    if ("ganttBodyColumns" in $$props2) $$invalidate(5, ganttBodyColumns = $$props2.ganttBodyColumns);
    if ("ganttBodyUnit" in $$props2) $$invalidate(6, ganttBodyUnit = $$props2.ganttBodyUnit);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*header, ganttBodyUnit, ganttBodyColumns, $from, $to, $width*/
    993) {
      $: {
        if (header.unit === ganttBodyUnit) {
          $$invalidate(
            0,
            header.columns = ganttBodyColumns.map((column) => ({
              ...column,
              label: dateAdapter.format(column.from, header.format)
            })),
            header
          );
        } else {
          const periods = getAllPeriods($from.valueOf(), $to.valueOf(), header.unit, header.offset);
          let distance_point = 0;
          let left = 0;
          $$invalidate(
            0,
            header.columns = periods.map((period) => {
              left = distance_point;
              distance_point = getPositionByDate(period.to, $from.valueOf(), $to.valueOf(), $width);
              return {
                width: Math.min(distance_point - left, $width),
                label: dateAdapter.format(period.from, header.format),
                from: period.from,
                to: period.to,
                left
              };
            }),
            header
          );
        }
      }
    }
  };
  return [
    header,
    from,
    to,
    width,
    onHeaderClick,
    ganttBodyColumns,
    ganttBodyUnit,
    $width,
    $to,
    $from,
    click_handler,
    keydown_handler
  ];
}
var ColumnHeaderRow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance7,
      create_fragment7,
      safe_not_equal,
      {
        header: 0,
        ganttBodyColumns: 5,
        ganttBodyUnit: 6
      },
      add_css5
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ColumnHeaderRow",
      options,
      id: create_fragment7.name
    });
  }
  get header() {
    throw new Error("<ColumnHeaderRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<ColumnHeaderRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ganttBodyColumns() {
    throw new Error("<ColumnHeaderRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ganttBodyColumns(value) {
    throw new Error("<ColumnHeaderRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ganttBodyUnit() {
    throw new Error("<ColumnHeaderRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ganttBodyUnit(value) {
    throw new Error("<ColumnHeaderRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ColumnHeaderRow_default = ColumnHeaderRow;

// node_modules/svelte-gantt/svelte/column/ColumnHeader.svelte
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  return child_ctx;
}
function create_each_block2(ctx) {
  let columnheaderrow;
  let current;
  columnheaderrow = new ColumnHeaderRow_default({
    props: {
      header: (
        /*header*/
        ctx[4]
      ),
      ganttBodyColumns: (
        /*ganttBodyColumns*/
        ctx[1]
      ),
      ganttBodyUnit: (
        /*ganttBodyUnit*/
        ctx[2]
      )
    },
    $$inline: true
  });
  columnheaderrow.$on(
    "dateSelected",
    /*dateSelected_handler*/
    ctx[3]
  );
  const block = {
    c: function create() {
      create_component(columnheaderrow.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(columnheaderrow, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const columnheaderrow_changes = {};
      if (dirty & /*headers*/
      1) columnheaderrow_changes.header = /*header*/
      ctx2[4];
      if (dirty & /*ganttBodyColumns*/
      2) columnheaderrow_changes.ganttBodyColumns = /*ganttBodyColumns*/
      ctx2[1];
      if (dirty & /*ganttBodyUnit*/
      4) columnheaderrow_changes.ganttBodyUnit = /*ganttBodyUnit*/
      ctx2[2];
      columnheaderrow.$set(columnheaderrow_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(columnheaderrow.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(columnheaderrow.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(columnheaderrow, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(10:0) {#each headers as header}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*headers*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*headers, ganttBodyColumns, ganttBodyUnit*/
      7) {
        each_value = ensure_array_like_dev(
          /*headers*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ColumnHeader", slots, []);
  let { headers } = $$props;
  let { ganttBodyColumns } = $$props;
  let { ganttBodyUnit } = $$props;
  $$self.$$.on_mount.push(function() {
    if (headers === void 0 && !("headers" in $$props || $$self.$$.bound[$$self.$$.props["headers"]])) {
      console.warn("<ColumnHeader> was created without expected prop 'headers'");
    }
    if (ganttBodyColumns === void 0 && !("ganttBodyColumns" in $$props || $$self.$$.bound[$$self.$$.props["ganttBodyColumns"]])) {
      console.warn("<ColumnHeader> was created without expected prop 'ganttBodyColumns'");
    }
    if (ganttBodyUnit === void 0 && !("ganttBodyUnit" in $$props || $$self.$$.bound[$$self.$$.props["ganttBodyUnit"]])) {
      console.warn("<ColumnHeader> was created without expected prop 'ganttBodyUnit'");
    }
  });
  const writable_props = ["headers", "ganttBodyColumns", "ganttBodyUnit"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ColumnHeader> was created with unknown prop '${key}'`);
  });
  function dateSelected_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("headers" in $$props2) $$invalidate(0, headers = $$props2.headers);
    if ("ganttBodyColumns" in $$props2) $$invalidate(1, ganttBodyColumns = $$props2.ganttBodyColumns);
    if ("ganttBodyUnit" in $$props2) $$invalidate(2, ganttBodyUnit = $$props2.ganttBodyUnit);
  };
  $$self.$capture_state = () => ({
    ColumnHeaderRow: ColumnHeaderRow_default,
    headers,
    ganttBodyColumns,
    ganttBodyUnit
  });
  $$self.$inject_state = ($$props2) => {
    if ("headers" in $$props2) $$invalidate(0, headers = $$props2.headers);
    if ("ganttBodyColumns" in $$props2) $$invalidate(1, ganttBodyColumns = $$props2.ganttBodyColumns);
    if ("ganttBodyUnit" in $$props2) $$invalidate(2, ganttBodyUnit = $$props2.ganttBodyUnit);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [headers, ganttBodyColumns, ganttBodyUnit, dateSelected_handler];
}
var ColumnHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      headers: 0,
      ganttBodyColumns: 1,
      ganttBodyUnit: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ColumnHeader",
      options,
      id: create_fragment8.name
    });
  }
  get headers() {
    throw new Error("<ColumnHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headers(value) {
    throw new Error("<ColumnHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ganttBodyColumns() {
    throw new Error("<ColumnHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ganttBodyColumns(value) {
    throw new Error("<ColumnHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ganttBodyUnit() {
    throw new Error("<ColumnHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ganttBodyUnit(value) {
    throw new Error("<ColumnHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ColumnHeader_default = ColumnHeader;

// node_modules/svelte-gantt/svelte/column/canvas.js
function createBackground(columns, opts) {
  try {
    const canvas = document.createElement("canvas");
    canvas.width = (columns.length - 1) * columns[0].width;
    canvas.height = 20;
    const ctx = canvas.getContext("2d");
    ctx.shadowColor = "rgba(128,128,128,0.5)";
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.shadowBlur = 0.5;
    ctx.lineWidth = opts.columnStrokeWidth;
    ctx.lineCap = "square";
    ctx.strokeStyle = opts.columnStrokeColor;
    ctx.translate(0.5, 0.5);
    columns.forEach((column) => {
      lineAt(ctx, column.left);
    });
    const dataURL = canvas.toDataURL();
    return `url("${dataURL}")`;
  } catch (e) {
    console.error("[canvas] Render error", e);
  }
}
function lineAt(ctx, x) {
  ctx.beginPath();
  ctx.moveTo(x, 0);
  ctx.lineTo(x, 20);
  ctx.stroke();
}

// node_modules/svelte-gantt/svelte/column/Columns.svelte
var file6 = "node_modules\\svelte-gantt\\svelte\\column\\Columns.svelte";
function add_css6(target) {
  append_styles(target, "svelte-1uqfnup", ".sg-columns.svelte-1uqfnup{position:absolute;height:100%;width:100%}.sg-columns--background.svelte-1uqfnup{overflow:hidden;background-repeat:repeat;background-position-x:-1px}.sg-column.svelte-1uqfnup{position:absolute;height:100%;width:100%;box-sizing:border-box}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29sdW1ucy5zdmVsdGUiLCJzb3VyY2VzIjpbIkNvbHVtbnMuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+aW1wb3J0IHsgY3JlYXRlQmFja2dyb3VuZCB9IGZyb20gJy4vY2FudmFzJztcbi8qKlxuICogQ29udGFpbmVyIGNvbXBvbmVudCBmb3IgY29sdW1ucyByZW5kZXJlZCBhcyBnYW50dCBib2R5IGJhY2tncm91bmRcbiAqL1xuZXhwb3J0IGxldCBjb2x1bW5zO1xuZXhwb3J0IGxldCB1c2VDYW52YXNDb2x1bW5zID0gdHJ1ZTtcbmV4cG9ydCBsZXQgY29sdW1uU3Ryb2tlV2lkdGg7XG5leHBvcnQgbGV0IGNvbHVtblN0cm9rZUNvbG9yO1xuZXhwb3J0IGxldCBjb2x1bW5EZWZhdWx0Q29sb3IgPSAnI2ZmZmZmZic7XG5sZXQgYmFja2dyb3VuZEltYWdlO1xuJDoge1xuICAgIC8vIFRPRE86IGJhY2tncm91bmQgcmVwZWF0cyBhbmQgc28gZG8gY29sdW1ucyBzbyBwYXNzaW5nIGV2ZXJ5IGVsZW1lbnQgaXMgbm90IG5lZWRlZCwgYnV0IGxpbmUgYWxpZ25tZW50IGlzc3VlcyBvY2N1ciBvbiBsYXRlciByb3dzXG4gICAgLy8gVE9ETzogSSB1c2VkIHRvIG1ha2UgY29sdW1uIHdpZHRocyBhbmQgcG9zaXRpb25zIHdob2xlIG51bWJlcnMsIG5vdyB0aGV5IGNvbnRhaW4gZGVjaW1hbHMgYWdhaW4sIGNoZWNrIGlmIHRoaXMgaXMgYmVjYXVzZSBvZiB0aGF0XG4gICAgYmFja2dyb3VuZEltYWdlID0gY3JlYXRlQmFja2dyb3VuZChjb2x1bW5zLCB7XG4gICAgICAgIC8vIGNvbHVtbnMuc2xpY2UoMCw1KVxuICAgICAgICBjb2x1bW5TdHJva2VDb2xvcixcbiAgICAgICAgY29sdW1uU3Ryb2tlV2lkdGhcbiAgICB9KTtcbn1cbjwvc2NyaXB0PlxuXG57I2lmIHVzZUNhbnZhc0NvbHVtbnN9XG4gICAgPGRpdiBjbGFzcz1cInNnLWNvbHVtbnMgc2ctY29sdW1ucy0tYmFja2dyb3VuZFwiIHN0eWxlOmJhY2tncm91bmQtaW1hZ2U9e2JhY2tncm91bmRJbWFnZX0+PC9kaXY+XG57OmVsc2V9XG4gICAgPGRpdiBjbGFzcz1cInNnLWNvbHVtbnNcIj5cbiAgICAgICAgeyNlYWNoIGNvbHVtbnMgYXMgY29sdW1ufVxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzPVwic2ctY29sdW1uXCJcbiAgICAgICAgICAgICAgICBzdHlsZT1cIlxuICAgICAgICAgICAgICAgIGJvcmRlci1yaWdodDoge2NvbHVtbi5iZ0hpZ2hsaWdodENvbG9yXG4gICAgICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgICAgICA6IGNvbHVtblN0cm9rZVdpZHRofXB4IHNvbGlkIHtjb2x1bW4uYmdIaWdobGlnaHRDb2xvciB8fCBjb2x1bW5TdHJva2VDb2xvcn07XG4gICAgICAgICAgICAgICAgbGVmdDoge2NvbHVtbi5sZWZ0fXB4O1xuICAgICAgICAgICAgICAgIHdpZHRoOiB7Y29sdW1uLndpZHRofXB4O1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHtjb2x1bW4uYmdIaWdobGlnaHRDb2xvciB8fCBjb2x1bW5EZWZhdWx0Q29sb3J9O1wiXG4gICAgICAgICAgICA+PC9kaXY+XG4gICAgICAgIHsvZWFjaH1cbiAgICA8L2Rpdj5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICAuc2ctY29sdW1ucyB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgLyogQlVHOiBjb2x1bW4gYm9yZGVycyBhcmUgbm90IHNob3dpbmcgY29ycmVjdGx5IHdoZW4gd2lkdGggaXMgdmVyeSBzbWFsbCAqL1xuICAgIH1cblxuICAgIC5zZy1jb2x1bW5zLS1iYWNrZ3JvdW5kIHtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgYmFja2dyb3VuZC1yZXBlYXQ6IHJlcGVhdDtcbiAgICAgICAgYmFja2dyb3VuZC1wb3NpdGlvbi14OiAtMXB4O1xuICAgIH1cblxuICAgIC5zZy1jb2x1bW4ge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUF5Q0ksMEJBQVksQ0FDUixRQUFRLENBQUUsUUFBUSxDQUNsQixNQUFNLENBQUUsSUFBSSxDQUNaLEtBQUssQ0FBRSxJQUVYLENBRUEsc0NBQXdCLENBQ3BCLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLGlCQUFpQixDQUFFLE1BQU0sQ0FDekIscUJBQXFCLENBQUUsSUFDM0IsQ0FFQSx5QkFBVyxDQUNQLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLE1BQU0sQ0FBRSxJQUFJLENBQ1osS0FBSyxDQUFFLElBQUksQ0FDWCxVQUFVLENBQUUsVUFDaEIifQ== */");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function create_else_block2(ctx) {
  let div;
  let each_value = ensure_array_like_dev(
    /*columns*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "class", "sg-columns svelte-1uqfnup");
      add_location(div, file6, 24, 4, 876);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*columns, columnStrokeWidth, columnStrokeColor, columnDefaultColor*/
      29) {
        each_value = ensure_array_like_dev(
          /*columns*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(24:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "sg-columns sg-columns--background svelte-1uqfnup");
      set_style(
        div,
        "background-image",
        /*backgroundImage*/
        ctx[5]
      );
      add_location(div, file6, 22, 4, 769);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*backgroundImage*/
      32) {
        set_style(
          div,
          "background-image",
          /*backgroundImage*/
          ctx2[5]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(22:0) {#if useCanvasColumns}",
    ctx
  });
  return block;
}
function create_each_block3(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "sg-column svelte-1uqfnup");
      set_style(
        div,
        "border-right",
        /*column*/
        (ctx[6].bgHighlightColor ? 0 : (
          /*columnStrokeWidth*/
          ctx[2]
        )) + "px solid " + /*column*/
        (ctx[6].bgHighlightColor || /*columnStrokeColor*/
        ctx[3])
      );
      set_style(
        div,
        "left",
        /*column*/
        ctx[6].left + "px"
      );
      set_style(
        div,
        "width",
        /*column*/
        ctx[6].width + "px"
      );
      set_style(
        div,
        "background-color",
        /*column*/
        ctx[6].bgHighlightColor || /*columnDefaultColor*/
        ctx[4]
      );
      add_location(div, file6, 26, 12, 947);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*columns, columnStrokeWidth, columnStrokeColor*/
      13) {
        set_style(
          div,
          "border-right",
          /*column*/
          (ctx2[6].bgHighlightColor ? 0 : (
            /*columnStrokeWidth*/
            ctx2[2]
          )) + "px solid " + /*column*/
          (ctx2[6].bgHighlightColor || /*columnStrokeColor*/
          ctx2[3])
        );
      }
      if (dirty & /*columns*/
      1) {
        set_style(
          div,
          "left",
          /*column*/
          ctx2[6].left + "px"
        );
      }
      if (dirty & /*columns*/
      1) {
        set_style(
          div,
          "width",
          /*column*/
          ctx2[6].width + "px"
        );
      }
      if (dirty & /*columns, columnDefaultColor*/
      17) {
        set_style(
          div,
          "background-color",
          /*column*/
          ctx2[6].bgHighlightColor || /*columnDefaultColor*/
          ctx2[4]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(26:8) {#each columns as column}",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*useCanvasColumns*/
      ctx2[1]
    ) return create_if_block4;
    return create_else_block2;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Columns", slots, []);
  let { columns } = $$props;
  let { useCanvasColumns = true } = $$props;
  let { columnStrokeWidth } = $$props;
  let { columnStrokeColor } = $$props;
  let { columnDefaultColor = "#ffffff" } = $$props;
  let backgroundImage;
  $$self.$$.on_mount.push(function() {
    if (columns === void 0 && !("columns" in $$props || $$self.$$.bound[$$self.$$.props["columns"]])) {
      console.warn("<Columns> was created without expected prop 'columns'");
    }
    if (columnStrokeWidth === void 0 && !("columnStrokeWidth" in $$props || $$self.$$.bound[$$self.$$.props["columnStrokeWidth"]])) {
      console.warn("<Columns> was created without expected prop 'columnStrokeWidth'");
    }
    if (columnStrokeColor === void 0 && !("columnStrokeColor" in $$props || $$self.$$.bound[$$self.$$.props["columnStrokeColor"]])) {
      console.warn("<Columns> was created without expected prop 'columnStrokeColor'");
    }
  });
  const writable_props = [
    "columns",
    "useCanvasColumns",
    "columnStrokeWidth",
    "columnStrokeColor",
    "columnDefaultColor"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Columns> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("columns" in $$props2) $$invalidate(0, columns = $$props2.columns);
    if ("useCanvasColumns" in $$props2) $$invalidate(1, useCanvasColumns = $$props2.useCanvasColumns);
    if ("columnStrokeWidth" in $$props2) $$invalidate(2, columnStrokeWidth = $$props2.columnStrokeWidth);
    if ("columnStrokeColor" in $$props2) $$invalidate(3, columnStrokeColor = $$props2.columnStrokeColor);
    if ("columnDefaultColor" in $$props2) $$invalidate(4, columnDefaultColor = $$props2.columnDefaultColor);
  };
  $$self.$capture_state = () => ({
    createBackground,
    columns,
    useCanvasColumns,
    columnStrokeWidth,
    columnStrokeColor,
    columnDefaultColor,
    backgroundImage
  });
  $$self.$inject_state = ($$props2) => {
    if ("columns" in $$props2) $$invalidate(0, columns = $$props2.columns);
    if ("useCanvasColumns" in $$props2) $$invalidate(1, useCanvasColumns = $$props2.useCanvasColumns);
    if ("columnStrokeWidth" in $$props2) $$invalidate(2, columnStrokeWidth = $$props2.columnStrokeWidth);
    if ("columnStrokeColor" in $$props2) $$invalidate(3, columnStrokeColor = $$props2.columnStrokeColor);
    if ("columnDefaultColor" in $$props2) $$invalidate(4, columnDefaultColor = $$props2.columnDefaultColor);
    if ("backgroundImage" in $$props2) $$invalidate(5, backgroundImage = $$props2.backgroundImage);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*columns, columnStrokeColor, columnStrokeWidth*/
    13) {
      $: {
        $$invalidate(5, backgroundImage = createBackground(columns, {
          // columns.slice(0,5)
          columnStrokeColor,
          columnStrokeWidth
        }));
      }
    }
  };
  return [
    columns,
    useCanvasColumns,
    columnStrokeWidth,
    columnStrokeColor,
    columnDefaultColor,
    backgroundImage
  ];
}
var Columns = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance9,
      create_fragment9,
      safe_not_equal,
      {
        columns: 0,
        useCanvasColumns: 1,
        columnStrokeWidth: 2,
        columnStrokeColor: 3,
        columnDefaultColor: 4
      },
      add_css6
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Columns",
      options,
      id: create_fragment9.name
    });
  }
  get columns() {
    throw new Error("<Columns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set columns(value) {
    throw new Error("<Columns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useCanvasColumns() {
    throw new Error("<Columns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useCanvasColumns(value) {
    throw new Error("<Columns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get columnStrokeWidth() {
    throw new Error("<Columns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set columnStrokeWidth(value) {
    throw new Error("<Columns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get columnStrokeColor() {
    throw new Error("<Columns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set columnStrokeColor(value) {
    throw new Error("<Columns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get columnDefaultColor() {
    throw new Error("<Columns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set columnDefaultColor(value) {
    throw new Error("<Columns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Columns_default = Columns;

// node_modules/svelte-gantt/svelte/ui/Resizer.svelte
var file7 = "node_modules\\svelte-gantt\\svelte\\ui\\Resizer.svelte";
function add_css7(target) {
  append_styles(target, "svelte-lzaxz7", ".sg-resize.svelte-lzaxz7{z-index:2;background:var(--sg-resize-color);width:5px;cursor:col-resize;position:absolute;height:100%;transition:width 0.2s,\n            transform 0.2s}.sg-resize.svelte-lzaxz7:hover{transform:translateX(-2px);width:10px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVzaXplci5zdmVsdGUiLCJzb3VyY2VzIjpbIlJlc2l6ZXIuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnc3ZlbHRlJztcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cbiAgICBpbXBvcnQgeyB1c2VEcmFnZ2FibGUgfSBmcm9tICcuLi9jb3JlL2RyYWcnO1xuICAgIGltcG9ydCB7IHNldEN1cnNvciB9IGZyb20gJy4uL3V0aWxzL2RvbSc7XG5cbiAgICBleHBvcnQgbGV0IHg7XG4gICAgZXhwb3J0IGxldCBjb250YWluZXI7XG5cbiAgICBsZXQgZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICBjb25zdCBkcmFnT3B0aW9ucyA9IHtcbiAgICAgICAgb25EcmFnOiBldmVudCA9PiB7XG4gICAgICAgICAgICAoeCA9IGV2ZW50LngpLCAoZHJhZ2dpbmcgPSB0cnVlKTtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdyZXNpemUnLCB7IGxlZnQ6IHggfSk7XG4gICAgICAgICAgICBzZXRDdXJzb3IoJ2NvbC1yZXNpemUnKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Ecm9wOiBldmVudCA9PiB7XG4gICAgICAgICAgICAoeCA9IGV2ZW50LngpLCAoZHJhZ2dpbmcgPSBmYWxzZSk7XG4gICAgICAgICAgICBkaXNwYXRjaCgncmVzaXplJywgeyBsZWZ0OiB4IH0pO1xuICAgICAgICAgICAgc2V0Q3Vyc29yKCdkZWZhdWx0Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYWdBbGxvd2VkOiB0cnVlLFxuICAgICAgICByZXNpemVBbGxvd2VkOiBmYWxzZSxcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgIGdldFg6ICgpID0+IHgsXG4gICAgICAgIGdldFk6ICgpID0+IDAsXG4gICAgICAgIGdldFdpZHRoOiAoKSA9PiAwXG4gICAgfTtcblxuICAgICQ6IGRyYWdPcHRpb25zLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuICAgIGZ1bmN0aW9uIHJlc2l6ZXIobm9kZSkge1xuICAgICAgICBjb25zdCBkcmFnZ2FibGUgPSB1c2VEcmFnZ2FibGUobm9kZSwgZHJhZ09wdGlvbnMsICdyZXNpemVyJyk7XG5cbiAgICAgICAgcmV0dXJuIHsgZGVzdHJveTogKCkgPT4gZHJhZ2dhYmxlLmRlc3Ryb3koKSB9O1xuICAgIH1cbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwic2ctcmVzaXplXCIgc3R5bGU9XCJsZWZ0Ont4fXB4XCIgdXNlOnJlc2l6ZXI+PC9kaXY+XG5cbjxzdHlsZT5cbiAgICAuc2ctcmVzaXplIHtcbiAgICAgICAgei1pbmRleDogMjtcbiAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tc2ctcmVzaXplLWNvbG9yKTtcbiAgICAgICAgd2lkdGg6IDVweDtcbiAgICAgICAgY3Vyc29yOiBjb2wtcmVzaXplO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcblxuICAgICAgICB0cmFuc2l0aW9uOlxuICAgICAgICAgICAgd2lkdGggMC4ycyxcbiAgICAgICAgICAgIHRyYW5zZm9ybSAwLjJzO1xuICAgIH1cblxuICAgIC5zZy1yZXNpemU6aG92ZXIge1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTJweCk7XG4gICAgICAgIHdpZHRoOiAxMHB4O1xuICAgIH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBMkNJLHdCQUFXLENBQ1AsT0FBTyxDQUFFLENBQUMsQ0FDVixVQUFVLENBQUUsSUFBSSxpQkFBaUIsQ0FBQyxDQUNsQyxLQUFLLENBQUUsR0FBRyxDQUNWLE1BQU0sQ0FBRSxVQUFVLENBQ2xCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLE1BQU0sQ0FBRSxJQUFJLENBRVosVUFBVSxDQUNOLEtBQUssQ0FBQyxJQUFJO0FBQ3RCLFlBQVksU0FBUyxDQUFDLElBQ2xCLENBRUEsd0JBQVUsTUFBTyxDQUNiLFNBQVMsQ0FBRSxXQUFXLElBQUksQ0FBQyxDQUMzQixLQUFLLENBQUUsSUFDWCJ9 */");
}
function create_fragment10(ctx) {
  let div;
  let resizer_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "sg-resize svelte-lzaxz7");
      set_style(
        div,
        "left",
        /*x*/
        ctx[0] + "px"
      );
      add_location(div, file7, 40, 0, 1014);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(resizer_action = /*resizer*/
        ctx[1].call(null, div));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*x*/
      1) {
        set_style(
          div,
          "left",
          /*x*/
          ctx2[0] + "px"
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Resizer", slots, []);
  const dispatch = createEventDispatcher();
  let { x } = $$props;
  let { container } = $$props;
  let dragging = false;
  const dragOptions = {
    onDrag: (event) => {
      $$invalidate(0, x = event.x), dragging = true;
      dispatch("resize", { left: x });
      setCursor("col-resize");
    },
    onDrop: (event) => {
      $$invalidate(0, x = event.x), dragging = false;
      dispatch("resize", { left: x });
      setCursor("default");
    },
    dragAllowed: true,
    resizeAllowed: false,
    container,
    getX: () => x,
    getY: () => 0,
    getWidth: () => 0
  };
  function resizer(node) {
    const draggable = useDraggable(node, dragOptions, "resizer");
    return { destroy: () => draggable.destroy() };
  }
  $$self.$$.on_mount.push(function() {
    if (x === void 0 && !("x" in $$props || $$self.$$.bound[$$self.$$.props["x"]])) {
      console.warn("<Resizer> was created without expected prop 'x'");
    }
    if (container === void 0 && !("container" in $$props || $$self.$$.bound[$$self.$$.props["container"]])) {
      console.warn("<Resizer> was created without expected prop 'container'");
    }
  });
  const writable_props = ["x", "container"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Resizer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2) $$invalidate(0, x = $$props2.x);
    if ("container" in $$props2) $$invalidate(2, container = $$props2.container);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    dispatch,
    useDraggable,
    setCursor,
    x,
    container,
    dragging,
    dragOptions,
    resizer
  });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2) $$invalidate(0, x = $$props2.x);
    if ("container" in $$props2) $$invalidate(2, container = $$props2.container);
    if ("dragging" in $$props2) dragging = $$props2.dragging;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*container*/
    4) {
      $: dragOptions.container = container;
    }
  };
  return [x, resizer, container];
}
var Resizer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { x: 0, container: 2 }, add_css7);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Resizer",
      options,
      id: create_fragment10.name
    });
  }
  get x() {
    throw new Error("<Resizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<Resizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container() {
    throw new Error("<Resizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error("<Resizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Resizer_default = Resizer;

// node_modules/svelte-gantt/svelte/core/api.js
function controller() {
  const listeners = [];
  function raise(...params) {
    for (const listener of listeners) {
      listener(params);
    }
  }
  ;
  function on(handler) {
    listeners.push(handler);
    const removeListener = () => {
      const index = listeners.indexOf(handler);
      listeners.splice(index, 1);
    };
    return removeListener;
  }
  ;
  return [on, raise];
}
function feature(events) {
  const result = { on: {}, raise: {} };
  for (const event in events) {
    const [on, raise] = events[event];
    result.on[event] = on;
    result.raise[event] = raise;
  }
  return result;
}
var contextKey = {};
function provideGanttApi() {
  return setContext(contextKey, createGanttApi());
}
function createGanttApi() {
  return {
    tasks: feature({
      move: controller(),
      resize: controller(),
      select: controller(),
      switchRow: controller(),
      moveEnd: controller(),
      change: controller(),
      changed: controller(),
      dblclicked: controller()
    }),
    gantt: feature({
      viewChanged: controller(),
      dateSelected: controller()
    }),
    timeranges: feature({
      clicked: controller(),
      resized: controller(),
      changed: controller()
    })
  };
}

// node_modules/svelte-gantt/svelte/core/task.js
function createTaskFactory(params) {
  return {
    createTask: (model) => createTask(model, params),
    reflectTask: (task, targetRow) => reflectTask(task, targetRow, params)
  };
}
function createTask(model, params) {
  model.amountDone = model.amountDone ?? 0;
  model.showButton = model.showButton ?? false;
  model.buttonClasses = model.buttonClasses ?? "";
  model.buttonHtml = model.buttonHtml ?? "";
  const left = params.getPositionByDate(model.from) | 0;
  const right = params.getPositionByDate(model.to) | 0;
  const row = params.rowEntities[model.resourceId];
  const height = (row ? row.height : void 0) - 2 * params.rowPadding;
  const top = (row ? row.y : -1e3) + params.rowPadding;
  return {
    model,
    left,
    width: right - left,
    height,
    top
  };
}
function reflectTask(task, targetRow, params) {
  const reflectedId = `reflected-task-${String(task.model.id)}-${String(targetRow.model.id)}`;
  const model = {
    ...task.model,
    resourceId: targetRow.model.id,
    id: reflectedId,
    enableDragging: false
  };
  return {
    ...task,
    model,
    top: targetRow.y + params.rowPadding,
    reflected: true,
    reflectedOnParent: false,
    reflectedOnChild: true,
    originalId: task.model.id
  };
}

// node_modules/svelte-gantt/svelte/core/row.js
function createRows(rows, params) {
  const context = { y: 0, result: [] };
  createChildRows(rows, context, params);
  return context.result;
}
function createChildRows(rowModels, context, params, parent = null, level = 0, parents = []) {
  const rowsAtLevel = [];
  const allRows = [];
  if (parent) {
    parents = [...parents, parent];
  }
  for (const model of rowModels) {
    const row = createRow(model, context.y, params);
    context.result.push(row);
    rowsAtLevel.push(row);
    allRows.push(row);
    row.childLevel = level;
    row.parent = parent;
    row.allParents = parents;
    if (parent) {
      row.hidden = !(parent.model.expanded || parent.model.expanded == null) || parent.hidden != null && parent.hidden;
    }
    if (!row.hidden) {
      context.y += row.height;
    }
    if (model.children) {
      const nextLevel = createChildRows(model.children, context, params, row, level + 1, parents);
      row.children = nextLevel.rows;
      row.allChildren = nextLevel.allRows;
      allRows.push(...nextLevel.allRows);
    }
  }
  return {
    rows: rowsAtLevel,
    allRows
  };
}
function createRow(model, y, params) {
  const height = model.height ?? params.rowHeight;
  return {
    model,
    y,
    height
  };
}
function expandRow(row) {
  row.model.expanded = true;
  if (row.children)
    show(row.children);
}
function collapseRow(row) {
  row.model.expanded = false;
  if (row.children)
    hide(row.children);
}
function hide(children) {
  for (const row of children) {
    if (row.children)
      hide(row.children);
    row.hidden = true;
  }
}
function show(children, hidden = false) {
  for (const row of children) {
    if (row.children)
      show(row.children, !row.model.expanded);
    row.hidden = hidden;
  }
}

// node_modules/svelte-gantt/svelte/core/timeRange.js
var TimeRangeFactory = class {
  constructor(columnService) {
    __publicField(this, "columnService");
    this.columnService = columnService;
  }
  create(model) {
    model.resizable = model.resizable === void 0 ? true : model.resizable;
    const left = this.columnService.getPositionByDate(model.from);
    const right = this.columnService.getPositionByDate(model.to);
    return {
      model,
      left,
      width: right - left,
      resizing: false
    };
  }
};

// node_modules/svelte-gantt/svelte/core/selectionManager.js
var SelectionManager = class {
  constructor(taskStore) {
    __publicField(this, "taskStore");
    __publicField(this, "_selectedTasks", writable({}));
    this.taskStore = taskStore;
  }
  selectSingle(taskId) {
    this.unSelectTasks();
    this._selectedTasks.set({ [taskId]: true });
  }
  toggleSelection(taskId) {
    this._selectedTasks.update((selections) => ({
      ...selections,
      [taskId]: !selections[taskId]
    }));
  }
  unSelectTasks() {
    this._selectedTasks.set({});
  }
};

// node_modules/svelte-gantt/svelte/core/column.js
function createColumnService(params) {
  function getColumnByDate(date) {
    const pair = findByDate(params.columns, date);
    return !pair[0] ? pair[1] : pair[0];
  }
  function getColumnByPosition(x) {
    const pair = findByPosition(params.columns, x);
    return !pair[0] ? pair[1] : pair[0];
  }
  return {
    getColumnByDate,
    getColumnByPosition,
    getPositionByDate(date) {
      if (!date)
        return null;
      const column = getColumnByDate(date);
      let durationTo = date - column.from;
      const position = durationTo / column.duration * column.width;
      return column.left + position;
    },
    getDateByPosition(x) {
      const column = getColumnByPosition(x);
      x = x - column.left;
      let positionDuration = column.duration / column.width * x;
      const date = column.from + positionDuration;
      return date;
    },
    /**
     * TODO: remove, currently unused
     * @param {number} date - Date
     * @returns {number} rounded date passed as parameter
     */
    roundTo(date) {
      let value = Math.round(date / params.magnetDuration) * params.magnetDuration;
      return value;
    }
  };
}
function findByPosition(columns, x) {
  const result = get(columns, x, (c) => c.left);
  return result;
}
function findByDate(columns, x) {
  const result = get(columns, x, (c) => c.from);
  return result;
}

// node_modules/svelte-gantt/svelte/core/events.js
function createDelegatedEventDispatcher() {
  const callbacks = {};
  return {
    onDelegatedEvent(type2, attr, callback) {
      if (!callbacks[type2])
        callbacks[type2] = {};
      callbacks[type2][attr] = callback;
    },
    offDelegatedEvent(type2, attr) {
      delete callbacks[type2][attr];
    },
    onEvent(e) {
      const { type: type2, target } = e;
      const cbs = callbacks[type2];
      if (!cbs)
        return;
      let match;
      let element2 = target;
      while (element2 && element2 != e.currentTarget) {
        if (match = matches(cbs, element2)) {
          break;
        }
        element2 = element2.parentElement;
      }
      if (match && cbs[match.attr]) {
        cbs[match.attr](e, match.data, element2);
      } else if (cbs["empty"]) {
        cbs["empty"](e, null, element2);
      }
    }
  };
}
function matches(cbs, element2) {
  let data;
  for (const attr in cbs) {
    if (data = element2.getAttribute(attr)) {
      return { attr, data };
    }
  }
}

// node_modules/svelte-gantt/svelte/utils/defaultDateAdapter.js
var DefaultSvelteGanttDateAdapter = class {
  format(date, format) {
    const d = new Date(date);
    switch (format) {
      case "H":
        return d.getHours() + "";
      case "HH":
        return pad(d.getHours());
      case "H:mm":
        return `${d.getHours()}:${pad(d.getMinutes())}`;
      case "hh:mm":
        return `${pad(d.getHours())}:${pad(d.getMinutes())}`;
      case "hh:mm:ss":
        return `${d.getHours()}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
      case "dd/MM/yyyy":
        return `${d.getDate()}/${d.getMonth() + 1}/${d.getFullYear()}`;
      case "dd/MM/yyyy hh:mm":
        return `${d.getDate()}/${d.getMonth() + 1}/${d.getFullYear()} ${d.getHours()}:${d.getMinutes()}`;
      case "dd/MM/yyyy hh:mm:ss":
        return `${d.getDate()}/${d.getMonth() + 1}/${d.getFullYear()} ${d.getHours()}:${d.getMinutes()}:${d.getSeconds()}`;
      case "YYYY":
        return `${d.getFullYear()}`;
      case "Q":
        return `${Math.floor(d.getMonth() / 3 + 1)}`;
      case "[Q]Q":
        return `Q${Math.floor(d.getMonth() / 3 + 1)}`;
      case "YYYY[Q]Q":
        return `${d.getFullYear()}Q${Math.floor(d.getMonth() / 3 + 1)}`;
      case "MM": {
        let month = String(d.getMonth() + 1);
        if (month.length == 1)
          month = `0${month}`;
        return `${month}`;
      }
      case "MMMM": {
        const month = d.toLocaleString("default", { month: "long" });
        return `${month.charAt(0).toUpperCase()}${month.substring(1)}`;
      }
      case "MMMM - YYYY": {
        const month = d.toLocaleString("default", { month: "long" });
        return `${month.charAt(0).toUpperCase()}${month.substring(1)}-${d.getFullYear()}`;
      }
      case "MMMM YYYY": {
        const month = d.toLocaleString("default", { month: "long" });
        return `${month.charAt(0).toUpperCase()}${month.substring(1)} ${d.getFullYear()}`;
      }
      case "MMM": {
        const month = d.toLocaleString("default", { month: "short" });
        return `${month.charAt(0).toUpperCase()}${month.substring(1)}`;
      }
      case "MMM - YYYY": {
        const month = d.toLocaleString("default", { month: "short" });
        return `${month.charAt(0).toUpperCase()}${month.substring(1)} - ${d.getFullYear()}`;
      }
      case "MMM YYYY": {
        const month = d.toLocaleString("default", { month: "short" });
        return `${month.charAt(0).toUpperCase()}${month.substring(1)} ${d.getFullYear()}`;
      }
      case "W":
        return `${getWeekNumber(d)}`;
      case "WW": {
        const weeknumber = getWeekNumber(d);
        return `${weeknumber.toString().length == 1 ? "0" : ""}${weeknumber}`;
      }
      default:
        console.warn(`Date Format '${format}' is not supported, use another date adapter.`);
        return `${d.getDate()}/${d.getMonth() + 1}/${d.getFullYear()}`;
    }
  }
  /**
   * Rounds the date down to the nearest unit
   *
   * Note: This does not consider the timezone, rounds only to the UTC time, which makes it incorrect to round to day start or half hour time zones
   */
  roundTo(date, unit, offset) {
    const magnetDuration = getPeriodDuration(unit, offset);
    const value = Math.round(date / magnetDuration) * magnetDuration;
    return value;
  }
};
function pad(value) {
  let result = value.toString();
  for (let i = result.length; i < 2; i++) {
    result = "0" + result;
  }
  return result;
}
function getWeekNumber(d) {
  d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
  d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
  const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
  const weekNo = Math.ceil(((d.valueOf() - yearStart.valueOf()) / 864e5 + 1) / 7);
  return weekNo;
}
function getPeriodDuration(unit, offset) {
  switch (unit) {
    case "y":
    case "year":
      return offset * 31536e6;
    case "month":
      return offset * 30 * 24 * 60 * 60 * 1e3;
    case "week":
      return offset * 7 * 24 * 60 * 60 * 1e3;
    case "d":
    case "day":
      return offset * 24 * 60 * 60 * 1e3;
    case "h":
    case "hour":
      return offset * 60 * 60 * 1e3;
    case "m":
    case "minute":
      return offset * 60 * 1e3;
    case "s":
    case "second":
      return offset * 1e3;
    default:
      throw new Error(`Unknown unit: ${unit}`);
  }
}

// node_modules/svelte-gantt/svelte/core/layouts.js
var layouts_exports = {};
__export(layouts_exports, {
  expand: () => expand,
  overlap: () => overlap,
  pack: () => pack
});
function overlap(params) {
  const { taskStore, rowStore, rowHeight, rowPadding, rowReflectedTasks } = params;
  let top = 0;
  const result = { changed: false };
  if (!params.invalidateFull) {
    for (const taskId in params.invalidatedTasks) {
      positionTask(taskStore.entities[taskId]);
    }
    return result;
  }
  for (const rowId of rowStore.ids) {
    const row = rowStore.entities[rowId];
    row.y = top;
    const prevHeight = row.height;
    row.height = row.model.height || rowHeight;
    if (!row.hidden) {
      top += row.height;
    }
    if (prevHeight !== row.height) {
      result.changed = true;
    }
    const reflectedTasks = rowReflectedTasks[rowId];
    if (reflectedTasks) {
      for (const task of reflectedTasks) {
        positionTask(task);
      }
    }
  }
  function positionTask(task) {
    const row = rowStore.entities[task.model.resourceId];
    if (!row)
      return;
    task.height = (row ? row.height : void 0) - 2 * rowPadding;
    task.top = row.y + rowPadding;
  }
  for (const taskId of taskStore.ids) {
    positionTask(taskStore.entities[taskId]);
  }
  return result;
}
function pack(params) {
  return _layoutRows(params, false);
}
function expand(params) {
  return _layoutRows(params, true);
}
function _layoutRows(params, expandRow2) {
  const { taskStore, rowStore, rowTasks, rowHeight, rowPadding } = params;
  let top = 0;
  const result = { changed: false };
  for (const rowId of rowStore.ids) {
    const row = rowStore.entities[rowId];
    const taskIds = rowTasks[rowId];
    row.y = top;
    const prevHeight = row.height;
    if (taskIds) {
      const tasks = taskIds.map((taskId) => taskStore.entities[taskId]);
      _layoutRow(tasks, row, {
        rowHeight,
        rowPadding,
        expandRow: expandRow2
      });
    }
    if (!row.hidden) {
      top += row.height;
    }
    if (prevHeight !== row.height) {
      result.changed = true;
    }
  }
}
function _layoutRow(tasks, row, params) {
  if (!tasks.length) {
    return;
  }
  tasks.sort(_byStartThenByLongestSortFn);
  const others = {};
  const context = {};
  const ctx = (task) => context[task.model.id] ?? (context[task.model.id] = {});
  let maxYPos = 0;
  for (const task of tasks) {
    const c = ctx(task);
    c.yPos = 0;
    let fits = false;
    while (!fits) {
      const othersAtYPos = others[c.yPos] || [];
      fits = true;
      for (const other of othersAtYPos) {
        if (_intersects(task, other)) {
          ctx(task).intersects = ctx(other).intersects = true;
          c.yPos++;
          if (c.yPos > maxYPos) {
            maxYPos = c.yPos;
          }
          fits = false;
          break;
        } else {
          continue;
        }
      }
    }
    if (!others[c.yPos]) {
      others[c.yPos] = [];
    }
    others[c.yPos].push(task);
  }
  if (params.expandRow) {
    const contentHeight = (row.model.height || params.rowHeight) - 2 * params.rowPadding;
    row.height = contentHeight * (maxYPos + 1) + 2 * params.rowPadding;
    for (const task of tasks) {
      const c = ctx(task);
      task.height = contentHeight;
      task.top = row.y + params.rowPadding + task.height * c.yPos;
    }
  } else {
    row.height = row.model.height || params.rowHeight;
    const contentHeight = row.height - 2 * params.rowPadding;
    for (const task of tasks) {
      const c = ctx(task);
      task.height = contentHeight / (maxYPos + 1);
      task.top = row.y + params.rowPadding + task.height * c.yPos;
    }
  }
}
function _intersects(left, right) {
  return left.left + left.width > right.left && left.left < right.left + right.width;
}
function _byStartThenByLongestSortFn(a, b) {
  return a.left - b.left || b.left + b.width - (a.left + a.width);
}

// node_modules/svelte-gantt/svelte/modules/create-tasks.js
function useCreateTask() {
  const { columnService, utils } = getContext("services");
  return function createTaskActionBound(node, options) {
    return createTaskAction(node, {
      columnService,
      utils,
      ...options
    });
  };
}
var MIN_DRAG_X2 = 2;
var MIN_DRAG_Y2 = 2;
function createTaskAction(node, options) {
  let startX;
  let startFrom;
  let mouseStartRight;
  let direction;
  let initialX;
  let initialY;
  let triggered = false;
  let deadZone = 10;
  const container = () => options.container;
  function isNearEdge(x, y) {
    const rect = options.boundsContainer.getBoundingClientRect();
    const nearBottomEdge = y - rect.top >= rect.height - deadZone;
    const nearRightEdge = x - rect.left >= rect.width - deadZone;
    return nearBottomEdge || nearRightEdge;
  }
  function onMousedown(event) {
    if (!options.enabled) {
      return;
    }
    event.stopPropagation();
    event.preventDefault();
    if (isNearEdge(event.clientX, event.clientY)) {
      return;
    }
    const [mousePosX, _] = getRelativePosition(container(), event);
    const from = startFrom = options.utils.roundTo(options.columnService.getDateByPosition(mousePosX));
    const x = startX = options.columnService.getPositionByDate(from) | 0;
    const width = 0;
    initialX = event.clientX;
    initialY = event.clientY;
    mouseStartRight = x + width;
    window.addEventListener("pointermove", onMousemove, false);
    window.addEventListener("pointerup", onMouseup);
  }
  ;
  function onMousemove(event) {
    if (!triggered) {
      if (Math.abs(event.clientX - initialX) > MIN_DRAG_X2 || Math.abs(event.clientY - initialY) > MIN_DRAG_Y2) {
        triggered = true;
      } else {
        return;
      }
    }
    event.preventDefault();
    const { x, width, y } = getValues(event);
    options.onMove({
      from: startFrom,
      to: startFrom,
      x,
      width,
      y
    });
  }
  ;
  function getValues(event) {
    const mousePos = getRelativePos(container(), event);
    const x = startX;
    const width = 0;
    let resultX;
    let resultWidth;
    if (direction === "left") {
      if (mouseStartRight - mousePos.x <= 0) {
        direction = "right";
        resultX = mouseStartRight;
        resultWidth = mouseStartRight - mousePos.x;
        mouseStartRight = mouseStartRight + width;
      } else {
        resultX = mousePos.x;
        resultWidth = mouseStartRight - mousePos.x;
      }
    } else {
      if (mousePos.x - x <= 0) {
        direction = "left";
        resultX = mousePos.x;
        resultWidth = mousePos.x - x;
        mouseStartRight = x;
      } else {
        resultX = x;
        resultWidth = mousePos.x - x;
      }
    }
    return { x: resultX, width: resultWidth, y: mousePos.y };
  }
  function onMouseup(event) {
    window.removeEventListener("pointerup", onMouseup);
    window.removeEventListener("pointermove", onMousemove, false);
    if (triggered) {
      const { x, width, y } = getValues(event);
      const newFrom = options.utils.roundTo(options.columnService.getDateByPosition(x));
      const newTo = options.utils.roundTo(options.columnService.getDateByPosition(x + width));
      const newLeft = options.columnService.getPositionByDate(newFrom) | 0;
      const newRight = options.columnService.getPositionByDate(newTo) | 0;
      options.onEnd({
        from: newFrom,
        to: newTo,
        x: newLeft,
        width: newRight - newLeft,
        y
      });
    }
    mouseStartRight = null;
    initialX = null;
    initialY = null;
    triggered = false;
  }
  ;
  node.addEventListener("pointerdown", onMousedown);
  return {
    destroy() {
      node.removeEventListener("pointerdown", onMousedown);
      window.removeEventListener("pointermove", onMousemove);
      window.removeEventListener("pointerup", onMouseup);
    },
    update(opts) {
      Object.assign(options, opts);
    }
  };
}

// node_modules/svelte-gantt/svelte/Gantt.svelte
var { Error: Error_1 } = globals;
var file8 = "node_modules\\svelte-gantt\\svelte\\Gantt.svelte";
function add_css8(target) {
  append_styles(target, "svelte-4g5bd", ".sg-gantt{--sg-column-header-bg-hover:#f9f9f9;--sg-column-border-color:#efefef;--sg-column-header-border-color:#efefef;--sg-table-cell-border-color:#efefef;--sg-table-header-cell-border-color:#efefef;--sg-table-header-cell-bg:#fbfbfb;--sg-resize-color:#e9eaeb;--sg-dependency-arrow-color:#64748b;--sg-task-resize-color:rgba(255, 255, 255, 0.5);--sg-task-selected-outline-color:rgba(3, 169, 244, 0.5)}.sg-disable-transition.svelte-4g5bd .sg-task,.sg-disable-transition.svelte-4g5bd .sg-milestone{transition:transform 0s,\n            background-color 0.2s,\n            width 0s !important}.sg-view:not(:first-child){margin-left:5px}.sg-timeline.svelte-4g5bd{flex:1 1 0%;display:flex;flex-direction:column;overflow-x:auto}.sg-gantt.svelte-4g5bd{display:flex;width:100%;height:100%;position:relative}.sg-foreground.svelte-4g5bd{box-sizing:border-box;overflow:hidden;top:0;left:0;position:absolute;width:100%;height:100%;z-index:1;pointer-events:none}.sg-rows.svelte-4g5bd{width:100%;box-sizing:border-box;overflow:hidden}.sg-timeline-body.svelte-4g5bd{overflow:auto;flex:1 1 auto}.sg-header-scroller.svelte-4g5bd{overflow:hidden;position:relative}.content.svelte-4g5bd{position:relative}*{box-sizing:border-box}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2FudHQuc3ZlbHRlIiwic291cmNlcyI6WyJHYW50dC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5pbXBvcnQgeyBvbk1vdW50LCBzZXRDb250ZXh0LCB0aWNrLCBvbkRlc3Ryb3kgfSBmcm9tICdzdmVsdGUnO1xuaW1wb3J0IHsgd3JpdGFibGUsIGRlcml2ZWQgfSBmcm9tICdzdmVsdGUvc3RvcmUnO1xubGV0IGdhbnR0RWxlbWVudDtcbmxldCBtYWluSGVhZGVyQ29udGFpbmVyO1xubGV0IG1haW5Db250YWluZXI7XG5sZXQgcm93Q29udGFpbmVyO1xubGV0IHNjcm9sbGFibGVzID0gW107XG5sZXQgbW91bnRlZCA9IGZhbHNlO1xuaW1wb3J0IHsgY3JlYXRlRGF0YVN0b3JlIH0gZnJvbSAnLi9jb3JlL3N0b3JlJztcbmltcG9ydCB7IFRhc2ssIFJvdywgVGltZVJhbmdlLCBUaW1lUmFuZ2VIZWFkZXIgfSBmcm9tICcuL2VudGl0aWVzJztcbmltcG9ydCB7IENvbHVtbnMsIENvbHVtbkhlYWRlciB9IGZyb20gJy4vY29sdW1uJztcbmltcG9ydCB7IFJlc2l6ZXIgfSBmcm9tICcuL3VpJztcbmltcG9ydCB7IGNyZWF0ZVV0aWxzLCBnZXRJbmRpY2VzT25seSwgZ2V0UG9zaXRpb25CeURhdGUgfSBmcm9tICcuL3V0aWxzL3V0aWxzJztcbmltcG9ydCB7IGdldFJlbGF0aXZlUG9zLCBpc0xlZnRDbGljayB9IGZyb20gJy4vdXRpbHMvZG9tJztcbmltcG9ydCB7IHByb3ZpZGVHYW50dEFwaSB9IGZyb20gJy4vY29yZS9hcGknO1xuaW1wb3J0IHsgY3JlYXRlVGFza0ZhY3RvcnkgfSBmcm9tICcuL2NvcmUvdGFzayc7XG5pbXBvcnQgeyBjb2xsYXBzZVJvdywgZXhwYW5kUm93LCBjcmVhdGVSb3dzIH0gZnJvbSAnLi9jb3JlL3Jvdyc7XG5pbXBvcnQgeyBUaW1lUmFuZ2VGYWN0b3J5IH0gZnJvbSAnLi9jb3JlL3RpbWVSYW5nZSc7XG5pbXBvcnQgeyBEcmFnZ2FibGVHcm91cCB9IGZyb20gJy4vY29yZS9kcmFnJztcbmltcG9ydCB7IFNlbGVjdGlvbk1hbmFnZXIgfSBmcm9tICcuL2NvcmUvc2VsZWN0aW9uTWFuYWdlcic7XG5pbXBvcnQgeyBjcmVhdGVDb2x1bW5TZXJ2aWNlIH0gZnJvbSAnLi9jb3JlL2NvbHVtbic7XG5pbXBvcnQgeyBjcmVhdGVEZWxlZ2F0ZWRFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuL2NvcmUvZXZlbnRzJztcbmltcG9ydCB7IGdldER1cmF0aW9uLCBnZXRBbGxQZXJpb2RzIH0gZnJvbSAnLi91dGlscy9kYXRlJztcbmltcG9ydCB7IERlZmF1bHRTdmVsdGVHYW50dERhdGVBZGFwdGVyIH0gZnJvbSAnLi91dGlscy9kZWZhdWx0RGF0ZUFkYXB0ZXInO1xuaW1wb3J0ICogYXMgbGF5b3V0cyBmcm9tICcuL2NvcmUvbGF5b3V0cyc7XG5pbXBvcnQgeyB1c2VDcmVhdGVUYXNrIH0gZnJvbSAnLi9tb2R1bGVzL2NyZWF0ZS10YXNrcyc7XG5pbXBvcnQgRHJhZ2dhYmxlIGZyb20gJy4vY29yZS9kcmFnL0RyYWdnYWJsZS5zdmVsdGUnO1xuZnVuY3Rpb24gYXNzZXJ0U2V0KHZhbHVlcykge1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlc1tuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIGlzIG5vdCBzZXRgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUm93cyB0byBsb2FkIGluIHRoZSBnYW50dFxuICovXG5leHBvcnQgbGV0IHJvd3M7XG4vKipcbiAqIFRhc2tzIHRoYXQgZGlzcGxheSBpbiB0aGUgZ2FudHRcbiAqL1xuZXhwb3J0IGxldCB0YXNrcyA9IFtdO1xuLyoqXG4gKiBUaW1lcmFuZ2VzIHRoYXQgZGlzcGxheSBpbiB0aGUgZ2FudHRcbiAqL1xuZXhwb3J0IGxldCB0aW1lUmFuZ2VzID0gW107XG5hc3NlcnRTZXQoeyByb3dzIH0pO1xuJDogaWYgKG1vdW50ZWQpXG4gICAgaW5pdFJvd3Mocm93cyk7XG4kOiBpZiAobW91bnRlZClcbiAgICBpbml0VGFza3ModGFza3MpO1xuJDogaWYgKG1vdW50ZWQpXG4gICAgaW5pdFRpbWVSYW5nZXModGltZVJhbmdlcyk7XG4vKiogdG9wIGFuZCBib3R0b20gcGFkZGluZyBvZiBhIHNpbmdsZSByb3cgaW4gcHggKi9cbmV4cG9ydCBsZXQgcm93UGFkZGluZyA9IDY7XG4vKiogaGVpZ2h0IG9mIGEgc2luZ2xlIHJvdyBpbiBweCAqL1xuZXhwb3J0IGxldCByb3dIZWlnaHQgPSA1MjtcbmNvbnN0IF9yb3dIZWlnaHQgPSB3cml0YWJsZShyb3dIZWlnaHQpO1xuY29uc3QgX3Jvd1BhZGRpbmcgPSB3cml0YWJsZShyb3dQYWRkaW5nKTtcbiQ6ICRfcm93SGVpZ2h0ID0gcm93SGVpZ2h0O1xuJDogJF9yb3dQYWRkaW5nID0gcm93UGFkZGluZztcbmZ1bmN0aW9uIHRvRGF0ZU51bShkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUgaW5zdGFuY2VvZiBEYXRlID8gZGF0ZS52YWx1ZU9mKCkgOiBkYXRlO1xufVxuLyoqIGRhdGV0aW1lIHRpbWVsaW5lIHN0YXJ0cyBvbiwgZGF0ZSAqL1xuZXhwb3J0IGxldCBmcm9tO1xuLyoqIGRhdGV0aW1lIHRpbWVsaW5lIGVuZHMgb24sIGRhdGUgKi9cbmV4cG9ydCBsZXQgdG87XG5hc3NlcnRTZXQoeyBmcm9tLCB0byB9KTtcbmNvbnN0IF9mcm9tID0gd3JpdGFibGUodG9EYXRlTnVtKGZyb20pKTtcbmNvbnN0IF90byA9IHdyaXRhYmxlKHRvRGF0ZU51bSh0bykpO1xuJDogJF9mcm9tID0gdG9EYXRlTnVtKGZyb20pO1xuJDogJF90byA9IHRvRGF0ZU51bSh0byk7XG4vKiogTWluaW11bSB3aWR0aCBvZiBtYWluIGdhbnR0IGFyZWEgaW4gcHggKi9cbmV4cG9ydCBsZXQgbWluV2lkdGggPSA4MDA7XG4vKiogc2hvdWxkIHRpbWVsaW5lIHN0cmV0Y2ggd2lkdGggdG8gZml0ICovXG5leHBvcnQgbGV0IGZpdFdpZHRoID0gZmFsc2U7XG5jb25zdCBfbWluV2lkdGggPSB3cml0YWJsZShtaW5XaWR0aCk7XG5jb25zdCBfZml0V2lkdGggPSB3cml0YWJsZShmaXRXaWR0aCk7XG4kOiB7XG4gICAgJF9taW5XaWR0aCA9IG1pbldpZHRoO1xuICAgICRfZml0V2lkdGggPSBmaXRXaWR0aDtcbn1cbi8qKiBzZXRzIHRvcCBsZXZlbCBnYW50dCBjbGFzcyB3aGljaCBjYW4gYmUgdXNlZCBmb3Igc3R5bGluZyAqL1xuZXhwb3J0IGxldCBjbGFzc2VzID0gW107XG4vKipcbiAqIGxpc3Qgb2YgaGVhZGVycyB1c2VkIGZvciBtYWluIGdhbnR0IGFyZWFcbiAqICAtIHVuaXQ6IHRpbWUgdW5pdCB1c2VkLCBlLmcuIGRheSB3aWxsIGNyZWF0ZSBhIGNlbGwgaW4gdGhlIGhlYWRlciBmb3IgZWFjaCBkYXkgaW4gdGhlIHRpbWVsaW5lXG4gKiAgLSBmb3JtYXQ6IGRhdGV0aW1lIGZvcm1hdCB1c2VkIGZvciBoZWFkZXIgY2VsbCBsYWJlbFxuICoqL1xuZXhwb3J0IGxldCBoZWFkZXJzID0gW1xuICAgIHsgdW5pdDogJ2RheScsIGZvcm1hdDogJ01NTU0gRG8nIH0sXG4gICAgeyB1bml0OiAnaG91cicsIGZvcm1hdDogJ0g6bW0nIH1cbl07XG4vKipcbiAqIExpc3Qgb2Ygem9vbSBsZXZlbHMgZm9yIGdhbnR0LiBHYW50dCBjeWNsZXMgdHJvdWdoIHRoZXNlIHBhcmFtZXRlcnMgb24gY3RybCtzY3JvbGwuXG4gKi9cbmV4cG9ydCBsZXQgem9vbUxldmVscyA9IFtcbiAgICB7XG4gICAgICAgIGhlYWRlcnM6IFtcbiAgICAgICAgICAgIHsgdW5pdDogJ2RheScsIGZvcm1hdDogJ0RELk1NLllZWVknIH0sXG4gICAgICAgICAgICB7IHVuaXQ6ICdob3VyJywgZm9ybWF0OiAnSEgnIH1cbiAgICAgICAgXSxcbiAgICAgICAgbWluV2lkdGg6IDgwMCxcbiAgICAgICAgZml0V2lkdGg6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaGVhZGVyczogW1xuICAgICAgICAgICAgeyB1bml0OiAnaG91cicsIGZvcm1hdDogJ2RkZCBEL00sIEggQScgfSxcbiAgICAgICAgICAgIHsgdW5pdDogJ21pbnV0ZScsIGZvcm1hdDogJ21tJywgb2Zmc2V0OiAxNSB9XG4gICAgICAgIF0sXG4gICAgICAgIG1pbldpZHRoOiA1MDAwLFxuICAgICAgICBmaXRXaWR0aDogZmFsc2VcbiAgICB9XG5dO1xuLyoqIHRhc2sgY29udGVudCBmYWN0b3J5IGZ1bmN0aW9uLCBlLmcuICh0YXNrKSA9PiAnPGRpdj5DdXN0b20gdGFzayBjb250ZW50PC9kaXY+JyAgKi9cbmV4cG9ydCBsZXQgdGFza0NvbnRlbnQgPSBudWxsO1xuLyoqXG4gKiBXaWR0aCBvZiB0YWJsZSwgdXNlZCB3aXRoIFN2ZWx0ZUdhbnR0VGFibGUgbW9kdWxlXG4gKi9cbmV4cG9ydCBsZXQgdGFibGVXaWR0aCA9IDI0MDtcbi8qKiB3aWR0aCBvZiBoYW5kbGUgZm9yIHJlc2l6aW5nIHRhc2sgKi9cbmV4cG9ydCBsZXQgcmVzaXplSGFuZGxlV2lkdGggPSAxMDtcbi8qKiBoYW5kbGVyIG9mIGJ1dHRvbiBjbGlja3MsIGUuZy4gKHRhc2spID0+IHtkZWJ1Z2dlcn0sICovXG5leHBvcnQgbGV0IG9uVGFza0J1dHRvbkNsaWNrID0gbnVsbDtcbmV4cG9ydCBsZXQgZGF0ZUFkYXB0ZXIgPSBuZXcgRGVmYXVsdFN2ZWx0ZUdhbnR0RGF0ZUFkYXB0ZXIoKTtcbi8qKiBtaW5pbXVtIHVuaXQgb2YgdGltZSB0YXNrIGRhdGUgdmFsdWVzIHdpbGwgcm91bmQgdG8gKi9cbmV4cG9ydCBsZXQgbWFnbmV0VW5pdCA9ICdtaW51dGUnO1xuLyoqIGFtb3VudCBvZiB1bml0cyB0YXNrIGRhdGUgdmFsdWVzIHdpbGwgcm91bmQgdG8gKi9cbmV4cG9ydCBsZXQgbWFnbmV0T2Zmc2V0ID0gMTU7XG5sZXQgbWFnbmV0RHVyYXRpb247XG4kOiBzZXRNYWduZXREdXJhdGlvbihtYWduZXRVbml0LCBtYWduZXRPZmZzZXQpO1xuc2V0TWFnbmV0RHVyYXRpb24obWFnbmV0VW5pdCwgbWFnbmV0T2Zmc2V0KTtcbmZ1bmN0aW9uIHNldE1hZ25ldER1cmF0aW9uKHVuaXQsIG9mZnNldCkge1xuICAgIGlmICh1bml0ICYmIG9mZnNldCkge1xuICAgICAgICBtYWduZXREdXJhdGlvbiA9IGdldER1cmF0aW9uKHVuaXQsIG9mZnNldCk7XG4gICAgfVxufVxuLyoqIGR1cmF0aW9uIHVuaXQgb2YgY29sdW1ucyAqL1xuZXhwb3J0IGxldCBjb2x1bW5Vbml0ID0gJ21pbnV0ZSc7XG4vKiogZHVyYXRpb24gd2lkdGggb2YgY29sdW1uICovXG5leHBvcnQgbGV0IGNvbHVtbk9mZnNldCA9IDE1O1xuLy8gZXhwb3J0IHVudGlsIFN2ZWx0ZTMgaW1wbGVtZW50cyBTdmVsdGUyJ3Mgc2V0dXAoY29tcG9uZW50KSBob29rXG5leHBvcnQgbGV0IGdhbnR0VGFibGVNb2R1bGVzID0gW107XG5leHBvcnQgbGV0IGdhbnR0Qm9keU1vZHVsZXMgPSBbXTtcbi8qKlxuICogV2hlbiB0YXNrIGlzIGFzc2lnbmVkIHRvIGEgY2hpbGQgcm93IGRpc3BsYXkgdGhlbSBvbiBwYXJlbnQgcm93cyBhcyB3ZWxsLCB1c2VkIHdoZW4gcm93cyBhcmUgZGlzYWJsZWQgYXMgYSB0cmVlLlxuICovXG5leHBvcnQgbGV0IHJlZmxlY3RPblBhcmVudFJvd3MgPSB0cnVlO1xuLyoqXG4gKiBXaGVuIHRhc2sgaXMgYXNzaWduZWQgdG8gYSBwYXJlbnQgcm93IGRpc3BsYXkgdGhlbSBvbiBjaGlsZCByb3dzIGFzIHdlbGwsIHVzZWQgd2hlbiByb3dzIGFyZSBkaXNhYmxlZCBhcyBhIHRyZWUuXG4gKi9cbmV4cG9ydCBsZXQgcmVmbGVjdE9uQ2hpbGRSb3dzID0gZmFsc2U7XG4vKipcbiAqIFJlbmRlciBjb2x1bW5zIGluIGEgY2FudmFzLCByZXN1bHRzIGluIGEgYmV0dGVyIHBlcmZvcm1hbmNlLlxuICogU2V0IHRvIGZhbHNlIGlmIGFkdmFuY2VkIENTUyBzdHlsaW5nIGlzIG5lZWRlZC5cbiAqKi9cbmV4cG9ydCBsZXQgdXNlQ2FudmFzQ29sdW1ucyA9IHRydWU7XG4vKiogY29sb3Igb2Ygc3Ryb2tlcyBzZXBlcmF0aW5nIHRoZSBjb2x1bW5zIGluIGdhbnR0Ym9keSAqL1xuZXhwb3J0IGxldCBjb2x1bW5TdHJva2VDb2xvciA9ICcjZWZlZmVmJztcbi8qKiB3aWR0aCBvZiBzdHJva2VzIHNlcGVyYXRpbmcgdGhlIGNvbHVtbnMgaW4gZ2FudHRib2R5ICovXG5leHBvcnQgbGV0IGNvbHVtblN0cm9rZVdpZHRoID0gMTtcbi8qKlxuICogb2JqZWN0IGluY2x1ZGluZyBhIHVuaXQgYW5kIGZyYWN0aW9ucyBvZiB0aGF0IHVuaXQgdGhhdCBzaG91bGQgYmUgaGlnaGxpZ2h0ZWQgZWcuIHt1bml0OiAnZGF5cycsIGZyYWN0aW9uczogWzAsNl19IC0+IHdpbGwgaGlnaGxpZ2h0IHdlZWtlbmRzLlxuICogaGlnaGxpZ2h0aW5nIHdpbGwgb25seSB3b3JrIGNvcnJlY3RseSBpZiBoaWdobGlnaHRlZCB1bml0IGlzIHRoZSBzYW1lIG9yIGEgY29uc3RhbnQgZnJhY3Rpb24gb2YgdGhlIGNvbHVtbiB1bml0IGVnLiBkYXlzLCBob3VycywgbWludXRlcyBpbiB0aGUgYWJvdmUuXG4gKi9cbmV4cG9ydCBsZXQgaGlnaGxpZ2h0ZWREdXJhdGlvbnMgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGhpZ2hsaWdodENvbG9yID0gJyM2ZWI4NTknO1xuLyoqIEFsbG93cyB3b3JraW5nIHdpdGggdGhlIGFjdHVhbCBET00gbm9kZSAqL1xuZXhwb3J0IGxldCB0YXNrRWxlbWVudEhvb2sgPSBudWxsO1xuLyoqIENvbnRyb2xzIGhvdyB0aGUgdGFza3Mgd2lsbCByZW5kZXIgKi9cbmV4cG9ydCBsZXQgbGF5b3V0ID0gJ292ZXJsYXAnO1xuY29uc3QgX2xheW91dCA9IHdyaXRhYmxlKGxheW91dCk7XG4kOiAkX2xheW91dCA9IGxheW91dDtcbmNvbnN0IHZpc2libGVXaWR0aCA9IHdyaXRhYmxlKG51bGwpO1xuY29uc3QgdmlzaWJsZUhlaWdodCA9IHdyaXRhYmxlKG51bGwpO1xuY29uc3QgaGVhZGVySGVpZ2h0ID0gd3JpdGFibGUobnVsbCk7XG5jb25zdCBfd2lkdGggPSBkZXJpdmVkKFt2aXNpYmxlV2lkdGgsIF9taW5XaWR0aCwgX2ZpdFdpZHRoXSwgKFt2aXNpYmxlLCBtaW4sIHN0cmV0Y2hdKSA9PiB7XG4gICAgcmV0dXJuIHN0cmV0Y2ggJiYgdmlzaWJsZSA+IG1pbiA/IHZpc2libGUgOiBtaW47XG59KTtcbmNvbnN0IGRhdGFTdG9yZSA9IGNyZWF0ZURhdGFTdG9yZSgpO1xuc2V0Q29udGV4dCgnZGF0YVN0b3JlJywgZGF0YVN0b3JlKTtcbmNvbnN0IHsgcm93U3RvcmUsIHRhc2tTdG9yZSwgdGltZVJhbmdlU3RvcmUsIGFsbFRhc2tzLCBhbGxSb3dzLCBhbGxUaW1lUmFuZ2VzLCByb3dUYXNrQ2FjaGUgfSA9IGRhdGFTdG9yZTtcbmV4cG9ydCBjb25zdCBjb2x1bW5TZXJ2aWNlID0gY3JlYXRlQ29sdW1uU2VydmljZSh7XG4gICAgZ2V0IGNvbHVtbnMoKSB7IHJldHVybiBjb2x1bW5zOyB9LFxuICAgIGdldCBtYWduZXREdXJhdGlvbigpIHsgcmV0dXJuIG1hZ25ldER1cmF0aW9uOyB9LFxufSk7XG5sZXQgZGlzYWJsZVRyYW5zaXRpb24gPSBmYWxzZTtcbmFzeW5jIGZ1bmN0aW9uIHRpY2tXaXRob3V0Q1NTVHJhbnNpdGlvbigpIHtcbiAgICBkaXNhYmxlVHJhbnNpdGlvbiA9IHRydWU7XG4gICAgYXdhaXQgdGljaygpO1xuICAgIGdhbnR0RWxlbWVudC5vZmZzZXRIZWlnaHQ7IC8vIGZvcmNlIGEgcmVmbG93XG4gICAgZGlzYWJsZVRyYW5zaXRpb24gPSBmYWxzZTtcbn1cbmxldCBjb2x1bW5zO1xuJDoge1xuICAgIGNvbHVtbnMgPSBnZXRDb2x1bW5zVjIoJF9mcm9tLCAkX3RvLCBjb2x1bW5Vbml0LCBjb2x1bW5PZmZzZXQsICRfd2lkdGgpO1xuICAgIHRpY2tXaXRob3V0Q1NTVHJhbnNpdGlvbigpO1xuICAgIHJlZnJlc2hUaW1lUmFuZ2VzKCk7XG4gICAgcmVmcmVzaFRhc2tzKCk7XG59XG5mdW5jdGlvbiBnZXRDb2x1bW5zVjIoZnJvbSwgdG8sIHVuaXQsIG9mZnNldCwgd2lkdGgpIHtcbiAgICAvL0JVRzogRnVuY3Rpb24gaXMgcnVubmluZyB0d2ljZSBvbiBpbml0LCBob3cgdG8gcHJldmVudCBpdD9cbiAgICBpZiAoZnJvbSBpbnN0YW5jZW9mIERhdGUpXG4gICAgICAgIGZyb20gPSBmcm9tLnZhbHVlT2YoKTtcbiAgICBpZiAodG8gaW5zdGFuY2VvZiBEYXRlKVxuICAgICAgICB0byA9IHRvLnZhbHVlT2YoKTtcbiAgICBsZXQgY29scyA9IFtdO1xuICAgIGNvbnN0IHBlcmlvZHMgPSBnZXRBbGxQZXJpb2RzKGZyb20udmFsdWVPZigpLCB0by52YWx1ZU9mKCksIHVuaXQsIG9mZnNldCwgaGlnaGxpZ2h0ZWREdXJhdGlvbnMpO1xuICAgIGxldCBsZWZ0ID0gMDtcbiAgICBsZXQgZGlzdGFuY2VfcG9pbnQgPSAwO1xuICAgIHBlcmlvZHMuZm9yRWFjaChmdW5jdGlvbiAocGVyaW9kKSB7XG4gICAgICAgIGxlZnQgPSBkaXN0YW5jZV9wb2ludDtcbiAgICAgICAgZGlzdGFuY2VfcG9pbnQgPSBnZXRQb3NpdGlvbkJ5RGF0ZShwZXJpb2QudG8sICRfZnJvbSwgJF90bywgJF93aWR0aCk7XG4gICAgICAgIGNvbHMucHVzaCh7XG4gICAgICAgICAgICB3aWR0aDogZGlzdGFuY2VfcG9pbnQgLSBsZWZ0LFxuICAgICAgICAgICAgZnJvbTogcGVyaW9kLmZyb20sXG4gICAgICAgICAgICB0bzogcGVyaW9kLnRvLFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBwZXJpb2QuZHVyYXRpb24sXG4gICAgICAgICAgICAuLi4ocGVyaW9kLmlzSGlnaGxpZ2h0ZWQgJiYgeyBiZ0hpZ2hsaWdodENvbG9yOiBoaWdobGlnaHRDb2xvciB9KVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29scztcbn1cbmxldCBvZmZzZXRXaWR0aDtcbmxldCBvZmZzZXRIZWlnaHQ7XG5sZXQgYm90dG9tU2Nyb2xsYmFyVmlzaWJsZSA9IHdyaXRhYmxlKG9mZnNldEhlaWdodCAtICR2aXNpYmxlSGVpZ2h0KTtcbmxldCByaWdodFNjcm9sbGJhclZpc2libGUgPSB3cml0YWJsZShvZmZzZXRXaWR0aCAtICR2aXNpYmxlV2lkdGgpO1xuJDogJGJvdHRvbVNjcm9sbGJhclZpc2libGUgPSBvZmZzZXRIZWlnaHQgLSAkdmlzaWJsZUhlaWdodDtcbiQ6ICRyaWdodFNjcm9sbGJhclZpc2libGUgPSBvZmZzZXRXaWR0aCAtICR2aXNpYmxlV2lkdGg7XG5zZXRDb250ZXh0KCdkaW1lbnNpb25zJywge1xuICAgIGZyb206IF9mcm9tLFxuICAgIHRvOiBfdG8sXG4gICAgd2lkdGg6IF93aWR0aCxcbiAgICB2aXNpYmxlV2lkdGgsXG4gICAgdmlzaWJsZUhlaWdodCxcbiAgICBoZWFkZXJIZWlnaHQsXG4gICAgYm90dG9tU2Nyb2xsYmFyVmlzaWJsZSxcbiAgICByaWdodFNjcm9sbGJhclZpc2libGUsXG59KTtcbnNldENvbnRleHQoJ29wdGlvbnMnLCB7XG4gICAgZGF0ZUFkYXB0ZXIsXG4gICAgdGFza0VsZW1lbnRIb29rLFxuICAgIHRhc2tDb250ZW50LFxuICAgIHJvd1BhZGRpbmc6IF9yb3dQYWRkaW5nLFxuICAgIHJvd0hlaWdodDogX3Jvd0hlaWdodCxcbiAgICBsYXlvdXQ6IF9sYXlvdXQsXG4gICAgcmVzaXplSGFuZGxlV2lkdGg6IHJlc2l6ZUhhbmRsZVdpZHRoLFxuICAgIHJlZmxlY3RPblBhcmVudFJvd3MsXG4gICAgcmVmbGVjdE9uQ2hpbGRSb3dzLFxuICAgIG9uVGFza0J1dHRvbkNsaWNrXG59KTtcbmNvbnN0IGhvdmVyZWRSb3cgPSB3cml0YWJsZShudWxsKTtcbmNvbnN0IHNlbGVjdGVkUm93ID0gd3JpdGFibGUobnVsbCk7XG5jb25zdCBnYW50dENvbnRleHQgPSB7XG4gICAgcm93Q29udGFpbmVyOiBudWxsLFxuICAgIG1haW5Db250YWluZXI6IG51bGwsXG4gICAgbWFpbkhlYWRlckNvbnRhaW5lcjogbnVsbCxcbiAgICBzY3JvbGxhYmxlcyxcbiAgICBob3ZlcmVkUm93LFxuICAgIHNlbGVjdGVkUm93LFxuICAgIHVwZGF0ZUxheW91dCxcbiAgICBleHBhbmRSb3cocm93KSB7XG4gICAgICAgIGV4cGFuZFJvdyhyb3cpO1xuICAgICAgICB1cGRhdGVMYXlvdXQoKTtcbiAgICB9LFxuICAgIGNvbGxhcHNlUm93KHJvdykge1xuICAgICAgICBjb2xsYXBzZVJvdyhyb3cpO1xuICAgICAgICB1cGRhdGVMYXlvdXQoKTtcbiAgICB9LFxuICAgIGludmFsaWRhdGVQb3NpdGlvbixcbn07XG5zZXRDb250ZXh0KCdnYW50dCcsIGdhbnR0Q29udGV4dCk7XG5sZXQgaW52YWxpZGF0ZWRUYXNrcyA9IHt9O1xubGV0IGludmFsaWRhdGVkUm93cyA9IHt9O1xubGV0IGludmFsaWRhdGVGdWxsID0gdHJ1ZTtcbmZ1bmN0aW9uIGludmFsaWRhdGVQb3NpdGlvbih7IHRhc2ssIHJvdyB9KSB7XG4gICAgaWYgKHJvdykge1xuICAgICAgICBpbnZhbGlkYXRlZFJvd3Nbcm93Lm1vZGVsLmlkXSA9IHRydWU7XG4gICAgICAgIGludmFsaWRhdGVGdWxsID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0YXNrKSB7XG4gICAgICAgIGludmFsaWRhdGVkVGFza3NbdGFzay5tb2RlbC5pZF0gPSB0cnVlO1xuICAgICAgICBpbnZhbGlkYXRlZFJvd3NbdGFzay5tb2RlbC5yZXNvdXJjZUlkXSA9IHRydWU7XG4gICAgICAgIGludmFsaWRhdGVGdWxsID0gZmFsc2U7XG4gICAgfVxufVxub25Nb3VudCgoKSA9PiB7XG4gICAgT2JqZWN0LmFzc2lnbihnYW50dENvbnRleHQsIHtcbiAgICAgICAgcm93Q29udGFpbmVyLFxuICAgICAgICBtYWluQ29udGFpbmVyLFxuICAgICAgICBtYWluSGVhZGVyQ29udGFpbmVyXG4gICAgfSk7XG4gICAgbW91bnRlZCA9IHRydWU7XG59KTtcbmNvbnN0IHsgb25EZWxlZ2F0ZWRFdmVudCwgb2ZmRGVsZWdhdGVkRXZlbnQsIG9uRXZlbnQgfSA9IGNyZWF0ZURlbGVnYXRlZEV2ZW50RGlzcGF0Y2hlcigpO1xub25EZWxlZ2F0ZWRFdmVudCgnY2xpY2snLCAnZGF0YS10YXNrLWlkJywgKGV2ZW50LCBkYXRhLCB0YXJnZXQpID0+IHtcbiAgICBjb25zdCB0YXNrSWQgPSBkYXRhO1xuICAgIGNvbnN0IHRhc2sgPSAkdGFza1N0b3JlLmVudGl0aWVzW3Rhc2tJZF07XG4gICAgaWYgKGlzTGVmdENsaWNrKGV2ZW50KSAmJiAhdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnc2ctdGFzay1yZWZsZWN0ZWQnKSAmJiAhdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnc2ctaWdub3JlLWNsaWNrJykpIHtcbiAgICAgICAgaWYgKGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbk1hbmFnZXIudG9nZ2xlU2VsZWN0aW9uKHRhc2tJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25NYW5hZ2VyLnNlbGVjdFNpbmdsZSh0YXNrSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwaVsndGFza3MnXS5yYWlzZS5zZWxlY3QodGFzayk7XG59KTtcbm9uRGVsZWdhdGVkRXZlbnQoJ3BvaW50ZXJvdmVyJywgJ2RhdGEtcm93LWlkJywgKGV2ZW50LCBkYXRhLCB0YXJnZXQpID0+IHtcbiAgICAkaG92ZXJlZFJvdyA9IGRhdGE7XG59KTtcbm9uRGVsZWdhdGVkRXZlbnQoJ2NsaWNrJywgJ2RhdGEtcm93LWlkJywgKGV2ZW50LCBkYXRhLCB0YXJnZXQpID0+IHtcbiAgICBzZWxlY3Rpb25NYW5hZ2VyLnVuU2VsZWN0VGFza3MoKTtcbiAgICBpZiAoJHNlbGVjdGVkUm93ID09IGRhdGEpIHtcbiAgICAgICAgJHNlbGVjdGVkUm93ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAkc2VsZWN0ZWRSb3cgPSBkYXRhO1xufSk7XG5vbkRlbGVnYXRlZEV2ZW50KCdkYmxjbGljaycsICdkYXRhLXRhc2staWQnLCAoZXZlbnQsIGRhdGEsIHRhcmdldCkgPT4ge1xuICAgIGNvbnN0IHRhc2tJZCA9IGRhdGE7XG4gICAgYXBpWyd0YXNrcyddLnJhaXNlLmRibGNsaWNrZWQoJHRhc2tTdG9yZS5lbnRpdGllc1t0YXNrSWRdLCBldmVudCk7XG59KTtcbm9uRGVsZWdhdGVkRXZlbnQoJ3BvaW50ZXJsZWF2ZScsICdlbXB0eScsIChldmVudCwgZGF0YSwgdGFyZ2V0KSA9PiB7XG4gICAgJGhvdmVyZWRSb3cgPSBudWxsO1xufSk7XG5vbkRlc3Ryb3koKCkgPT4ge1xuICAgIG9mZkRlbGVnYXRlZEV2ZW50KCdjbGljaycsICdkYXRhLXRhc2staWQnKTtcbiAgICBvZmZEZWxlZ2F0ZWRFdmVudCgnY2xpY2snLCAnZGF0YS1yb3ctaWQnKTtcbiAgICBvZmZEZWxlZ2F0ZWRFdmVudCgnZGJsY2xpY2snLCAnZGF0YS10YXNrLWlkJyk7XG4gICAgc2VsZWN0aW9uTWFuYWdlci51blNlbGVjdFRhc2tzKCk7XG59KTtcbmxldCBfX3Njcm9sbFRvcCA9IDA7XG5sZXQgX19zY3JvbGxMZWZ0ID0gMDtcbmZ1bmN0aW9uIHNjcm9sbGFibGUobm9kZSkge1xuICAgIGNvbnN0IG9uc2Nyb2xsID0gZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7IHNjcm9sbFRvcCwgc2Nyb2xsTGVmdCB9ID0gbm9kZTtcbiAgICAgICAgc2Nyb2xsYWJsZXMuZm9yRWFjaChzY3JvbGxhYmxlID0+IHtcbiAgICAgICAgICAgIGlmIChzY3JvbGxhYmxlLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxhYmxlLm5vZGUuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxhYmxlLm5vZGUuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgX19zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgIF9fc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG4gICAgfTtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uc2Nyb2xsKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZXN0cm95KCkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvbnNjcm9sbCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhvcml6b250YWxTY3JvbGxMaXN0ZW5lcihub2RlKSB7XG4gICAgc2Nyb2xsYWJsZXMucHVzaCh7IG5vZGUsIG9yaWVudGF0aW9uOiAnaG9yaXpvbnRhbCcgfSk7XG59XG5mdW5jdGlvbiBvblJlc2l6ZShldmVudCkge1xuICAgIHRhYmxlV2lkdGggPSBldmVudC5kZXRhaWwubGVmdDtcbn1cbmxldCB6b29tTGV2ZWwgPSAwO1xubGV0IHpvb21pbmcgPSBmYWxzZTtcbmFzeW5jIGZ1bmN0aW9uIG9ud2hlZWwoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuY3RybEtleSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCBwcmV2Wm9vbUxldmVsID0gem9vbUxldmVsO1xuICAgICAgICBpZiAoZXZlbnQuZGVsdGFZID4gMCkge1xuICAgICAgICAgICAgem9vbUxldmVsID0gTWF0aC5tYXgoem9vbUxldmVsIC0gMSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB6b29tTGV2ZWwgPSBNYXRoLm1pbih6b29tTGV2ZWwgKyAxLCB6b29tTGV2ZWxzLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2Wm9vbUxldmVsICE9IHpvb21MZXZlbCAmJiB6b29tTGV2ZWxzW3pvb21MZXZlbF0pIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgY29sdW1uVW5pdDogY29sdW1uVW5pdCxcbiAgICAgICAgICAgICAgICBjb2x1bW5PZmZzZXQ6IGNvbHVtbk9mZnNldCxcbiAgICAgICAgICAgICAgICBtaW5XaWR0aDogJF9taW5XaWR0aCxcbiAgICAgICAgICAgICAgICAuLi56b29tTGV2ZWxzW3pvb21MZXZlbF1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzY2FsZSA9IG9wdGlvbnMubWluV2lkdGggLyAkX3dpZHRoO1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG1haW5Db250YWluZXI7XG4gICAgICAgICAgICBjb25zdCBtb3VzZXBvcyA9IGdldFJlbGF0aXZlUG9zKG5vZGUsIGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGJlZm9yZSA9IG5vZGUuc2Nyb2xsTGVmdCArIG1vdXNlcG9zLng7XG4gICAgICAgICAgICBjb25zdCBhZnRlciA9IGJlZm9yZSAqIHNjYWxlO1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsTGVmdCA9IGFmdGVyIC0gbW91c2Vwb3MueCArIG5vZGUuY2xpZW50V2lkdGggLyAyO1xuICAgICAgICAgICAgY29sdW1uVW5pdCA9IG9wdGlvbnMuY29sdW1uVW5pdDtcbiAgICAgICAgICAgIGNvbHVtbk9mZnNldCA9IG9wdGlvbnMuY29sdW1uT2Zmc2V0O1xuICAgICAgICAgICAgJF9taW5XaWR0aCA9IG9wdGlvbnMubWluV2lkdGg7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgICAgIGhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5maXRXaWR0aClcbiAgICAgICAgICAgICAgICAkX2ZpdFdpZHRoID0gb3B0aW9ucy5maXRXaWR0aDtcbiAgICAgICAgICAgIGFwaVsnZ2FudHQnXS5yYWlzZS52aWV3Q2hhbmdlZCgpO1xuICAgICAgICAgICAgem9vbWluZyA9IHRydWU7XG4gICAgICAgICAgICBhd2FpdCB0aWNrKCk7XG4gICAgICAgICAgICBub2RlLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICAgICAgem9vbWluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gb25EYXRlU2VsZWN0ZWQoZXZlbnQpIHtcbiAgICAkX2Zyb20gPSBldmVudC5kZXRhaWwuZnJvbTtcbiAgICAkX3RvID0gZXZlbnQuZGV0YWlsLnRvO1xuICAgIGFwaVsnZ2FudHQnXS5yYWlzZS5kYXRlU2VsZWN0ZWQoeyBmcm9tOiAkX2Zyb20sIHRvOiAkX3RvIH0pO1xufVxuZnVuY3Rpb24gaW5pdFJvd3Mocm93c0RhdGEpIHtcbiAgICAvL0J1ZzogUnVubmluZyB0d2ljZSBvbiBjaGFuZ2Ugb3B0aW9uc1xuICAgIGNvbnN0IHJvd3MgPSBjcmVhdGVSb3dzKHJvd3NEYXRhLCB7IHJvd0hlaWdodCB9KTtcbiAgICByb3dTdG9yZS5hZGRBbGwocm93cyk7XG4gICAgdXBkYXRlTGF5b3V0KCk7XG59XG5jb25zdCB7IGNyZWF0ZVRhc2ssIHJlZmxlY3RUYXNrIH0gPSBjcmVhdGVUYXNrRmFjdG9yeSh7XG4gICAgZ2V0IHJvd0VudGl0aWVzKCkgeyByZXR1cm4gJHJvd1N0b3JlLmVudGl0aWVzOyB9LFxuICAgIGdldCByb3dQYWRkaW5nKCkgeyByZXR1cm4gcm93UGFkZGluZzsgfSxcbiAgICBnZXRQb3NpdGlvbkJ5RGF0ZTogKGRhdGUpID0+IGNvbHVtblNlcnZpY2UuZ2V0UG9zaXRpb25CeURhdGUoZGF0ZSksXG59KTtcbmFzeW5jIGZ1bmN0aW9uIGluaXRUYXNrcyh0YXNrRGF0YSkge1xuICAgIGNvbnN0IHRhc2tzID0gW107XG4gICAgZm9yIChjb25zdCB0YXNrTW9kZWwgb2YgdGFza0RhdGEpIHtcbiAgICAgICAgaWYgKCFkcmFnZ2luZ1Rhc2tzW3Rhc2tNb2RlbC5pZF0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkcmFnZ2luZ1Rhc2tzW3Rhc2tNb2RlbC5pZF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFzayA9IGNyZWF0ZVRhc2sodGFza01vZGVsKTtcbiAgICAgICAgdGFza3MucHVzaCh0YXNrKTtcbiAgICB9XG4gICAgdGFza1N0b3JlLmFkZEFsbCh0YXNrcyk7XG4gICAgdXBkYXRlTGF5b3V0KCk7XG59XG5sZXQgX3JlZmxlY3RlZFRhc2tzQ2FjaGUgPSB7fTtcbiQ6IHtcbiAgICBfcmVmbGVjdGVkVGFza3NDYWNoZSA9IHt9O1xuICAgIGZvciAoY29uc3QgdGFzayBvZiAkYWxsVGFza3MpIHtcbiAgICAgICAgY29uc3Qgcm93ID0gJHJvd1N0b3JlLmVudGl0aWVzW3Rhc2subW9kZWwucmVzb3VyY2VJZF07XG4gICAgICAgIGlmICghcm93KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmbGVjdE9uQ2hpbGRSb3dzICYmIHJvdy5hbGxDaGlsZHJlbikge1xuICAgICAgICAgICAgcm93LmFsbENoaWxkcmVuLmZvckVhY2gociA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmbGVjdGVkVGFzayA9IHJlZmxlY3RUYXNrKHRhc2ssIHIpO1xuICAgICAgICAgICAgICAgIGlmICghX3JlZmxlY3RlZFRhc2tzQ2FjaGVbci5tb2RlbC5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgX3JlZmxlY3RlZFRhc2tzQ2FjaGVbci5tb2RlbC5pZF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3JlZmxlY3RlZFRhc2tzQ2FjaGVbci5tb2RlbC5pZF0ucHVzaChyZWZsZWN0ZWRUYXNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZsZWN0T25QYXJlbnRSb3dzICYmIHJvdy5hbGxQYXJlbnRzKSB7XG4gICAgICAgICAgICByb3cuYWxsUGFyZW50cy5mb3JFYWNoKHIgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZmxlY3RlZFRhc2sgPSByZWZsZWN0VGFzayh0YXNrLCByKTtcbiAgICAgICAgICAgICAgICBpZiAoIV9yZWZsZWN0ZWRUYXNrc0NhY2hlW3IubW9kZWwuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIF9yZWZsZWN0ZWRUYXNrc0NhY2hlW3IubW9kZWwuaWRdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9yZWZsZWN0ZWRUYXNrc0NhY2hlW3IubW9kZWwuaWRdLnB1c2gocmVmbGVjdGVkVGFzayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGluaXRUaW1lUmFuZ2VzKHRpbWVSYW5nZURhdGEpIHtcbiAgICBjb25zdCB0aW1lUmFuZ2VzID0gdGltZVJhbmdlRGF0YS5tYXAodGltZVJhbmdlID0+IHtcbiAgICAgICAgcmV0dXJuIHRpbWVSYW5nZUZhY3RvcnkuY3JlYXRlKHRpbWVSYW5nZSk7XG4gICAgfSk7XG4gICAgdGltZVJhbmdlU3RvcmUuYWRkQWxsKHRpbWVSYW5nZXMpO1xufVxuZXhwb3J0IGNvbnN0IGFwaSA9IHByb3ZpZGVHYW50dEFwaSgpO1xuY29uc3Qgc2VsZWN0aW9uTWFuYWdlciA9IG5ldyBTZWxlY3Rpb25NYW5hZ2VyKHRhc2tTdG9yZSk7XG5leHBvcnQgY29uc3QgdGltZVJhbmdlRmFjdG9yeSA9IG5ldyBUaW1lUmFuZ2VGYWN0b3J5KGNvbHVtblNlcnZpY2UpO1xuZXhwb3J0IGNvbnN0IHV0aWxzID0gY3JlYXRlVXRpbHMoe1xuICAgIGdldCBmcm9tKCkgeyByZXR1cm4gJF9mcm9tOyB9LFxuICAgIGdldCB0bygpIHsgcmV0dXJuICRfdG87IH0sXG4gICAgZ2V0IHdpZHRoKCkgeyByZXR1cm4gJF93aWR0aDsgfSxcbiAgICBnZXQgbWFnbmV0T2Zmc2V0KCkgeyByZXR1cm4gbWFnbmV0T2Zmc2V0OyB9LFxuICAgIGdldCBtYWduZXRVbml0KCkgeyByZXR1cm4gbWFnbmV0VW5pdDsgfSxcbiAgICBnZXQgbWFnbmV0RHVyYXRpb24oKSB7IHJldHVybiBtYWduZXREdXJhdGlvbjsgfSxcbiAgICBnZXQgZGF0ZUFkYXB0ZXIoKSB7IHJldHVybiBkYXRlQWRhcHRlcjsgfSxcbn0pO1xuc2V0Q29udGV4dCgnc2VydmljZXMnLCB7XG4gICAgdXRpbHMsXG4gICAgYXBpLFxuICAgIHNlbGVjdGlvbk1hbmFnZXIsXG4gICAgY29sdW1uU2VydmljZSxcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHJlZnJlc2hUaW1lUmFuZ2VzKCkge1xuICAgIHRpbWVSYW5nZVN0b3JlLl91cGRhdGUoKHsgaWRzLCBlbnRpdGllcyB9KSA9PiB7XG4gICAgICAgIGlkcy5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVSYW5nZSA9IGVudGl0aWVzW2lkXTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0xlZnQgPSBjb2x1bW5TZXJ2aWNlLmdldFBvc2l0aW9uQnlEYXRlKHRpbWVSYW5nZS5tb2RlbC5mcm9tKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBuZXdSaWdodCA9IGNvbHVtblNlcnZpY2UuZ2V0UG9zaXRpb25CeURhdGUodGltZVJhbmdlLm1vZGVsLnRvKSB8IDA7XG4gICAgICAgICAgICB0aW1lUmFuZ2UubGVmdCA9IG5ld0xlZnQ7XG4gICAgICAgICAgICB0aW1lUmFuZ2Uud2lkdGggPSBuZXdSaWdodCAtIG5ld0xlZnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBpZHMsIGVudGl0aWVzIH07XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVmcmVzaFRhc2tzKCkge1xuICAgICRhbGxUYXNrcy5mb3JFYWNoKHRhc2sgPT4ge1xuICAgICAgICBjb25zdCBuZXdMZWZ0ID0gY29sdW1uU2VydmljZS5nZXRQb3NpdGlvbkJ5RGF0ZSh0YXNrLm1vZGVsLmZyb20pIHwgMDtcbiAgICAgICAgY29uc3QgbmV3UmlnaHQgPSBjb2x1bW5TZXJ2aWNlLmdldFBvc2l0aW9uQnlEYXRlKHRhc2subW9kZWwudG8pIHwgMDtcbiAgICAgICAgdGFzay5sZWZ0ID0gbmV3TGVmdDtcbiAgICAgICAgdGFzay53aWR0aCA9IG5ld1JpZ2h0IC0gbmV3TGVmdDtcbiAgICB9KTtcbiAgICB0YXNrU3RvcmUucmVmcmVzaCgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvd0NvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gcm93Q29udGFpbmVyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdFRhc2soaWQpIHtcbiAgICBjb25zdCB0YXNrID0gJHRhc2tTdG9yZS5lbnRpdGllc1tpZF07XG4gICAgaWYgKHRhc2spIHtcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlci5zZWxlY3RTaW5nbGUoaWQpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB1bnNlbGVjdFRhc2tzKCkge1xuICAgIHNlbGVjdGlvbk1hbmFnZXIudW5TZWxlY3RUYXNrcygpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbFRvUm93KGlkLCBzY3JvbGxCZWhhdmlvciA9ICdhdXRvJykge1xuICAgIGNvbnN0IHsgc2Nyb2xsVG9wLCBjbGllbnRIZWlnaHQgfSA9IG1haW5Db250YWluZXI7XG4gICAgY29uc3Qgcm93ID0gJHJvd1N0b3JlLmVudGl0aWVzW2lkXTtcbiAgICBpZiAoIXJvdykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFRvcCA9IHJvdy55O1xuICAgIGlmICh0YXJnZXRUb3AgPCBzY3JvbGxUb3ApIHtcbiAgICAgICAgbWFpbkNvbnRhaW5lci5zY3JvbGxUbyh7XG4gICAgICAgICAgICB0b3A6IHRhcmdldFRvcCxcbiAgICAgICAgICAgIGJlaGF2aW9yOiBzY3JvbGxCZWhhdmlvclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRhcmdldFRvcCA+IHNjcm9sbFRvcCArIGNsaWVudEhlaWdodCkge1xuICAgICAgICBtYWluQ29udGFpbmVyLnNjcm9sbFRvKHtcbiAgICAgICAgICAgIHRvcDogdGFyZ2V0VG9wICsgcm93LmhlaWdodCAtIGNsaWVudEhlaWdodCxcbiAgICAgICAgICAgIGJlaGF2aW9yOiBzY3JvbGxCZWhhdmlvclxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gc2Nyb2xsVG9UYXNrKGlkLCBzY3JvbGxCZWhhdmlvciA9ICdhdXRvJykge1xuICAgIGNvbnN0IHsgc2Nyb2xsTGVmdCwgc2Nyb2xsVG9wLCBjbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0IH0gPSBtYWluQ29udGFpbmVyO1xuICAgIGNvbnN0IHRhc2sgPSAkdGFza1N0b3JlLmVudGl0aWVzW2lkXTtcbiAgICBpZiAoIXRhc2spXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCByb3cgPSAkcm93U3RvcmUuZW50aXRpZXNbdGFzay5tb2RlbC5yZXNvdXJjZUlkXTtcbiAgICBpZiAoIXJvdylcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHRhcmdldExlZnQgPSB0YXNrLmxlZnQ7XG4gICAgY29uc3QgdGFyZ2V0VG9wID0gcm93Lnk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgdG9wOiB1bmRlZmluZWQsXG4gICAgICAgIGxlZnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgYmVoYXZpb3I6IHNjcm9sbEJlaGF2aW9yXG4gICAgfTtcbiAgICBpZiAodGFyZ2V0TGVmdCA8IHNjcm9sbExlZnQpIHtcbiAgICAgICAgb3B0aW9ucy5sZWZ0ID0gdGFyZ2V0TGVmdDtcbiAgICB9XG4gICAgaWYgKHRhcmdldExlZnQgPiBzY3JvbGxMZWZ0ICsgY2xpZW50V2lkdGgpIHtcbiAgICAgICAgb3B0aW9ucy5sZWZ0ID0gdGFyZ2V0TGVmdCArIHRhc2sud2lkdGggLSBjbGllbnRXaWR0aDtcbiAgICB9XG4gICAgaWYgKHRhcmdldFRvcCA8IHNjcm9sbFRvcCkge1xuICAgICAgICBvcHRpb25zLnRvcCA9IHRhcmdldFRvcDtcbiAgICB9XG4gICAgaWYgKHRhcmdldFRvcCA+IHNjcm9sbFRvcCArIGNsaWVudEhlaWdodCkge1xuICAgICAgICBvcHRpb25zLnRvcCA9IHRhcmdldFRvcCArIHJvdy5oZWlnaHQgLSBjbGllbnRIZWlnaHQ7XG4gICAgfVxuICAgIG1haW5Db250YWluZXIuc2Nyb2xsVG8ob3B0aW9ucyk7XG59XG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlVGFzayhtb2RlbCkge1xuICAgIGNvbnN0IHRhc2sgPSBjcmVhdGVUYXNrKG1vZGVsKTtcbiAgICB0YXNrU3RvcmUudXBzZXJ0KHRhc2spO1xuICAgIGludmFsaWRhdGVQb3NpdGlvbih7IHRhc2sgfSk7XG4gICAgdXBkYXRlTGF5b3V0U3luYygpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVRhc2tzKG1vZGVscykge1xuICAgIGNvbnN0IHRhc2tzID0gbW9kZWxzLm1hcChtb2RlbCA9PiBjcmVhdGVUYXNrKG1vZGVsKSk7XG4gICAgdGFza1N0b3JlLnVwc2VydEFsbCh0YXNrcyk7XG4gICAgdGFza3MuZm9yRWFjaCh0YXNrID0+IGludmFsaWRhdGVQb3NpdGlvbih7IHRhc2sgfSkpO1xuICAgIHVwZGF0ZUxheW91dFN5bmMoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVUYXNrKHRhc2tJZCkge1xuICAgIGNvbnN0IHRhc2sgPSAkdGFza1N0b3JlLmVudGl0aWVzW3Rhc2tJZF07XG4gICAgaWYgKCF0YXNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGFza1N0b3JlLmRlbGV0ZSh0YXNrSWQpO1xuICAgIGNvbnN0IHJvdyA9ICRyb3dTdG9yZS5lbnRpdGllc1t0YXNrLm1vZGVsLnJlc291cmNlSWRdO1xuICAgIGlmICghcm93KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52YWxpZGF0ZVBvc2l0aW9uKHsgcm93IH0pO1xuICAgIHVwZGF0ZUxheW91dFN5bmMoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVUYXNrcyh0YXNrSWRzKSB7XG4gICAgZm9yIChjb25zdCB0YXNrSWQgb2YgdGFza0lkcykge1xuICAgICAgICBjb25zdCB0YXNrID0gJHRhc2tTdG9yZS5lbnRpdGllc1t0YXNrSWRdO1xuICAgICAgICBpZiAoIXRhc2spIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdyA9ICRyb3dTdG9yZS5lbnRpdGllc1t0YXNrLm1vZGVsLnJlc291cmNlSWRdO1xuICAgICAgICBpZiAoIXJvdykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaW52YWxpZGF0ZVBvc2l0aW9uKHsgcm93IH0pO1xuICAgIH1cbiAgICB0YXNrU3RvcmUuZGVsZXRlQWxsKHRhc2tJZHMpO1xuICAgIHVwZGF0ZUxheW91dFN5bmMoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVSb3cobW9kZWwpIHtcbiAgICBjb25zdCByb3cgPSBjcmVhdGVSb3dzKFttb2RlbF0sIHsgcm93SGVpZ2h0IH0pO1xuICAgIHJvd1N0b3JlLnVwc2VydEFsbChyb3cpO1xuICAgIHVwZGF0ZUxheW91dCgpO1xuICAgIHVwZGF0ZUxheW91dFN5bmMoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVSb3dzKG1vZGVscykge1xuICAgIGNvbnN0IHJvd3MgPSBjcmVhdGVSb3dzKG1vZGVscywgeyByb3dIZWlnaHQgfSk7XG4gICAgcm93U3RvcmUudXBzZXJ0QWxsKHJvd3MpO1xuICAgIHVwZGF0ZUxheW91dCgpO1xuICAgIHVwZGF0ZUxheW91dFN5bmMoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3cocmVzb3VyY2VJZCkge1xuICAgIHJldHVybiAkcm93U3RvcmUuZW50aXRpZXNbcmVzb3VyY2VJZF07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0VGFzayhpZCkge1xuICAgIHJldHVybiAkdGFza1N0b3JlLmVudGl0aWVzW2lkXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRUYXNrcyhyZXNvdXJjZUlkKSB7XG4gICAgaWYgKCRyb3dUYXNrQ2FjaGVbcmVzb3VyY2VJZF0pIHtcbiAgICAgICAgcmV0dXJuICRyb3dUYXNrQ2FjaGVbcmVzb3VyY2VJZF0ubWFwKGlkID0+ICR0YXNrU3RvcmUuZW50aXRpZXNbaWRdKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5sZXQgZmlsdGVyZWRSb3dzID0gW107XG5sZXQgcm93c0FyZU9mU2FtZUhlaWdodCA9IHRydWU7XG5sZXQgcm93Q29udGFpbmVySGVpZ2h0ID0gMDtcbiQ6IHtcbiAgICBmaWx0ZXJlZFJvd3MgPSBbXTtcbiAgICByb3dDb250YWluZXJIZWlnaHQgPSAwO1xuICAgIGxheW91dENoYW5nZWQ7XG4gICAgY29uc3QgZmlyc3RSb3cgPSAkYWxsUm93c1swXTtcbiAgICBmb3IgKGNvbnN0IHJvdyBvZiAkYWxsUm93cykge1xuICAgICAgICBpZiAoIXJvdy5oaWRkZW4pIHtcbiAgICAgICAgICAgIGZpbHRlcmVkUm93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgICBpZiAoZmlyc3RSb3cgJiYgZmlyc3RSb3cuaGVpZ2h0ICE9PSByb3cuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcm93c0FyZU9mU2FtZUhlaWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93Q29udGFpbmVySGVpZ2h0ICs9IHJvdy5oZWlnaHQgfHwgcm93SGVpZ2h0O1xuICAgICAgICB9XG4gICAgfVxufVxubGV0IHN0YXJ0SW5kZXg7XG4kOiB7XG4gICAgaWYgKHJvd3NBcmVPZlNhbWVIZWlnaHQpIHtcbiAgICAgICAgY29uc3Qgcm93SGVpZ2h0ID0gcm93Q29udGFpbmVySGVpZ2h0IC8gZmlsdGVyZWRSb3dzLmxlbmd0aDtcbiAgICAgICAgc3RhcnRJbmRleCA9IE1hdGguZmxvb3IoX19zY3JvbGxUb3AgLyByb3dIZWlnaHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RhcnRJbmRleCA9IGdldEluZGljZXNPbmx5KGZpbHRlcmVkUm93cywgX19zY3JvbGxUb3AsIHJvdyA9PiByb3cueSlbMF07XG4gICAgfVxufVxubGV0IGVuZEluZGV4O1xuJDoge1xuICAgIGlmIChyb3dzQXJlT2ZTYW1lSGVpZ2h0KSB7XG4gICAgICAgIGVuZEluZGV4ID0gTWF0aC5taW4oc3RhcnRJbmRleCArIE1hdGguY2VpbCgkdmlzaWJsZUhlaWdodCAvIHJvd0hlaWdodCksIGZpbHRlcmVkUm93cy5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVuZEluZGV4ID0gZ2V0SW5kaWNlc09ubHkoZmlsdGVyZWRSb3dzLCBfX3Njcm9sbFRvcCArICR2aXNpYmxlSGVpZ2h0LCByb3cgPT4gcm93LnkpWzBdO1xuICAgIH1cbn1cbmxldCBwYWRkaW5nVG9wID0gMDtcbiQ6IHtcbiAgICBwYWRkaW5nVG9wID0gZmlsdGVyZWRSb3dzW3N0YXJ0SW5kZXhdID8gZmlsdGVyZWRSb3dzW3N0YXJ0SW5kZXhdLnkgOiAwO1xufVxubGV0IHZpc2libGVSb3dzID0gW107XG4kOiB2aXNpYmxlUm93cyA9IGZpbHRlcmVkUm93cy5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCArIDEpO1xubGV0IHZpc2libGVUYXNrczsgLy8gdHJ5IHRvIGtlZXAgdGhlIHNhbWUgb3JkZXIgaW4gdGhlIGFycmF5IGFzIGJlZm9yZVxubGV0IHByZXZpb3VzT3JkZXIgPSB7fTtcbiQ6IHtcbiAgICBjb25zdCB0YXNrcyA9IFtdO1xuICAgIGNvbnN0IHJlbmRlcmVkID0ge307XG4gICAgY29uc3QgdGFza3NPcmRlcmVkID0gW107XG4gICAgY29uc3Qgb3JkZXIgPSB7fTtcbiAgICAvLyBiZWNhdXNlIHN2ZWx0ZSBkZXRhY2hlcyBodG1sIGVsZW1lbnRzIHdoZW4gdGhlaXIgb3JkZXIgY2hhbmdlcyAoZXZlbiB3aGVuIGtleWVkKVxuICAgIC8vIHRoaXMgaGVscHMgQ1NTIHRyYW5zaXRpb25zXG4gICAgbGV0IG9yZGVyZWQgPSB0cnVlO1xuICAgIGxldCBvcmRpbmFsID0gMDtcbiAgICBmdW5jdGlvbiB0cnlSZXN0b3JlUG9zaXRpb24odGFzaykge1xuICAgICAgICBpZiAoIXRhc2spXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRhc2tzLnB1c2godGFzayk7XG4gICAgICAgIGNvbnN0IGlkID0gdGFzay5tb2RlbC5pZDtcbiAgICAgICAgaWYgKHByZXZpb3VzT3JkZXJbaWRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRhc2tzT3JkZXJlZFtwcmV2aW91c09yZGVyW2lkXV0gPSB0YXNrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3JkZXJlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG9yZGVyW2lkXSA9IG9yZGluYWwrKztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aXNpYmxlUm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCByb3cgPSB2aXNpYmxlUm93c1tpXTtcbiAgICAgICAgaWYgKCRyb3dUYXNrQ2FjaGVbcm93Lm1vZGVsLmlkXSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAkcm93VGFza0NhY2hlW3Jvdy5tb2RlbC5pZF0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9ICRyb3dUYXNrQ2FjaGVbcm93Lm1vZGVsLmlkXVtqXTtcbiAgICAgICAgICAgICAgICByZW5kZXJlZFtpZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeVJlc3RvcmVQb3NpdGlvbigkdGFza1N0b3JlLmVudGl0aWVzW2lkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9yZWZsZWN0ZWRUYXNrc0NhY2hlW3Jvdy5tb2RlbC5pZF0pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGFzayBvZiBfcmVmbGVjdGVkVGFza3NDYWNoZVtyb3cubW9kZWwuaWRdKSB7XG4gICAgICAgICAgICAgICAgdHJ5UmVzdG9yZVBvc2l0aW9uKHRhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHJlbmRlciBhbGwgdGFza3MgYmVpbmcgZHJhZ2dlZCBpZiBub3QgYWxyZWFkeVxuICAgIGZvciAoY29uc3QgaWQgaW4gZHJhZ2dpbmdUYXNrcykge1xuICAgICAgICBpZiAoIXJlbmRlcmVkW2lkXSkge1xuICAgICAgICAgICAgcmVuZGVyZWRbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyeVJlc3RvcmVQb3NpdGlvbigkdGFza1N0b3JlLmVudGl0aWVzW2lkXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhc2tzT3JkZXJlZC5sZW5ndGggIT09IHRhc2tzLmxlbmd0aCkge1xuICAgICAgICBvcmRlcmVkID0gZmFsc2U7XG4gICAgfVxuICAgIHByZXZpb3VzT3JkZXIgPSBvcmRlcmVkID8gcHJldmlvdXNPcmRlciA6IG9yZGVyO1xuICAgIHZpc2libGVUYXNrcyA9IG9yZGVyZWQgPyB0YXNrc09yZGVyZWQgOiB0YXNrcztcbn1cbmxldCBsYXlvdXRDaGFuZ2VkID0ge307XG5sZXQgcmVmcmVzaExheW91dCA9IHt9O1xuLyoqIGFwcGx5IGxheW91dHMgKi9cbiQ6IHtcbiAgICByZWZyZXNoTGF5b3V0O1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgdGFza1N0b3JlOiAkdGFza1N0b3JlLFxuICAgICAgICByb3dTdG9yZTogJHJvd1N0b3JlLFxuICAgICAgICByb3dUYXNrczogJHJvd1Rhc2tDYWNoZSxcbiAgICAgICAgcm93SGVpZ2h0LFxuICAgICAgICByb3dQYWRkaW5nLFxuICAgICAgICByb3dSZWZsZWN0ZWRUYXNrczogX3JlZmxlY3RlZFRhc2tzQ2FjaGUsXG4gICAgICAgIGludmFsaWRhdGVkUm93cyxcbiAgICAgICAgaW52YWxpZGF0ZWRUYXNrcyxcbiAgICAgICAgaW52YWxpZGF0ZUZ1bGwsXG4gICAgfTtcbiAgICBpZiAobGF5b3V0ID09PSAnb3ZlcmxhcCcpIHtcbiAgICAgICAgbGF5b3V0cy5vdmVybGFwKHBhcmFtcyk7XG4gICAgfVxuICAgIGlmIChsYXlvdXQgPT09ICdwYWNrJykge1xuICAgICAgICBsYXlvdXRzLnBhY2socGFyYW1zKTtcbiAgICB9XG4gICAgaWYgKGxheW91dCA9PT0gJ2V4cGFuZCcpIHtcbiAgICAgICAgbGF5b3V0cy5leHBhbmQocGFyYW1zKTtcbiAgICB9XG4gICAgbGF5b3V0Q2hhbmdlZCA9IHt9O1xuICAgIGludmFsaWRhdGVGdWxsID0gZmFsc2U7XG4gICAgaW52YWxpZGF0ZWRUYXNrcyA9IHt9O1xuICAgIGludmFsaWRhdGVkUm93cyA9IHt9O1xufVxuJDoge1xuICAgIGxheW91dDtcbiAgICB0YXNrcztcbiAgICByb3dzO1xuICAgIHVwZGF0ZUxheW91dCgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUxheW91dFN5bmMoX2ludmFsaWRhdGVGdWxsKSB7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICB0YXNrU3RvcmU6ICR0YXNrU3RvcmUsXG4gICAgICAgIHJvd1N0b3JlOiAkcm93U3RvcmUsXG4gICAgICAgIHJvd1Rhc2tzOiAkcm93VGFza0NhY2hlLFxuICAgICAgICByb3dIZWlnaHQsXG4gICAgICAgIHJvd1BhZGRpbmcsXG4gICAgICAgIHJvd1JlZmxlY3RlZFRhc2tzOiBfcmVmbGVjdGVkVGFza3NDYWNoZSxcbiAgICAgICAgaW52YWxpZGF0ZWRSb3dzLFxuICAgICAgICBpbnZhbGlkYXRlZFRhc2tzLFxuICAgICAgICBpbnZhbGlkYXRlRnVsbDogX2ludmFsaWRhdGVGdWxsID8/IGludmFsaWRhdGVGdWxsLFxuICAgIH07XG4gICAgaWYgKGxheW91dCA9PT0gJ292ZXJsYXAnKSB7XG4gICAgICAgIGxheW91dHMub3ZlcmxhcChwYXJhbXMpO1xuICAgIH1cbiAgICBpZiAobGF5b3V0ID09PSAncGFjaycpIHtcbiAgICAgICAgbGF5b3V0cy5wYWNrKHBhcmFtcyk7XG4gICAgfVxuICAgIGlmIChsYXlvdXQgPT09ICdleHBhbmQnKSB7XG4gICAgICAgIGxheW91dHMuZXhwYW5kKHBhcmFtcyk7XG4gICAgfVxuICAgIGxheW91dENoYW5nZWQgPSB7fTtcbiAgICBpbnZhbGlkYXRlRnVsbCA9IGZhbHNlO1xuICAgIGludmFsaWRhdGVkVGFza3MgPSB7fTtcbiAgICBpbnZhbGlkYXRlZFJvd3MgPSB7fTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVMYXlvdXQoKSB7XG4gICAgcmVmcmVzaExheW91dCA9IHt9O1xuICAgIGludmFsaWRhdGVGdWxsID0gdHJ1ZTtcbn1cbi8qKiBlbmFibGUgY3JlYXRlIHRhc2sgYnkgZHJhZ2dpbmcgKi9cbmV4cG9ydCBsZXQgZW5hYmxlQ3JlYXRlVGFzayA9IGZhbHNlO1xuZXhwb3J0IGxldCBvbkNyZWF0ZVRhc2sgPSAoZSkgPT4ge1xuICAgIGNvbnN0IGlkID0gYGNyZWF0aW5nLXRhc2stJHsoTWF0aC5yYW5kb20oKSArIDEpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgNyl9YDtcbiAgICByZXR1cm4gKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGxhYmVsOiAnICcsXG4gICAgICAgIC4uLmUsXG4gICAgfSk7XG59O1xuZXhwb3J0IGxldCBvbkNyZWF0ZWRUYXNrID0gKHRhc2spID0+IHsgfTtcbmxldCBkcmFnZ2luZ1Rhc2tzID0ge307XG5sZXQgX2NyZWF0aW5nVGFzayA9IG51bGw7XG5mdW5jdGlvbiBvbkNyZWF0ZVRhc2tNb3ZlKHsgZnJvbSwgdG8sIHgsIHdpZHRoLCB5IH0pIHtcbiAgICBpZiAoIV9jcmVhdGluZ1Rhc2spIHtcbiAgICAgICAgLy8gVE9ETzo6IGluY29ycmVjdCBmb3IgY29sbGFwc2libGUgcm93cywgaWYgY3JlYXRpbmcgdW5kZXIgb25lXG4gICAgICAgIGNvbnN0IHJvdyA9ICRhbGxSb3dzLmZpbmQocm93ID0+IHJvdy55IDwgeSAmJiB5IDwgcm93LnkgKyByb3cuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgcmVzb3VyY2VJZCA9IHJvdy5tb2RlbC5pZDtcbiAgICAgICAgX2NyZWF0aW5nVGFzayA9IGNyZWF0ZVRhc2sob25DcmVhdGVUYXNrKHtcbiAgICAgICAgICAgIHJlc291cmNlSWQsXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGFza1N0b3JlLnVwc2VydChfY3JlYXRpbmdUYXNrKTtcbiAgICAgICAgZHJhZ2dpbmdUYXNrc1tfY3JlYXRpbmdUYXNrLm1vZGVsLmlkXSA9IHtcbiAgICAgICAgICAgIHg6IF9jcmVhdGluZ1Rhc2subGVmdCxcbiAgICAgICAgICAgIHk6IF9jcmVhdGluZ1Rhc2sudG9wLFxuICAgICAgICAgICAgd2lkdGg6IF9jcmVhdGluZ1Rhc2sud2lkdGgsXG4gICAgICAgICAgICByZXNpemluZzogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZHJhZ2dpbmdUYXNrc1tfY3JlYXRpbmdUYXNrLm1vZGVsLmlkXS54ID0geDtcbiAgICBkcmFnZ2luZ1Rhc2tzW19jcmVhdGluZ1Rhc2subW9kZWwuaWRdLndpZHRoID0gd2lkdGg7XG59XG5mdW5jdGlvbiBvbkNyZWF0ZVRhc2tFbmQoeyBmcm9tLCB0bywgeCwgd2lkdGggfSkge1xuICAgIF9jcmVhdGluZ1Rhc2subW9kZWwuZnJvbSA9IGZyb207XG4gICAgX2NyZWF0aW5nVGFzay5tb2RlbC50byA9IHRvO1xuICAgIF9jcmVhdGluZ1Rhc2subGVmdCA9IHg7XG4gICAgX2NyZWF0aW5nVGFzay53aWR0aCA9IHdpZHRoO1xuICAgIHRhc2tTdG9yZS51cHNlcnQoX2NyZWF0aW5nVGFzayk7XG4gICAgZGVsZXRlIGRyYWdnaW5nVGFza3NbX2NyZWF0aW5nVGFzay5tb2RlbC5pZF07XG4gICAgb25DcmVhdGVkVGFzayhfY3JlYXRpbmdUYXNrKTtcbiAgICBfY3JlYXRpbmdUYXNrID0gbnVsbDtcbn1cbmNvbnN0IGRyYWdDcmVhdGVUYXNrcyA9IHVzZUNyZWF0ZVRhc2soKTtcbmZ1bmN0aW9uIG9uQ2hhbmdlKGUpIHtcbiAgICBpZiAoZS5kZXRhaWwuY2hhbmdlcy5zb21lKGMgPT4gIWMudGFyZ2V0Um93KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGUuZGV0YWlsLmNoYW5nZXMpIHtcbiAgICAgICAgY29uc3QgeyB0YXNrLCBjdXJyZW50LCBwcmV2aW91cywgc291cmNlUm93LCB0YXJnZXRSb3cgfSA9IGNoYW5nZTtcbiAgICAgICAgaWYgKCF0YXJnZXRSb3cpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGFzay5tb2RlbDtcbiAgICAgICAgaWYgKHRhcmdldFJvdykge1xuICAgICAgICAgICAgYXBpLnRhc2tzLnJhaXNlLnN3aXRjaFJvdyh0YXNrLCB0YXJnZXRSb3csIHNvdXJjZVJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhbmdlZCA9IHByZXZpb3VzLmZyb20gIT0gY3VycmVudC5mcm9tIHx8IHByZXZpb3VzLnRvICE9IGN1cnJlbnQudG8gfHwgKHNvdXJjZVJvdyAmJiBzb3VyY2VSb3cubW9kZWwuaWQgIT09IHRhcmdldFJvdy5tb2RlbC5pZCk7XG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICBtb2RlbC5mcm9tID0gY3VycmVudC5mcm9tO1xuICAgICAgICAgICAgbW9kZWwudG8gPSBjdXJyZW50LnRvO1xuICAgICAgICAgICAgbW9kZWwucmVzb3VyY2VJZCA9IHRhcmdldFJvdy5tb2RlbC5pZDtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Rhc2sgPSB7XG4gICAgICAgICAgICAgICAgLi4udGFzayxcbiAgICAgICAgICAgICAgICBsZWZ0OiBjdXJyZW50LmxlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiBjdXJyZW50LnRvcCxcbiAgICAgICAgICAgICAgICB3aWR0aDogY3VycmVudC53aWR0aCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhcGkudGFza3MucmFpc2UuY2hhbmdlKHsgdGFzazogbmV3VGFzaywgc291cmNlUm93LCB0YXJnZXRSb3csIHByZXZpb3VzU3RhdGU6IHByZXZpb3VzIH0pO1xuICAgICAgICAgICAgYXBpLnRhc2tzLnJhaXNlLmNoYW5nZWQoeyB0YXNrOiBuZXdUYXNrLCBzb3VyY2VSb3csIHRhcmdldFJvdywgcHJldmlvdXNTdGF0ZTogcHJldmlvdXMgfSk7XG4gICAgICAgICAgICB0YXNrU3RvcmUudXBkYXRlKG5ld1Rhc2spO1xuICAgICAgICAgICAgaW52YWxpZGF0ZVBvc2l0aW9uKHsgcm93OiBzb3VyY2VSb3cgfSk7XG4gICAgICAgICAgICBpbnZhbGlkYXRlUG9zaXRpb24oeyB0YXNrOiBuZXdUYXNrIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gb25JdGVtc0NoYW5nZShlKSB7XG4gICAgZHJhZ2dpbmdUYXNrcyA9IHsgLi4uZS5kZXRhaWwuaXRlbXMgfTtcbn1cbjwvc2NyaXB0PlxuXG48IS0tIHN2ZWx0ZS1pZ25vcmUgYTExeS1jbGljay1ldmVudHMtaGF2ZS1rZXktZXZlbnRzIC0tPlxuPCEtLSBzdmVsdGUtaWdub3JlIGExMXktbW91c2UtZXZlbnRzLWhhdmUta2V5LWV2ZW50cyAtLT5cbjwhLS0gc3ZlbHRlLWlnbm9yZSBhMTF5LW5vLXN0YXRpYy1lbGVtZW50LWludGVyYWN0aW9ucyAtLT5cbjxkaXZcbiAgICBjbGFzcz1cInNnLWdhbnR0IHtjbGFzc2VzfVwiXG4gICAgY2xhc3M6c2ctZGlzYWJsZS10cmFuc2l0aW9uPXtkaXNhYmxlVHJhbnNpdGlvbn1cbiAgICBiaW5kOnRoaXM9e2dhbnR0RWxlbWVudH1cbiAgICBvbjpwb2ludGVyZG93bnxzdG9wUHJvcGFnYXRpb249e29uRXZlbnR9XG4gICAgb246Y2xpY2t8c3RvcFByb3BhZ2F0aW9uPXtvbkV2ZW50fVxuICAgIG9uOmRibGNsaWNrPXtvbkV2ZW50fVxuICAgIG9uOnBvaW50ZXJvdmVyPXtvbkV2ZW50fVxuICAgIG9uOnBvaW50ZXJsZWF2ZT17b25FdmVudH1cbj5cbiAgICB7I2VhY2ggZ2FudHRUYWJsZU1vZHVsZXMgYXMgbW9kdWxlfVxuICAgICAgICA8c3ZlbHRlOmNvbXBvbmVudFxuICAgICAgICAgICAgdGhpcz17bW9kdWxlfVxuICAgICAgICAgICAge3Jvd0NvbnRhaW5lckhlaWdodH1cbiAgICAgICAgICAgIHtwYWRkaW5nVG9wfVxuICAgICAgICAgICAge3RhYmxlV2lkdGh9XG4gICAgICAgICAgICB7Li4uJCRyZXN0UHJvcHN9XG4gICAgICAgICAgICB7dmlzaWJsZVJvd3N9XG4gICAgICAgIC8+XG5cbiAgICAgICAgPFJlc2l6ZXIgeD17dGFibGVXaWR0aH0gb246cmVzaXplPXtvblJlc2l6ZX0gY29udGFpbmVyPXtnYW50dEVsZW1lbnR9PjwvUmVzaXplcj5cbiAgICB7L2VhY2h9XG5cbiAgICA8ZGl2IGNsYXNzPVwic2ctdGltZWxpbmUgc2ctdmlld1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwic2ctaGVhZGVyXCIgYmluZDp0aGlzPXttYWluSGVhZGVyQ29udGFpbmVyfSBiaW5kOmNsaWVudEhlaWdodD17JGhlYWRlckhlaWdodH0gc3R5bGU9e2BwYWRkaW5nLXJpZ2h0OiAkeyRyaWdodFNjcm9sbGJhclZpc2libGV9cHg7YH0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwic2ctaGVhZGVyLXNjcm9sbGVyXCIgdXNlOmhvcml6b250YWxTY3JvbGxMaXN0ZW5lcj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaGVhZGVyLWNvbnRhaW5lclwiIHN0eWxlPVwid2lkdGg6eyRfd2lkdGh9cHhcIj5cbiAgICAgICAgICAgICAgICAgICAgPENvbHVtbkhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAge2hlYWRlcnN9XG4gICAgICAgICAgICAgICAgICAgICAgICBnYW50dEJvZHlDb2x1bW5zPXtjb2x1bW5zfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FudHRCb2R5VW5pdD17Y29sdW1uVW5pdH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOmRhdGVTZWxlY3RlZD17b25EYXRlU2VsZWN0ZWR9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIHsjZWFjaCAkYWxsVGltZVJhbmdlcyBhcyB0aW1lUmFuZ2UgKHRpbWVSYW5nZS5tb2RlbC5pZCl9XG4gICAgICAgICAgICAgICAgICAgICAgICA8VGltZVJhbmdlSGVhZGVyIHsuLi50aW1lUmFuZ2V9IC8+XG4gICAgICAgICAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzcz1cInNnLXRpbWVsaW5lLWJvZHlcIlxuICAgICAgICAgICAgYmluZDp0aGlzPXttYWluQ29udGFpbmVyfVxuICAgICAgICAgICAgdXNlOnNjcm9sbGFibGVcbiAgICAgICAgICAgIGNsYXNzOnpvb21pbmdcbiAgICAgICAgICAgIG9uOndoZWVsPXtvbndoZWVsfVxuICAgICAgICAgICAgYmluZDpjbGllbnRIZWlnaHQ9eyR2aXNpYmxlSGVpZ2h0fVxuICAgICAgICAgICAgYmluZDpvZmZzZXRIZWlnaHQ9e29mZnNldEhlaWdodH1cbiAgICAgICAgICAgIGJpbmQ6Y2xpZW50V2lkdGg9eyR2aXNpYmxlV2lkdGh9XG4gICAgICAgICAgICBiaW5kOm9mZnNldFdpZHRoPXtvZmZzZXRXaWR0aH1cbiAgICAgICAgICAgIHVzZTpkcmFnQ3JlYXRlVGFza3M9e3sgY29udGFpbmVyOiByb3dDb250YWluZXIsIGVuYWJsZWQ6IGVuYWJsZUNyZWF0ZVRhc2ssIG9uTW92ZTogb25DcmVhdGVUYXNrTW92ZSwgb25FbmQ6IG9uQ3JlYXRlVGFza0VuZCwgYm91bmRzQ29udGFpbmVyOiBtYWluQ29udGFpbmVyIH19XG4gICAgICAgID5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50XCIgc3R5bGU9XCJ3aWR0aDp7JF93aWR0aH1weFwiPlxuICAgICAgICAgICAgICAgIDxDb2x1bW5zIHtjb2x1bW5zfSB7Y29sdW1uU3Ryb2tlQ29sb3J9IHtjb2x1bW5TdHJva2VXaWR0aH0ge3VzZUNhbnZhc0NvbHVtbnN9IC8+XG5cbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwic2ctcm93c1wiXG4gICAgICAgICAgICAgICAgICAgIGJpbmQ6dGhpcz17cm93Q29udGFpbmVyfVxuICAgICAgICAgICAgICAgICAgICBzdHlsZT1cImhlaWdodDp7cm93Q29udGFpbmVySGVpZ2h0fXB4O1wiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPVwidHJhbnNmb3JtOiB0cmFuc2xhdGVZKHtwYWRkaW5nVG9wfXB4KTtcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsjZWFjaCB2aXNpYmxlUm93cyBhcyByb3cgKHJvdy5tb2RlbC5pZCl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFJvdyB7cm93fSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZy1mb3JlZ3JvdW5kXCI+XG4gICAgICAgICAgICAgICAgICAgIHsjZWFjaCAkYWxsVGltZVJhbmdlcyBhcyB0aW1lUmFuZ2UgKHRpbWVSYW5nZS5tb2RlbC5pZCl9XG4gICAgICAgICAgICAgICAgICAgICAgICA8VGltZVJhbmdlIHsuLi50aW1lUmFuZ2V9IC8+XG4gICAgICAgICAgICAgICAgICAgIHsvZWFjaH1cblxuICAgICAgICAgICAgICAgICAgICA8RHJhZ2dhYmxlR3JvdXAgaXRlbXM9e2RyYWdnaW5nVGFza3N9IG9uOmNoYW5nZT17b25DaGFuZ2V9IG9uOml0ZW1zQ2hhbmdlPXtvbkl0ZW1zQ2hhbmdlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsjZWFjaCB2aXNpYmxlVGFza3MgYXMgdGFzayAodGFzay5tb2RlbC5pZCl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPERyYWdnYWJsZSB7dGFza30gbGV0OnN0YXRlIGxldDpvblBvaW50ZXJEb3duPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8VGFza1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgey4uLnRhc2t9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbD17dGFzay5tb2RlbH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ9e3N0YXRlLnh9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A9e3N0YXRlLnl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD17c3RhdGUud2lkdGh9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ9e3Rhc2suaGVpZ2h0fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ2dpbmc9e3N0YXRlLmRyYWdnaW5nfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXppbmc9e3N0YXRlLnJlc2l6aW5nfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246cG9pbnRlcmRvd249e29uUG9pbnRlckRvd259XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9EcmFnZ2FibGU+XG4gICAgICAgICAgICAgICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgICAgICAgICAgIDwvRHJhZ2dhYmxlR3JvdXA+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgeyNlYWNoIGdhbnR0Qm9keU1vZHVsZXMgYXMgbW9kdWxlfVxuICAgICAgICAgICAgICAgICAgICA8c3ZlbHRlOmNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcz17bW9kdWxlfVxuICAgICAgICAgICAgICAgICAgICAgICAge3BhZGRpbmdUb3B9XG4gICAgICAgICAgICAgICAgICAgICAgICB7dmlzaWJsZVJvd3N9XG4gICAgICAgICAgICAgICAgICAgICAgICB7Li4uJCRyZXN0UHJvcHN9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgICA6Z2xvYmFsKC5zZy1nYW50dCkge1xuICAgICAgICAtLXNnLWNvbHVtbi1oZWFkZXItYmctaG92ZXI6ICNmOWY5Zjk7XG4gICAgICAgIC0tc2ctY29sdW1uLWJvcmRlci1jb2xvcjogI2VmZWZlZjtcbiAgICAgICAgLS1zZy1jb2x1bW4taGVhZGVyLWJvcmRlci1jb2xvcjogI2VmZWZlZjtcbiAgICAgICAgLS1zZy10YWJsZS1jZWxsLWJvcmRlci1jb2xvcjogI2VmZWZlZjtcbiAgICAgICAgLS1zZy10YWJsZS1oZWFkZXItY2VsbC1ib3JkZXItY29sb3I6ICNlZmVmZWY7XG4gICAgICAgIC0tc2ctdGFibGUtaGVhZGVyLWNlbGwtYmc6ICNmYmZiZmI7XG4gICAgICAgIC0tc2ctcmVzaXplLWNvbG9yOiAjZTllYWViO1xuICAgICAgICAtLXNnLWRlcGVuZGVuY3ktYXJyb3ctY29sb3I6ICM2NDc0OGI7XG4gICAgICAgIC0tc2ctdGFzay1yZXNpemUtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KTtcbiAgICAgICAgLS1zZy10YXNrLXNlbGVjdGVkLW91dGxpbmUtY29sb3I6IHJnYmEoMywgMTY5LCAyNDQsIDAuNSk7XG4vKiBcbiAgICAgICAgLS1zZy1jb2x1bW4taGVhZGVyLWJnLWhvdmVyOiAjMzMzO1xuICAgICAgICAtLXNnLWNvbHVtbi1ib3JkZXItY29sb3I6ICMzMzM7XG4gICAgICAgIC0tc2ctY29sdW1uLWhlYWRlci1ib3JkZXItY29sb3I6ICMzMzM7XG4gICAgICAgIC0tc2ctdGFibGUtY2VsbC1ib3JkZXItY29sb3I6ICMzMzM7XG4gICAgICAgIC0tc2ctdGFibGUtaGVhZGVyLWNlbGwtYm9yZGVyLWNvbG9yOiAjMzMzO1xuICAgICAgICAtLXNnLXRhYmxlLWhlYWRlci1jZWxsLWJnOiAjMzMzO1xuICAgICAgICAtLXNnLXJlc2l6ZS1jb2xvcjogIzMzMztcbiAgICAgICAgLS1zZy1kZXBlbmRlbmN5LWFycm93LWNvbG9yOiByZWQ7XG4gICAgICAgIC0tc2ctdGFzay1yZXNpemUtY29sb3I6ICNjY2M7ICovXG4gICAgfVxuXG4gICAgLnNnLWRpc2FibGUtdHJhbnNpdGlvbiA6Z2xvYmFsKC5zZy10YXNrKSxcbiAgICAuc2ctZGlzYWJsZS10cmFuc2l0aW9uIDpnbG9iYWwoLnNnLW1pbGVzdG9uZSkge1xuICAgICAgICB0cmFuc2l0aW9uOlxuICAgICAgICAgICAgdHJhbnNmb3JtIDBzLFxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvciAwLjJzLFxuICAgICAgICAgICAgd2lkdGggMHMgIWltcG9ydGFudDtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5zZy12aWV3Om5vdCg6Zmlyc3QtY2hpbGQpKSB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiA1cHg7XG4gICAgfVxuXG4gICAgLnNnLXRpbWVsaW5lIHtcbiAgICAgICAgZmxleDogMSAxIDAlO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICBvdmVyZmxvdy14OiBhdXRvO1xuICAgIH1cblxuICAgIC5zZy1nYW50dCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG5cbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIH1cblxuICAgIC5zZy1mb3JlZ3JvdW5kIHtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIHotaW5kZXg6IDE7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIH1cblxuICAgIC5zZy1yb3dzIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgfVxuXG4gICAgLnNnLXRpbWVsaW5lLWJvZHkge1xuICAgICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgICAgZmxleDogMSAxIGF1dG87XG4gICAgfVxuXG4gICAgLnNnLWhlYWRlci1zY3JvbGxlciB7XG4gICAgICAgIC8qIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNlZmVmZWY7IC8vIHJlcGxhY2Ugd2l0aCBlbGVtZW50LCBvciBjb25kaXRpb25hbGx5IGRyYXcgdGhpcyBib3JkZXIgKi9cbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIH1cblxuICAgIC5jb250ZW50IHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIH1cblxuICAgIDpnbG9iYWwoKikge1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBbTlCWSxTQUFXLENBQ2YsMkJBQTJCLENBQUUsT0FBTyxDQUNwQyx3QkFBd0IsQ0FBRSxPQUFPLENBQ2pDLCtCQUErQixDQUFFLE9BQU8sQ0FDeEMsNEJBQTRCLENBQUUsT0FBTyxDQUNyQyxtQ0FBbUMsQ0FBRSxPQUFPLENBQzVDLHlCQUF5QixDQUFFLE9BQU8sQ0FDbEMsaUJBQWlCLENBQUUsT0FBTyxDQUMxQiwyQkFBMkIsQ0FBRSxPQUFPLENBQ3BDLHNCQUFzQixDQUFFLHdCQUF3QixDQUNoRCxnQ0FBZ0MsQ0FBRSxzQkFXdEMsQ0FFQSxtQ0FBc0IsQ0FBUyxRQUFTLENBQ3hDLG1DQUFzQixDQUFTLGFBQWUsQ0FDMUMsVUFBVSxDQUNOLFNBQVMsQ0FBQyxFQUFFO0FBQ3hCLFlBQVksZ0JBQWdCLENBQUMsSUFBSTtBQUNqQyxZQUFZLEtBQUssQ0FBQyxFQUFFLENBQUMsVUFDakIsQ0FFUSwwQkFBNEIsQ0FDaEMsV0FBVyxDQUFFLEdBQ2pCLENBRUEseUJBQWEsQ0FDVCxJQUFJLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQ1osT0FBTyxDQUFFLElBQUksQ0FDYixjQUFjLENBQUUsTUFBTSxDQUN0QixVQUFVLENBQUUsSUFDaEIsQ0FFQSxzQkFBVSxDQUNOLE9BQU8sQ0FBRSxJQUFJLENBRWIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLFFBQVEsQ0FBRSxRQUNkLENBRUEsMkJBQWUsQ0FDWCxVQUFVLENBQUUsVUFBVSxDQUN0QixRQUFRLENBQUUsTUFBTSxDQUNoQixHQUFHLENBQUUsQ0FBQyxDQUNOLElBQUksQ0FBRSxDQUFDLENBQ1AsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLE9BQU8sQ0FBRSxDQUFDLENBQ1YsY0FBYyxDQUFFLElBQ3BCLENBRUEscUJBQVMsQ0FDTCxLQUFLLENBQUUsSUFBSSxDQUNYLFVBQVUsQ0FBRSxVQUFVLENBQ3RCLFFBQVEsQ0FBRSxNQUNkLENBRUEsOEJBQWtCLENBQ2QsUUFBUSxDQUFFLElBQUksQ0FDZCxJQUFJLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUNkLENBRUEsZ0NBQW9CLENBRWhCLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLFFBQVEsQ0FBRSxRQUNkLENBRUEscUJBQVMsQ0FDTCxRQUFRLENBQUUsUUFDZCxDQUVRLENBQUcsQ0FDUCxVQUFVLENBQUUsVUFDaEIifQ== */");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[164] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[167] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[172] = list[i];
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[175] = list[i];
  return child_ctx;
}
function get_each_context_4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[172] = list[i];
  return child_ctx;
}
function get_each_context_5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[164] = list[i];
  return child_ctx;
}
function create_each_block_5(ctx) {
  let switch_instance;
  let t;
  let resizer;
  let current;
  const switch_instance_spread_levels = [
    {
      rowContainerHeight: (
        /*rowContainerHeight*/
        ctx[12]
      )
    },
    { paddingTop: (
      /*paddingTop*/
      ctx[25]
    ) },
    { tableWidth: (
      /*tableWidth*/
      ctx[2]
    ) },
    /*$$restProps*/
    ctx[62],
    { visibleRows: (
      /*visibleRows*/
      ctx[13]
    ) }
  ];
  var switch_value = (
    /*module*/
    ctx[164]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    if (dirty !== void 0 && dirty[0] & /*rowContainerHeight, paddingTop, tableWidth, visibleRows*/
    33566724 | dirty[2] & /*$$restProps*/
    1) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
        dirty[0] & /*rowContainerHeight*/
        4096 && {
          rowContainerHeight: (
            /*rowContainerHeight*/
            ctx2[12]
          )
        },
        dirty[0] & /*paddingTop*/
        33554432 && { paddingTop: (
          /*paddingTop*/
          ctx2[25]
        ) },
        dirty[0] & /*tableWidth*/
        4 && { tableWidth: (
          /*tableWidth*/
          ctx2[2]
        ) },
        dirty[2] & /*$$restProps*/
        1 && get_spread_object(
          /*$$restProps*/
          ctx2[62]
        ),
        dirty[0] & /*visibleRows*/
        8192 && { visibleRows: (
          /*visibleRows*/
          ctx2[13]
        ) }
      ]));
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  resizer = new Resizer_default({
    props: {
      x: (
        /*tableWidth*/
        ctx[2]
      ),
      container: (
        /*ganttElement*/
        ctx[18]
      )
    },
    $$inline: true
  });
  resizer.$on(
    "resize",
    /*onResize*/
    ctx[54]
  );
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      t = space();
      create_component(resizer.$$.fragment);
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_dev(target, t, anchor);
      mount_component(resizer, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*ganttTableModules*/
      16 && switch_value !== (switch_value = /*module*/
      ctx2[164])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, t.parentNode, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*rowContainerHeight, paddingTop, tableWidth, visibleRows*/
        33566724 | dirty[2] & /*$$restProps*/
        1 ? get_spread_update(switch_instance_spread_levels, [
          dirty[0] & /*rowContainerHeight*/
          4096 && {
            rowContainerHeight: (
              /*rowContainerHeight*/
              ctx2[12]
            )
          },
          dirty[0] & /*paddingTop*/
          33554432 && { paddingTop: (
            /*paddingTop*/
            ctx2[25]
          ) },
          dirty[0] & /*tableWidth*/
          4 && { tableWidth: (
            /*tableWidth*/
            ctx2[2]
          ) },
          dirty[2] & /*$$restProps*/
          1 && get_spread_object(
            /*$$restProps*/
            ctx2[62]
          ),
          dirty[0] & /*visibleRows*/
          8192 && { visibleRows: (
            /*visibleRows*/
            ctx2[13]
          ) }
        ]) : {};
        switch_instance.$set(switch_instance_changes);
      }
      const resizer_changes = {};
      if (dirty[0] & /*tableWidth*/
      4) resizer_changes.x = /*tableWidth*/
      ctx2[2];
      if (dirty[0] & /*ganttElement*/
      262144) resizer_changes.container = /*ganttElement*/
      ctx2[18];
      resizer.$set(resizer_changes);
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      transition_in(resizer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      transition_out(resizer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
      destroy_component(resizer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_5.name,
    type: "each",
    source: "(886:4) {#each ganttTableModules as module}",
    ctx
  });
  return block;
}
function create_each_block_4(key_1, ctx) {
  let first;
  let timerangeheader;
  let current;
  const timerangeheader_spread_levels = [
    /*timeRange*/
    ctx[172]
  ];
  let timerangeheader_props = {};
  for (let i = 0; i < timerangeheader_spread_levels.length; i += 1) {
    timerangeheader_props = assign(timerangeheader_props, timerangeheader_spread_levels[i]);
  }
  timerangeheader = new TimeRangeHeader_default({
    props: timerangeheader_props,
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(timerangeheader.$$.fragment);
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(timerangeheader, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const timerangeheader_changes = dirty[0] & /*$allTimeRanges*/
      536870912 ? get_spread_update(timerangeheader_spread_levels, [get_spread_object(
        /*timeRange*/
        ctx[172]
      )]) : {};
      timerangeheader.$set(timerangeheader_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(timerangeheader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(timerangeheader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(timerangeheader, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_4.name,
    type: "each",
    source: "(909:20) {#each $allTimeRanges as timeRange (timeRange.model.id)}",
    ctx
  });
  return block;
}
function create_each_block_3(key_1, ctx) {
  let first;
  let row_1;
  let current;
  row_1 = new Row_default({
    props: { row: (
      /*row*/
      ctx[175]
    ) },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(row_1.$$.fragment);
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(row_1, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const row_1_changes = {};
      if (dirty[0] & /*visibleRows*/
      8192) row_1_changes.row = /*row*/
      ctx[175];
      row_1.$set(row_1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(row_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(row_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(row_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_3.name,
    type: "each",
    source: "(937:24) {#each visibleRows as row (row.model.id)}",
    ctx
  });
  return block;
}
function create_each_block_2(key_1, ctx) {
  let first;
  let timerange;
  let current;
  const timerange_spread_levels = [
    /*timeRange*/
    ctx[172]
  ];
  let timerange_props = {};
  for (let i = 0; i < timerange_spread_levels.length; i += 1) {
    timerange_props = assign(timerange_props, timerange_spread_levels[i]);
  }
  timerange = new TimeRange_default({ props: timerange_props, $$inline: true });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(timerange.$$.fragment);
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(timerange, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const timerange_changes = dirty[0] & /*$allTimeRanges*/
      536870912 ? get_spread_update(timerange_spread_levels, [get_spread_object(
        /*timeRange*/
        ctx[172]
      )]) : {};
      timerange.$set(timerange_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(timerange.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(timerange.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(timerange, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(944:20) {#each $allTimeRanges as timeRange (timeRange.model.id)}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let task_1;
  let t;
  let current;
  const task_1_spread_levels = [
    /*task*/
    ctx[167],
    { model: (
      /*task*/
      ctx[167].model
    ) },
    { left: (
      /*state*/
      ctx[170].x
    ) },
    { top: (
      /*state*/
      ctx[170].y
    ) },
    { width: (
      /*state*/
      ctx[170].width
    ) },
    { height: (
      /*task*/
      ctx[167].height
    ) },
    { dragging: (
      /*state*/
      ctx[170].dragging
    ) },
    { resizing: (
      /*state*/
      ctx[170].resizing
    ) }
  ];
  let task_1_props = {};
  for (let i = 0; i < task_1_spread_levels.length; i += 1) {
    task_1_props = assign(task_1_props, task_1_spread_levels[i]);
  }
  task_1 = new Task_default({ props: task_1_props, $$inline: true });
  task_1.$on("pointerdown", function() {
    if (is_function(
      /*onPointerDown*/
      ctx[171]
    )) ctx[171].apply(this, arguments);
  });
  const block = {
    c: function create() {
      create_component(task_1.$$.fragment);
      t = space();
    },
    m: function mount(target, anchor) {
      mount_component(task_1, target, anchor);
      insert_dev(target, t, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const task_1_changes = dirty[0] & /*visibleTasks*/
      67108864 | dirty[5] & /*state*/
      32768 ? get_spread_update(task_1_spread_levels, [
        dirty[0] & /*visibleTasks*/
        67108864 && get_spread_object(
          /*task*/
          ctx[167]
        ),
        dirty[0] & /*visibleTasks*/
        67108864 && { model: (
          /*task*/
          ctx[167].model
        ) },
        dirty[5] & /*state*/
        32768 && { left: (
          /*state*/
          ctx[170].x
        ) },
        dirty[5] & /*state*/
        32768 && { top: (
          /*state*/
          ctx[170].y
        ) },
        dirty[5] & /*state*/
        32768 && { width: (
          /*state*/
          ctx[170].width
        ) },
        dirty[0] & /*visibleTasks*/
        67108864 && { height: (
          /*task*/
          ctx[167].height
        ) },
        dirty[5] & /*state*/
        32768 && { dragging: (
          /*state*/
          ctx[170].dragging
        ) },
        dirty[5] & /*state*/
        32768 && { resizing: (
          /*state*/
          ctx[170].resizing
        ) }
      ]) : {};
      task_1.$set(task_1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(task_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(task_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(task_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(950:28) <Draggable {task} let:state let:onPointerDown>",
    ctx
  });
  return block;
}
function create_each_block_1(key_1, ctx) {
  let first;
  let draggable;
  let current;
  draggable = new Draggable_default({
    props: {
      task: (
        /*task*/
        ctx[167]
      ),
      $$slots: {
        default: [
          create_default_slot_1,
          ({ state, onPointerDown }) => ({ 170: state, 171: onPointerDown }),
          ({ state, onPointerDown }) => [0, 0, 0, 0, 0, (state ? 32768 : 0) | (onPointerDown ? 65536 : 0)]
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(draggable.$$.fragment);
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(draggable, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const draggable_changes = {};
      if (dirty[0] & /*visibleTasks*/
      67108864) draggable_changes.task = /*task*/
      ctx[167];
      if (dirty[0] & /*visibleTasks*/
      67108864 | dirty[5] & /*$$scope, state, onPointerDown*/
      134316032) {
        draggable_changes.$$scope = { dirty, ctx };
      }
      draggable.$set(draggable_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(draggable.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(draggable.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(draggable, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(949:24) {#each visibleTasks as task (task.model.id)}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like_dev(
    /*visibleTasks*/
    ctx[26]
  );
  const get_key = (ctx2) => (
    /*task*/
    ctx2[167].model.id
  );
  validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*visibleTasks*/
      67108864 | dirty[5] & /*state, onPointerDown*/
      98304) {
        each_value_1 = ensure_array_like_dev(
          /*visibleTasks*/
          ctx2[26]
        );
        group_outros();
        validate_each_keys(ctx2, each_value_1, get_each_context_1, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_1, each_1_anchor, get_each_context_1);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(948:20) <DraggableGroup items={draggingTasks} on:change={onChange} on:itemsChange={onItemsChange}>",
    ctx
  });
  return block;
}
function create_each_block4(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    { paddingTop: (
      /*paddingTop*/
      ctx[25]
    ) },
    { visibleRows: (
      /*visibleRows*/
      ctx[13]
    ) },
    /*$$restProps*/
    ctx[62]
  ];
  var switch_value = (
    /*module*/
    ctx[164]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    if (dirty !== void 0 && dirty[0] & /*paddingTop, visibleRows*/
    33562624 | dirty[2] & /*$$restProps*/
    1) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
        dirty[0] & /*paddingTop*/
        33554432 && { paddingTop: (
          /*paddingTop*/
          ctx2[25]
        ) },
        dirty[0] & /*visibleRows*/
        8192 && { visibleRows: (
          /*visibleRows*/
          ctx2[13]
        ) },
        dirty[2] & /*$$restProps*/
        1 && get_spread_object(
          /*$$restProps*/
          ctx2[62]
        )
      ]));
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*ganttBodyModules*/
      32 && switch_value !== (switch_value = /*module*/
      ctx2[164])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*paddingTop, visibleRows*/
        33562624 | dirty[2] & /*$$restProps*/
        1 ? get_spread_update(switch_instance_spread_levels, [
          dirty[0] & /*paddingTop*/
          33554432 && { paddingTop: (
            /*paddingTop*/
            ctx2[25]
          ) },
          dirty[0] & /*visibleRows*/
          8192 && { visibleRows: (
            /*visibleRows*/
            ctx2[13]
          ) },
          dirty[2] & /*$$restProps*/
          1 && get_spread_object(
            /*$$restProps*/
            ctx2[62]
          )
        ]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(966:16) {#each ganttBodyModules as module}",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let div9;
  let t0;
  let div8;
  let div2;
  let div1;
  let div0;
  let columnheader;
  let t1;
  let each_blocks_3 = [];
  let each1_lookup = /* @__PURE__ */ new Map();
  let horizontalScrollListener_action;
  let div2_style_value;
  let div2_resize_listener;
  let t2;
  let div7;
  let div6;
  let columns_1;
  let t3;
  let div4;
  let div3;
  let each_blocks_2 = [];
  let each2_lookup = /* @__PURE__ */ new Map();
  let t4;
  let div5;
  let each_blocks_1 = [];
  let each3_lookup = /* @__PURE__ */ new Map();
  let t5;
  let draggablegroup;
  let t6;
  let scrollable_action;
  let div7_resize_listener;
  let dragCreateTasks_action;
  let div9_class_value;
  let current;
  let mounted;
  let dispose;
  let each_value_5 = ensure_array_like_dev(
    /*ganttTableModules*/
    ctx[4]
  );
  let each_blocks_4 = [];
  for (let i = 0; i < each_value_5.length; i += 1) {
    each_blocks_4[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
  }
  const out = (i) => transition_out(each_blocks_4[i], 1, 1, () => {
    each_blocks_4[i] = null;
  });
  columnheader = new ColumnHeader_default({
    props: {
      headers: (
        /*headers*/
        ctx[1]
      ),
      ganttBodyColumns: (
        /*columns*/
        ctx[23]
      ),
      ganttBodyUnit: (
        /*columnUnit*/
        ctx[0]
      )
    },
    $$inline: true
  });
  columnheader.$on(
    "dateSelected",
    /*onDateSelected*/
    ctx[56]
  );
  let each_value_4 = ensure_array_like_dev(
    /*$allTimeRanges*/
    ctx[29]
  );
  const get_key = (ctx2) => (
    /*timeRange*/
    ctx2[172].model.id
  );
  validate_each_keys(ctx, each_value_4, get_each_context_4, get_key);
  for (let i = 0; i < each_value_4.length; i += 1) {
    let child_ctx = get_each_context_4(ctx, each_value_4, i);
    let key = get_key(child_ctx);
    each1_lookup.set(key, each_blocks_3[i] = create_each_block_4(key, child_ctx));
  }
  columns_1 = new Columns_default({
    props: {
      columns: (
        /*columns*/
        ctx[23]
      ),
      columnStrokeColor: (
        /*columnStrokeColor*/
        ctx[7]
      ),
      columnStrokeWidth: (
        /*columnStrokeWidth*/
        ctx[8]
      ),
      useCanvasColumns: (
        /*useCanvasColumns*/
        ctx[6]
      )
    },
    $$inline: true
  });
  let each_value_3 = ensure_array_like_dev(
    /*visibleRows*/
    ctx[13]
  );
  const get_key_1 = (ctx2) => (
    /*row*/
    ctx2[175].model.id
  );
  validate_each_keys(ctx, each_value_3, get_each_context_3, get_key_1);
  for (let i = 0; i < each_value_3.length; i += 1) {
    let child_ctx = get_each_context_3(ctx, each_value_3, i);
    let key = get_key_1(child_ctx);
    each2_lookup.set(key, each_blocks_2[i] = create_each_block_3(key, child_ctx));
  }
  let each_value_2 = ensure_array_like_dev(
    /*$allTimeRanges*/
    ctx[29]
  );
  const get_key_2 = (ctx2) => (
    /*timeRange*/
    ctx2[172].model.id
  );
  validate_each_keys(ctx, each_value_2, get_each_context_2, get_key_2);
  for (let i = 0; i < each_value_2.length; i += 1) {
    let child_ctx = get_each_context_2(ctx, each_value_2, i);
    let key = get_key_2(child_ctx);
    each3_lookup.set(key, each_blocks_1[i] = create_each_block_2(key, child_ctx));
  }
  draggablegroup = new DraggableGroup_default({
    props: {
      items: (
        /*draggingTasks*/
        ctx[14]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  draggablegroup.$on(
    "change",
    /*onChange*/
    ctx[60]
  );
  draggablegroup.$on(
    "itemsChange",
    /*onItemsChange*/
    ctx[61]
  );
  let each_value = ensure_array_like_dev(
    /*ganttBodyModules*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  const out_1 = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div9 = element("div");
      for (let i = 0; i < each_blocks_4.length; i += 1) {
        each_blocks_4[i].c();
      }
      t0 = space();
      div8 = element("div");
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      create_component(columnheader.$$.fragment);
      t1 = space();
      for (let i = 0; i < each_blocks_3.length; i += 1) {
        each_blocks_3[i].c();
      }
      t2 = space();
      div7 = element("div");
      div6 = element("div");
      create_component(columns_1.$$.fragment);
      t3 = space();
      div4 = element("div");
      div3 = element("div");
      for (let i = 0; i < each_blocks_2.length; i += 1) {
        each_blocks_2[i].c();
      }
      t4 = space();
      div5 = element("div");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t5 = space();
      create_component(draggablegroup.$$.fragment);
      t6 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div0, "class", "header-container");
      set_style(
        div0,
        "width",
        /*$_width*/
        ctx[16] + "px"
      );
      add_location(div0, file8, 901, 16, 28551);
      attr_dev(div1, "class", "sg-header-scroller svelte-4g5bd");
      add_location(div1, file8, 900, 12, 28473);
      attr_dev(div2, "class", "sg-header");
      attr_dev(div2, "style", div2_style_value = `padding-right: ${/*$rightScrollbarVisible*/
      ctx[27]}px;`);
      add_render_callback(() => (
        /*div2_elementresize_handler*/
        ctx[131].call(div2)
      ));
      add_location(div2, file8, 899, 8, 28317);
      set_style(div3, "transform", "translateY(" + /*paddingTop*/
      ctx[25] + "px)");
      add_location(div3, file8, 935, 20, 29970);
      attr_dev(div4, "class", "sg-rows svelte-4g5bd");
      set_style(
        div4,
        "height",
        /*rowContainerHeight*/
        ctx[12] + "px"
      );
      add_location(div4, file8, 930, 16, 29787);
      attr_dev(div5, "class", "sg-foreground svelte-4g5bd");
      add_location(div5, file8, 942, 16, 30230);
      attr_dev(div6, "class", "content svelte-4g5bd");
      set_style(
        div6,
        "width",
        /*$_width*/
        ctx[16] + "px"
      );
      add_location(div6, file8, 927, 12, 29625);
      attr_dev(div7, "class", "sg-timeline-body svelte-4g5bd");
      add_render_callback(() => (
        /*div7_elementresize_handler*/
        ctx[134].call(div7)
      ));
      toggle_class(
        div7,
        "zooming",
        /*zooming*/
        ctx[24]
      );
      add_location(div7, file8, 915, 8, 29088);
      attr_dev(div8, "class", "sg-timeline sg-view svelte-4g5bd");
      add_location(div8, file8, 898, 4, 28275);
      attr_dev(div9, "class", div9_class_value = "sg-gantt " + /*classes*/
      ctx[3] + " svelte-4g5bd");
      toggle_class(
        div9,
        "sg-disable-transition",
        /*disableTransition*/
        ctx[22]
      );
      add_location(div9, file8, 875, 0, 27639);
    },
    l: function claim(nodes) {
      throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div9, anchor);
      for (let i = 0; i < each_blocks_4.length; i += 1) {
        if (each_blocks_4[i]) {
          each_blocks_4[i].m(div9, null);
        }
      }
      append_dev(div9, t0);
      append_dev(div9, div8);
      append_dev(div8, div2);
      append_dev(div2, div1);
      append_dev(div1, div0);
      mount_component(columnheader, div0, null);
      append_dev(div0, t1);
      for (let i = 0; i < each_blocks_3.length; i += 1) {
        if (each_blocks_3[i]) {
          each_blocks_3[i].m(div0, null);
        }
      }
      ctx[130](div2);
      div2_resize_listener = add_iframe_resize_listener(
        div2,
        /*div2_elementresize_handler*/
        ctx[131].bind(div2)
      );
      append_dev(div8, t2);
      append_dev(div8, div7);
      append_dev(div7, div6);
      mount_component(columns_1, div6, null);
      append_dev(div6, t3);
      append_dev(div6, div4);
      append_dev(div4, div3);
      for (let i = 0; i < each_blocks_2.length; i += 1) {
        if (each_blocks_2[i]) {
          each_blocks_2[i].m(div3, null);
        }
      }
      ctx[132](div4);
      append_dev(div6, t4);
      append_dev(div6, div5);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div5, null);
        }
      }
      append_dev(div5, t5);
      mount_component(draggablegroup, div5, null);
      append_dev(div6, t6);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div6, null);
        }
      }
      ctx[133](div7);
      div7_resize_listener = add_iframe_resize_listener(
        div7,
        /*div7_elementresize_handler*/
        ctx[134].bind(div7)
      );
      ctx[135](div9);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(horizontalScrollListener_action = /*horizontalScrollListener*/
          ctx[53].call(null, div1)),
          action_destroyer(scrollable_action = /*scrollable*/
          ctx[52].call(null, div7)),
          listen_dev(
            div7,
            "wheel",
            /*onwheel*/
            ctx[55],
            false,
            false,
            false,
            false
          ),
          action_destroyer(dragCreateTasks_action = /*dragCreateTasks*/
          ctx[59].call(null, div7, {
            container: (
              /*rowContainer*/
              ctx[21]
            ),
            enabled: (
              /*enableCreateTask*/
              ctx[9]
            ),
            onMove: (
              /*onCreateTaskMove*/
              ctx[57]
            ),
            onEnd: (
              /*onCreateTaskEnd*/
              ctx[58]
            ),
            boundsContainer: (
              /*mainContainer*/
              ctx[20]
            )
          })),
          listen_dev(div9, "pointerdown", stop_propagation(
            /*onEvent*/
            ctx[51]
          ), false, false, true, false),
          listen_dev(div9, "click", stop_propagation(
            /*onEvent*/
            ctx[51]
          ), false, false, true, false),
          listen_dev(
            div9,
            "dblclick",
            /*onEvent*/
            ctx[51],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div9,
            "pointerover",
            /*onEvent*/
            ctx[51],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div9,
            "pointerleave",
            /*onEvent*/
            ctx[51],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*tableWidth, ganttElement, ganttTableModules, rowContainerHeight, paddingTop, visibleRows*/
      33828884 | dirty[1] & /*onResize*/
      8388608 | dirty[2] & /*$$restProps*/
      1) {
        each_value_5 = ensure_array_like_dev(
          /*ganttTableModules*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value_5.length; i += 1) {
          const child_ctx = get_each_context_5(ctx2, each_value_5, i);
          if (each_blocks_4[i]) {
            each_blocks_4[i].p(child_ctx, dirty);
            transition_in(each_blocks_4[i], 1);
          } else {
            each_blocks_4[i] = create_each_block_5(child_ctx);
            each_blocks_4[i].c();
            transition_in(each_blocks_4[i], 1);
            each_blocks_4[i].m(div9, t0);
          }
        }
        group_outros();
        for (i = each_value_5.length; i < each_blocks_4.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      const columnheader_changes = {};
      if (dirty[0] & /*headers*/
      2) columnheader_changes.headers = /*headers*/
      ctx2[1];
      if (dirty[0] & /*columns*/
      8388608) columnheader_changes.ganttBodyColumns = /*columns*/
      ctx2[23];
      if (dirty[0] & /*columnUnit*/
      1) columnheader_changes.ganttBodyUnit = /*columnUnit*/
      ctx2[0];
      columnheader.$set(columnheader_changes);
      if (dirty[0] & /*$allTimeRanges*/
      536870912) {
        each_value_4 = ensure_array_like_dev(
          /*$allTimeRanges*/
          ctx2[29]
        );
        group_outros();
        validate_each_keys(ctx2, each_value_4, get_each_context_4, get_key);
        each_blocks_3 = update_keyed_each(each_blocks_3, dirty, get_key, 1, ctx2, each_value_4, each1_lookup, div0, outro_and_destroy_block, create_each_block_4, null, get_each_context_4);
        check_outros();
      }
      if (!current || dirty[0] & /*$_width*/
      65536) {
        set_style(
          div0,
          "width",
          /*$_width*/
          ctx2[16] + "px"
        );
      }
      if (!current || dirty[0] & /*$rightScrollbarVisible*/
      134217728 && div2_style_value !== (div2_style_value = `padding-right: ${/*$rightScrollbarVisible*/
      ctx2[27]}px;`)) {
        attr_dev(div2, "style", div2_style_value);
      }
      const columns_1_changes = {};
      if (dirty[0] & /*columns*/
      8388608) columns_1_changes.columns = /*columns*/
      ctx2[23];
      if (dirty[0] & /*columnStrokeColor*/
      128) columns_1_changes.columnStrokeColor = /*columnStrokeColor*/
      ctx2[7];
      if (dirty[0] & /*columnStrokeWidth*/
      256) columns_1_changes.columnStrokeWidth = /*columnStrokeWidth*/
      ctx2[8];
      if (dirty[0] & /*useCanvasColumns*/
      64) columns_1_changes.useCanvasColumns = /*useCanvasColumns*/
      ctx2[6];
      columns_1.$set(columns_1_changes);
      if (dirty[0] & /*visibleRows*/
      8192) {
        each_value_3 = ensure_array_like_dev(
          /*visibleRows*/
          ctx2[13]
        );
        group_outros();
        validate_each_keys(ctx2, each_value_3, get_each_context_3, get_key_1);
        each_blocks_2 = update_keyed_each(each_blocks_2, dirty, get_key_1, 1, ctx2, each_value_3, each2_lookup, div3, outro_and_destroy_block, create_each_block_3, null, get_each_context_3);
        check_outros();
      }
      if (!current || dirty[0] & /*paddingTop*/
      33554432) {
        set_style(div3, "transform", "translateY(" + /*paddingTop*/
        ctx2[25] + "px)");
      }
      if (!current || dirty[0] & /*rowContainerHeight*/
      4096) {
        set_style(
          div4,
          "height",
          /*rowContainerHeight*/
          ctx2[12] + "px"
        );
      }
      if (dirty[0] & /*$allTimeRanges*/
      536870912) {
        each_value_2 = ensure_array_like_dev(
          /*$allTimeRanges*/
          ctx2[29]
        );
        group_outros();
        validate_each_keys(ctx2, each_value_2, get_each_context_2, get_key_2);
        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key_2, 1, ctx2, each_value_2, each3_lookup, div5, outro_and_destroy_block, create_each_block_2, t5, get_each_context_2);
        check_outros();
      }
      const draggablegroup_changes = {};
      if (dirty[0] & /*draggingTasks*/
      16384) draggablegroup_changes.items = /*draggingTasks*/
      ctx2[14];
      if (dirty[0] & /*visibleTasks*/
      67108864 | dirty[5] & /*$$scope*/
      134217728) {
        draggablegroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      draggablegroup.$set(draggablegroup_changes);
      if (dirty[0] & /*ganttBodyModules, paddingTop, visibleRows*/
      33562656 | dirty[2] & /*$$restProps*/
      1) {
        each_value = ensure_array_like_dev(
          /*ganttBodyModules*/
          ctx2[5]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div6, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out_1(i);
        }
        check_outros();
      }
      if (!current || dirty[0] & /*$_width*/
      65536) {
        set_style(
          div6,
          "width",
          /*$_width*/
          ctx2[16] + "px"
        );
      }
      if (dragCreateTasks_action && is_function(dragCreateTasks_action.update) && dirty[0] & /*rowContainer, enableCreateTask, mainContainer*/
      3146240) dragCreateTasks_action.update.call(null, {
        container: (
          /*rowContainer*/
          ctx2[21]
        ),
        enabled: (
          /*enableCreateTask*/
          ctx2[9]
        ),
        onMove: (
          /*onCreateTaskMove*/
          ctx2[57]
        ),
        onEnd: (
          /*onCreateTaskEnd*/
          ctx2[58]
        ),
        boundsContainer: (
          /*mainContainer*/
          ctx2[20]
        )
      });
      if (!current || dirty[0] & /*zooming*/
      16777216) {
        toggle_class(
          div7,
          "zooming",
          /*zooming*/
          ctx2[24]
        );
      }
      if (!current || dirty[0] & /*classes*/
      8 && div9_class_value !== (div9_class_value = "sg-gantt " + /*classes*/
      ctx2[3] + " svelte-4g5bd")) {
        attr_dev(div9, "class", div9_class_value);
      }
      if (!current || dirty[0] & /*classes, disableTransition*/
      4194312) {
        toggle_class(
          div9,
          "sg-disable-transition",
          /*disableTransition*/
          ctx2[22]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value_5.length; i += 1) {
        transition_in(each_blocks_4[i]);
      }
      transition_in(columnheader.$$.fragment, local);
      for (let i = 0; i < each_value_4.length; i += 1) {
        transition_in(each_blocks_3[i]);
      }
      transition_in(columns_1.$$.fragment, local);
      for (let i = 0; i < each_value_3.length; i += 1) {
        transition_in(each_blocks_2[i]);
      }
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      transition_in(draggablegroup.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks_4 = each_blocks_4.filter(Boolean);
      for (let i = 0; i < each_blocks_4.length; i += 1) {
        transition_out(each_blocks_4[i]);
      }
      transition_out(columnheader.$$.fragment, local);
      for (let i = 0; i < each_blocks_3.length; i += 1) {
        transition_out(each_blocks_3[i]);
      }
      transition_out(columns_1.$$.fragment, local);
      for (let i = 0; i < each_blocks_2.length; i += 1) {
        transition_out(each_blocks_2[i]);
      }
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      transition_out(draggablegroup.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div9);
      }
      destroy_each(each_blocks_4, detaching);
      destroy_component(columnheader);
      for (let i = 0; i < each_blocks_3.length; i += 1) {
        each_blocks_3[i].d();
      }
      ctx[130](null);
      div2_resize_listener();
      destroy_component(columns_1);
      for (let i = 0; i < each_blocks_2.length; i += 1) {
        each_blocks_2[i].d();
      }
      ctx[132](null);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].d();
      }
      destroy_component(draggablegroup);
      destroy_each(each_blocks, detaching);
      ctx[133](null);
      div7_resize_listener();
      ctx[135](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function assertSet(values) {
  for (const name in values) {
    if (values[name] == null) {
      throw new Error(`"${name}" is not set`);
    }
  }
}
function toDateNum(date) {
  return date instanceof Date ? date.valueOf() : date;
}
function instance11($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "rows",
    "tasks",
    "timeRanges",
    "rowPadding",
    "rowHeight",
    "from",
    "to",
    "minWidth",
    "fitWidth",
    "classes",
    "headers",
    "zoomLevels",
    "taskContent",
    "tableWidth",
    "resizeHandleWidth",
    "onTaskButtonClick",
    "dateAdapter",
    "magnetUnit",
    "magnetOffset",
    "columnUnit",
    "columnOffset",
    "ganttTableModules",
    "ganttBodyModules",
    "reflectOnParentRows",
    "reflectOnChildRows",
    "useCanvasColumns",
    "columnStrokeColor",
    "columnStrokeWidth",
    "highlightedDurations",
    "highlightColor",
    "taskElementHook",
    "layout",
    "columnService",
    "api",
    "timeRangeFactory",
    "utils",
    "refreshTimeRanges",
    "refreshTasks",
    "getRowContainer",
    "selectTask",
    "unselectTasks",
    "scrollToRow",
    "scrollToTask",
    "updateTask",
    "updateTasks",
    "removeTask",
    "removeTasks",
    "updateRow",
    "updateRows",
    "getRow",
    "getTask",
    "getTasks",
    "updateLayoutSync",
    "updateLayout",
    "enableCreateTask",
    "onCreateTask",
    "onCreatedTask"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $allRows;
  let $rowTaskCache;
  let $rowStore;
  let $taskStore;
  let $visibleHeight;
  let $allTasks;
  let $_width;
  let $_to;
  let $_from;
  let $_fitWidth;
  let $_minWidth;
  let $hoveredRow;
  let $selectedRow;
  let $visibleWidth;
  let $rightScrollbarVisible;
  let $bottomScrollbarVisible;
  let $_layout;
  let $_rowPadding;
  let $_rowHeight;
  let $headerHeight;
  let $allTimeRanges;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Gantt", slots, []);
  let ganttElement;
  let mainHeaderContainer;
  let mainContainer;
  let rowContainer;
  let scrollables = [];
  let mounted = false;
  let { rows } = $$props;
  let { tasks = [] } = $$props;
  let { timeRanges = [] } = $$props;
  assertSet({ rows });
  let { rowPadding = 6 } = $$props;
  let { rowHeight = 52 } = $$props;
  const _rowHeight = writable(rowHeight);
  validate_store(_rowHeight, "_rowHeight");
  component_subscribe($$self, _rowHeight, (value) => $$invalidate(147, $_rowHeight = value));
  const _rowPadding = writable(rowPadding);
  validate_store(_rowPadding, "_rowPadding");
  component_subscribe($$self, _rowPadding, (value) => $$invalidate(146, $_rowPadding = value));
  let { from } = $$props;
  let { to } = $$props;
  assertSet({ from, to });
  const _from = writable(toDateNum(from));
  validate_store(_from, "_from");
  component_subscribe($$self, _from, (value) => $$invalidate(129, $_from = value));
  const _to = writable(toDateNum(to));
  validate_store(_to, "_to");
  component_subscribe($$self, _to, (value) => $$invalidate(128, $_to = value));
  let { minWidth = 800 } = $$props;
  let { fitWidth = false } = $$props;
  const _minWidth = writable(minWidth);
  validate_store(_minWidth, "_minWidth");
  component_subscribe($$self, _minWidth, (value) => $$invalidate(141, $_minWidth = value));
  const _fitWidth = writable(fitWidth);
  validate_store(_fitWidth, "_fitWidth");
  component_subscribe($$self, _fitWidth, (value) => $$invalidate(140, $_fitWidth = value));
  let { classes = [] } = $$props;
  let { headers = [{ unit: "day", format: "MMMM Do" }, { unit: "hour", format: "H:mm" }] } = $$props;
  let { zoomLevels = [
    {
      headers: [{ unit: "day", format: "DD.MM.YYYY" }, { unit: "hour", format: "HH" }],
      minWidth: 800,
      fitWidth: true
    },
    {
      headers: [
        { unit: "hour", format: "ddd D/M, H A" },
        { unit: "minute", format: "mm", offset: 15 }
      ],
      minWidth: 5e3,
      fitWidth: false
    }
  ] } = $$props;
  let { taskContent = null } = $$props;
  let { tableWidth = 240 } = $$props;
  let { resizeHandleWidth = 10 } = $$props;
  let { onTaskButtonClick = null } = $$props;
  let { dateAdapter = new DefaultSvelteGanttDateAdapter() } = $$props;
  let { magnetUnit = "minute" } = $$props;
  let { magnetOffset = 15 } = $$props;
  let magnetDuration;
  setMagnetDuration(magnetUnit, magnetOffset);
  function setMagnetDuration(unit, offset) {
    if (unit && offset) {
      magnetDuration = getDuration(unit, offset);
    }
  }
  let { columnUnit = "minute" } = $$props;
  let { columnOffset = 15 } = $$props;
  let { ganttTableModules = [] } = $$props;
  let { ganttBodyModules = [] } = $$props;
  let { reflectOnParentRows = true } = $$props;
  let { reflectOnChildRows = false } = $$props;
  let { useCanvasColumns = true } = $$props;
  let { columnStrokeColor = "#efefef" } = $$props;
  let { columnStrokeWidth = 1 } = $$props;
  let { highlightedDurations = void 0 } = $$props;
  let { highlightColor = "#6eb859" } = $$props;
  let { taskElementHook = null } = $$props;
  let { layout = "overlap" } = $$props;
  const _layout = writable(layout);
  validate_store(_layout, "_layout");
  component_subscribe($$self, _layout, (value) => $$invalidate(145, $_layout = value));
  const visibleWidth = writable(null);
  validate_store(visibleWidth, "visibleWidth");
  component_subscribe($$self, visibleWidth, (value) => $$invalidate(17, $visibleWidth = value));
  const visibleHeight = writable(null);
  validate_store(visibleHeight, "visibleHeight");
  component_subscribe($$self, visibleHeight, (value) => $$invalidate(15, $visibleHeight = value));
  const headerHeight = writable(null);
  validate_store(headerHeight, "headerHeight");
  component_subscribe($$self, headerHeight, (value) => $$invalidate(28, $headerHeight = value));
  const _width = derived([visibleWidth, _minWidth, _fitWidth], ([visible, min, stretch]) => {
    return stretch && visible > min ? visible : min;
  });
  validate_store(_width, "_width");
  component_subscribe($$self, _width, (value) => $$invalidate(16, $_width = value));
  const dataStore = createDataStore();
  setContext("dataStore", dataStore);
  const { rowStore, taskStore, timeRangeStore, allTasks, allRows, allTimeRanges, rowTaskCache } = dataStore;
  validate_store(rowStore, "rowStore");
  component_subscribe($$self, rowStore, (value) => $$invalidate(125, $rowStore = value));
  validate_store(taskStore, "taskStore");
  component_subscribe($$self, taskStore, (value) => $$invalidate(126, $taskStore = value));
  validate_store(allTasks, "allTasks");
  component_subscribe($$self, allTasks, (value) => $$invalidate(127, $allTasks = value));
  validate_store(allRows, "allRows");
  component_subscribe($$self, allRows, (value) => $$invalidate(123, $allRows = value));
  validate_store(allTimeRanges, "allTimeRanges");
  component_subscribe($$self, allTimeRanges, (value) => $$invalidate(29, $allTimeRanges = value));
  validate_store(rowTaskCache, "rowTaskCache");
  component_subscribe($$self, rowTaskCache, (value) => $$invalidate(124, $rowTaskCache = value));
  const columnService = createColumnService({
    get columns() {
      return columns;
    },
    get magnetDuration() {
      return magnetDuration;
    }
  });
  let disableTransition = false;
  async function tickWithoutCSSTransition() {
    $$invalidate(22, disableTransition = true);
    await tick();
    ganttElement.offsetHeight;
    $$invalidate(22, disableTransition = false);
  }
  let columns;
  function getColumnsV2(from2, to2, unit, offset, width) {
    if (from2 instanceof Date) from2 = from2.valueOf();
    if (to2 instanceof Date) to2 = to2.valueOf();
    let cols = [];
    const periods = getAllPeriods(from2.valueOf(), to2.valueOf(), unit, offset, highlightedDurations);
    let left = 0;
    let distance_point = 0;
    periods.forEach(function(period) {
      left = distance_point;
      distance_point = getPositionByDate(period.to, $_from, $_to, $_width);
      cols.push({
        width: distance_point - left,
        from: period.from,
        to: period.to,
        left,
        duration: period.duration,
        ...period.isHighlighted && { bgHighlightColor: highlightColor }
      });
    });
    return cols;
  }
  let offsetWidth;
  let offsetHeight;
  let bottomScrollbarVisible = writable(offsetHeight - $visibleHeight);
  validate_store(bottomScrollbarVisible, "bottomScrollbarVisible");
  component_subscribe($$self, bottomScrollbarVisible, (value) => $$invalidate(144, $bottomScrollbarVisible = value));
  let rightScrollbarVisible = writable(offsetWidth - $visibleWidth);
  validate_store(rightScrollbarVisible, "rightScrollbarVisible");
  component_subscribe($$self, rightScrollbarVisible, (value) => $$invalidate(27, $rightScrollbarVisible = value));
  setContext("dimensions", {
    from: _from,
    to: _to,
    width: _width,
    visibleWidth,
    visibleHeight,
    headerHeight,
    bottomScrollbarVisible,
    rightScrollbarVisible
  });
  setContext("options", {
    dateAdapter,
    taskElementHook,
    taskContent,
    rowPadding: _rowPadding,
    rowHeight: _rowHeight,
    layout: _layout,
    resizeHandleWidth,
    reflectOnParentRows,
    reflectOnChildRows,
    onTaskButtonClick
  });
  const hoveredRow = writable(null);
  validate_store(hoveredRow, "hoveredRow");
  component_subscribe($$self, hoveredRow, (value) => $$invalidate(142, $hoveredRow = value));
  const selectedRow = writable(null);
  validate_store(selectedRow, "selectedRow");
  component_subscribe($$self, selectedRow, (value) => $$invalidate(143, $selectedRow = value));
  const ganttContext = {
    rowContainer: null,
    mainContainer: null,
    mainHeaderContainer: null,
    scrollables,
    hoveredRow,
    selectedRow,
    updateLayout,
    expandRow(row) {
      expandRow(row);
      updateLayout();
    },
    collapseRow(row) {
      collapseRow(row);
      updateLayout();
    },
    invalidatePosition
  };
  setContext("gantt", ganttContext);
  let invalidatedTasks = {};
  let invalidatedRows = {};
  let invalidateFull = true;
  function invalidatePosition({ task, row }) {
    if (row) {
      $$invalidate(112, invalidatedRows[row.model.id] = true, invalidatedRows);
      $$invalidate(113, invalidateFull = false);
    }
    if (task) {
      $$invalidate(111, invalidatedTasks[task.model.id] = true, invalidatedTasks);
      $$invalidate(112, invalidatedRows[task.model.resourceId] = true, invalidatedRows);
      $$invalidate(113, invalidateFull = false);
    }
  }
  onMount(() => {
    Object.assign(ganttContext, {
      rowContainer,
      mainContainer,
      mainHeaderContainer
    });
    $$invalidate(110, mounted = true);
  });
  const { onDelegatedEvent, offDelegatedEvent, onEvent } = createDelegatedEventDispatcher();
  onDelegatedEvent("click", "data-task-id", (event, data, target) => {
    const taskId = data;
    const task = $taskStore.entities[taskId];
    if (isLeftClick(event) && !target.classList.contains("sg-task-reflected") && !target.classList.contains("sg-ignore-click")) {
      if (event.ctrlKey) {
        selectionManager.toggleSelection(taskId);
      } else {
        selectionManager.selectSingle(taskId);
      }
    }
    api["tasks"].raise.select(task);
  });
  onDelegatedEvent("pointerover", "data-row-id", (event, data, target) => {
    set_store_value(hoveredRow, $hoveredRow = data, $hoveredRow);
  });
  onDelegatedEvent("click", "data-row-id", (event, data, target) => {
    selectionManager.unSelectTasks();
    if ($selectedRow == data) {
      set_store_value(selectedRow, $selectedRow = null, $selectedRow);
      return;
    }
    set_store_value(selectedRow, $selectedRow = data, $selectedRow);
  });
  onDelegatedEvent("dblclick", "data-task-id", (event, data, target) => {
    const taskId = data;
    api["tasks"].raise.dblclicked($taskStore.entities[taskId], event);
  });
  onDelegatedEvent("pointerleave", "empty", (event, data, target) => {
    set_store_value(hoveredRow, $hoveredRow = null, $hoveredRow);
  });
  onDestroy(() => {
    offDelegatedEvent("click", "data-task-id");
    offDelegatedEvent("click", "data-row-id");
    offDelegatedEvent("dblclick", "data-task-id");
    selectionManager.unSelectTasks();
  });
  let __scrollTop = 0;
  let __scrollLeft = 0;
  function scrollable(node) {
    const onscroll = (event) => {
      const { scrollTop, scrollLeft } = node;
      scrollables.forEach((scrollable2) => {
        if (scrollable2.orientation === "horizontal") {
          scrollable2.node.scrollLeft = scrollLeft;
        } else {
          scrollable2.node.scrollTop = scrollTop;
        }
      });
      $$invalidate(114, __scrollTop = scrollTop);
      __scrollLeft = scrollLeft;
    };
    node.addEventListener("scroll", onscroll);
    return {
      destroy() {
        node.removeEventListener("scroll", onscroll, false);
      }
    };
  }
  function horizontalScrollListener(node) {
    scrollables.push({ node, orientation: "horizontal" });
  }
  function onResize(event) {
    $$invalidate(2, tableWidth = event.detail.left);
  }
  let zoomLevel = 0;
  let zooming = false;
  async function onwheel(event) {
    if (event.ctrlKey) {
      event.preventDefault();
      const prevZoomLevel = zoomLevel;
      if (event.deltaY > 0) {
        zoomLevel = Math.max(zoomLevel - 1, 0);
      } else {
        zoomLevel = Math.min(zoomLevel + 1, zoomLevels.length - 1);
      }
      if (prevZoomLevel != zoomLevel && zoomLevels[zoomLevel]) {
        const options = {
          columnUnit,
          columnOffset,
          minWidth: $_minWidth,
          ...zoomLevels[zoomLevel]
        };
        const scale = options.minWidth / $_width;
        const node = mainContainer;
        const mousepos = getRelativePos(node, event);
        const before = node.scrollLeft + mousepos.x;
        const after = before * scale;
        const scrollLeft = after - mousepos.x + node.clientWidth / 2;
        $$invalidate(0, columnUnit = options.columnUnit);
        $$invalidate(63, columnOffset = options.columnOffset);
        set_store_value(_minWidth, $_minWidth = options.minWidth, $_minWidth);
        if (options.headers) $$invalidate(1, headers = options.headers);
        if (options.fitWidth) set_store_value(_fitWidth, $_fitWidth = options.fitWidth, $_fitWidth);
        api["gantt"].raise.viewChanged();
        $$invalidate(24, zooming = true);
        await tick();
        node.scrollLeft = scrollLeft;
        $$invalidate(24, zooming = false);
      }
    }
  }
  function onDateSelected(event) {
    set_store_value(_from, $_from = event.detail.from, $_from);
    set_store_value(_to, $_to = event.detail.to, $_to);
    api["gantt"].raise.dateSelected({ from: $_from, to: $_to });
  }
  function initRows(rowsData) {
    const rows2 = createRows(rowsData, { rowHeight });
    rowStore.addAll(rows2);
    updateLayout();
  }
  const { createTask: createTask2, reflectTask: reflectTask2 } = createTaskFactory({
    get rowEntities() {
      return $rowStore.entities;
    },
    get rowPadding() {
      return rowPadding;
    },
    getPositionByDate: (date) => columnService.getPositionByDate(date)
  });
  async function initTasks(taskData) {
    const tasks2 = [];
    for (const taskModel of taskData) {
      if (!draggingTasks[taskModel.id]) {
        delete draggingTasks[taskModel.id];
      }
      const task = createTask2(taskModel);
      tasks2.push(task);
    }
    taskStore.addAll(tasks2);
    updateLayout();
  }
  let _reflectedTasksCache = {};
  function initTimeRanges(timeRangeData) {
    const timeRanges2 = timeRangeData.map((timeRange) => {
      return timeRangeFactory.create(timeRange);
    });
    timeRangeStore.addAll(timeRanges2);
  }
  const api = provideGanttApi();
  const selectionManager = new SelectionManager(taskStore);
  const timeRangeFactory = new TimeRangeFactory(columnService);
  const utils = createUtils({
    get from() {
      return $_from;
    },
    get to() {
      return $_to;
    },
    get width() {
      return $_width;
    },
    get magnetOffset() {
      return magnetOffset;
    },
    get magnetUnit() {
      return magnetUnit;
    },
    get magnetDuration() {
      return magnetDuration;
    },
    get dateAdapter() {
      return dateAdapter;
    }
  });
  setContext("services", {
    utils,
    api,
    selectionManager,
    columnService
  });
  function refreshTimeRanges() {
    timeRangeStore._update(({ ids, entities }) => {
      ids.forEach((id) => {
        const timeRange = entities[id];
        const newLeft = columnService.getPositionByDate(timeRange.model.from) | 0;
        const newRight = columnService.getPositionByDate(timeRange.model.to) | 0;
        timeRange.left = newLeft;
        timeRange.width = newRight - newLeft;
      });
      return { ids, entities };
    });
  }
  function refreshTasks() {
    $allTasks.forEach((task) => {
      const newLeft = columnService.getPositionByDate(task.model.from) | 0;
      const newRight = columnService.getPositionByDate(task.model.to) | 0;
      task.left = newLeft;
      task.width = newRight - newLeft;
    });
    taskStore.refresh();
  }
  function getRowContainer() {
    return rowContainer;
  }
  function selectTask(id) {
    const task = $taskStore.entities[id];
    if (task) {
      selectionManager.selectSingle(id);
    }
  }
  function unselectTasks() {
    selectionManager.unSelectTasks();
  }
  function scrollToRow(id, scrollBehavior = "auto") {
    const { scrollTop, clientHeight } = mainContainer;
    const row = $rowStore.entities[id];
    if (!row) {
      return;
    }
    const targetTop = row.y;
    if (targetTop < scrollTop) {
      mainContainer.scrollTo({ top: targetTop, behavior: scrollBehavior });
    }
    if (targetTop > scrollTop + clientHeight) {
      mainContainer.scrollTo({
        top: targetTop + row.height - clientHeight,
        behavior: scrollBehavior
      });
    }
  }
  function scrollToTask(id, scrollBehavior = "auto") {
    const { scrollLeft, scrollTop, clientWidth, clientHeight } = mainContainer;
    const task = $taskStore.entities[id];
    if (!task) return;
    const row = $rowStore.entities[task.model.resourceId];
    if (!row) return;
    const targetLeft = task.left;
    const targetTop = row.y;
    const options = {
      top: void 0,
      left: void 0,
      behavior: scrollBehavior
    };
    if (targetLeft < scrollLeft) {
      options.left = targetLeft;
    }
    if (targetLeft > scrollLeft + clientWidth) {
      options.left = targetLeft + task.width - clientWidth;
    }
    if (targetTop < scrollTop) {
      options.top = targetTop;
    }
    if (targetTop > scrollTop + clientHeight) {
      options.top = targetTop + row.height - clientHeight;
    }
    mainContainer.scrollTo(options);
  }
  function updateTask(model) {
    const task = createTask2(model);
    taskStore.upsert(task);
    invalidatePosition({ task });
    updateLayoutSync();
  }
  function updateTasks(models) {
    const tasks2 = models.map((model) => createTask2(model));
    taskStore.upsertAll(tasks2);
    tasks2.forEach((task) => invalidatePosition({ task }));
    updateLayoutSync();
  }
  function removeTask(taskId) {
    const task = $taskStore.entities[taskId];
    if (!task) {
      return;
    }
    taskStore.delete(taskId);
    const row = $rowStore.entities[task.model.resourceId];
    if (!row) {
      return;
    }
    invalidatePosition({ row });
    updateLayoutSync();
  }
  function removeTasks(taskIds) {
    for (const taskId of taskIds) {
      const task = $taskStore.entities[taskId];
      if (!task) {
        continue;
      }
      const row = $rowStore.entities[task.model.resourceId];
      if (!row) {
        continue;
      }
      invalidatePosition({ row });
    }
    taskStore.deleteAll(taskIds);
    updateLayoutSync();
  }
  function updateRow(model) {
    const row = createRows([model], { rowHeight });
    rowStore.upsertAll(row);
    updateLayout();
    updateLayoutSync();
  }
  function updateRows(models) {
    const rows2 = createRows(models, { rowHeight });
    rowStore.upsertAll(rows2);
    updateLayout();
    updateLayoutSync();
  }
  function getRow(resourceId) {
    return $rowStore.entities[resourceId];
  }
  function getTask(id) {
    return $taskStore.entities[id];
  }
  function getTasks(resourceId) {
    if ($rowTaskCache[resourceId]) {
      return $rowTaskCache[resourceId].map((id) => $taskStore.entities[id]);
    }
    return null;
  }
  let filteredRows = [];
  let rowsAreOfSameHeight = true;
  let rowContainerHeight = 0;
  let startIndex;
  let endIndex;
  let paddingTop = 0;
  let visibleRows = [];
  let visibleTasks;
  let previousOrder = {};
  let layoutChanged = {};
  let refreshLayout = {};
  function updateLayoutSync(_invalidateFull) {
    const params = {
      taskStore: $taskStore,
      rowStore: $rowStore,
      rowTasks: $rowTaskCache,
      rowHeight,
      rowPadding,
      rowReflectedTasks: _reflectedTasksCache,
      invalidatedRows,
      invalidatedTasks,
      invalidateFull: _invalidateFull ?? invalidateFull
    };
    if (layout === "overlap") {
      overlap(params);
    }
    if (layout === "pack") {
      pack(params);
    }
    if (layout === "expand") {
      expand(params);
    }
    $$invalidate(121, layoutChanged = {});
    $$invalidate(113, invalidateFull = false);
    $$invalidate(111, invalidatedTasks = {});
    $$invalidate(112, invalidatedRows = {});
  }
  function updateLayout() {
    $$invalidate(122, refreshLayout = {});
    $$invalidate(113, invalidateFull = true);
  }
  let { enableCreateTask = false } = $$props;
  let { onCreateTask = (e) => {
    const id = `creating-task-${(Math.random() + 1).toString(36).substring(2, 7)}`;
    return { id, label: " ", ...e };
  } } = $$props;
  let { onCreatedTask = (task) => {
  } } = $$props;
  let draggingTasks = {};
  let _creatingTask = null;
  function onCreateTaskMove({ from: from2, to: to2, x, width, y }) {
    if (!_creatingTask) {
      const row = $allRows.find((row2) => row2.y < y && y < row2.y + row2.height);
      const resourceId = row.model.id;
      _creatingTask = createTask2(onCreateTask({ resourceId, from: from2, to: to2 }));
      taskStore.upsert(_creatingTask);
      $$invalidate(
        14,
        draggingTasks[_creatingTask.model.id] = {
          x: _creatingTask.left,
          y: _creatingTask.top,
          width: _creatingTask.width,
          resizing: true
        },
        draggingTasks
      );
    }
    $$invalidate(14, draggingTasks[_creatingTask.model.id].x = x, draggingTasks);
    $$invalidate(14, draggingTasks[_creatingTask.model.id].width = width, draggingTasks);
  }
  function onCreateTaskEnd({ from: from2, to: to2, x, width }) {
    _creatingTask.model.from = from2;
    _creatingTask.model.to = to2;
    _creatingTask.left = x;
    _creatingTask.width = width;
    taskStore.upsert(_creatingTask);
    delete draggingTasks[_creatingTask.model.id];
    onCreatedTask(_creatingTask);
    _creatingTask = null;
  }
  const dragCreateTasks = useCreateTask();
  function onChange(e) {
    if (e.detail.changes.some((c) => !c.targetRow)) {
      return;
    }
    for (const change of e.detail.changes) {
      const { task, current, previous, sourceRow, targetRow } = change;
      if (!targetRow) {
        continue;
      }
      const model = task.model;
      if (targetRow) {
        api.tasks.raise.switchRow(task, targetRow, sourceRow);
      }
      const changed = previous.from != current.from || previous.to != current.to || sourceRow && sourceRow.model.id !== targetRow.model.id;
      if (changed) {
        model.from = current.from;
        model.to = current.to;
        model.resourceId = targetRow.model.id;
        const newTask = {
          ...task,
          left: current.left,
          top: current.top,
          width: current.width
        };
        api.tasks.raise.change({
          task: newTask,
          sourceRow,
          targetRow,
          previousState: previous
        });
        api.tasks.raise.changed({
          task: newTask,
          sourceRow,
          targetRow,
          previousState: previous
        });
        taskStore.update(newTask);
        invalidatePosition({ row: sourceRow });
        invalidatePosition({ task: newTask });
      }
    }
  }
  function onItemsChange(e) {
    $$invalidate(14, draggingTasks = { ...e.detail.items });
  }
  $$self.$$.on_mount.push(function() {
    if (rows === void 0 && !("rows" in $$props || $$self.$$.bound[$$self.$$.props["rows"]])) {
      console.warn("<Gantt> was created without expected prop 'rows'");
    }
    if (from === void 0 && !("from" in $$props || $$self.$$.bound[$$self.$$.props["from"]])) {
      console.warn("<Gantt> was created without expected prop 'from'");
    }
    if (to === void 0 && !("to" in $$props || $$self.$$.bound[$$self.$$.props["to"]])) {
      console.warn("<Gantt> was created without expected prop 'to'");
    }
  });
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      mainHeaderContainer = $$value;
      $$invalidate(19, mainHeaderContainer);
    });
  }
  function div2_elementresize_handler() {
    $headerHeight = this.clientHeight;
    headerHeight.set($headerHeight);
  }
  function div4_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      rowContainer = $$value;
      $$invalidate(21, rowContainer);
    });
  }
  function div7_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      mainContainer = $$value;
      $$invalidate(20, mainContainer);
    });
  }
  function div7_elementresize_handler() {
    $visibleHeight = this.clientHeight;
    visibleHeight.set($visibleHeight);
    offsetHeight = this.offsetHeight;
    $visibleWidth = this.clientWidth;
    visibleWidth.set($visibleWidth);
    offsetWidth = this.offsetWidth;
    $$invalidate(11, offsetHeight);
    $$invalidate(10, offsetWidth);
  }
  function div9_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ganttElement = $$value;
      $$invalidate(18, ganttElement);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(62, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("rows" in $$new_props) $$invalidate(64, rows = $$new_props.rows);
    if ("tasks" in $$new_props) $$invalidate(65, tasks = $$new_props.tasks);
    if ("timeRanges" in $$new_props) $$invalidate(66, timeRanges = $$new_props.timeRanges);
    if ("rowPadding" in $$new_props) $$invalidate(67, rowPadding = $$new_props.rowPadding);
    if ("rowHeight" in $$new_props) $$invalidate(68, rowHeight = $$new_props.rowHeight);
    if ("from" in $$new_props) $$invalidate(69, from = $$new_props.from);
    if ("to" in $$new_props) $$invalidate(70, to = $$new_props.to);
    if ("minWidth" in $$new_props) $$invalidate(71, minWidth = $$new_props.minWidth);
    if ("fitWidth" in $$new_props) $$invalidate(72, fitWidth = $$new_props.fitWidth);
    if ("classes" in $$new_props) $$invalidate(3, classes = $$new_props.classes);
    if ("headers" in $$new_props) $$invalidate(1, headers = $$new_props.headers);
    if ("zoomLevels" in $$new_props) $$invalidate(73, zoomLevels = $$new_props.zoomLevels);
    if ("taskContent" in $$new_props) $$invalidate(74, taskContent = $$new_props.taskContent);
    if ("tableWidth" in $$new_props) $$invalidate(2, tableWidth = $$new_props.tableWidth);
    if ("resizeHandleWidth" in $$new_props) $$invalidate(75, resizeHandleWidth = $$new_props.resizeHandleWidth);
    if ("onTaskButtonClick" in $$new_props) $$invalidate(76, onTaskButtonClick = $$new_props.onTaskButtonClick);
    if ("dateAdapter" in $$new_props) $$invalidate(77, dateAdapter = $$new_props.dateAdapter);
    if ("magnetUnit" in $$new_props) $$invalidate(78, magnetUnit = $$new_props.magnetUnit);
    if ("magnetOffset" in $$new_props) $$invalidate(79, magnetOffset = $$new_props.magnetOffset);
    if ("columnUnit" in $$new_props) $$invalidate(0, columnUnit = $$new_props.columnUnit);
    if ("columnOffset" in $$new_props) $$invalidate(63, columnOffset = $$new_props.columnOffset);
    if ("ganttTableModules" in $$new_props) $$invalidate(4, ganttTableModules = $$new_props.ganttTableModules);
    if ("ganttBodyModules" in $$new_props) $$invalidate(5, ganttBodyModules = $$new_props.ganttBodyModules);
    if ("reflectOnParentRows" in $$new_props) $$invalidate(80, reflectOnParentRows = $$new_props.reflectOnParentRows);
    if ("reflectOnChildRows" in $$new_props) $$invalidate(81, reflectOnChildRows = $$new_props.reflectOnChildRows);
    if ("useCanvasColumns" in $$new_props) $$invalidate(6, useCanvasColumns = $$new_props.useCanvasColumns);
    if ("columnStrokeColor" in $$new_props) $$invalidate(7, columnStrokeColor = $$new_props.columnStrokeColor);
    if ("columnStrokeWidth" in $$new_props) $$invalidate(8, columnStrokeWidth = $$new_props.columnStrokeWidth);
    if ("highlightedDurations" in $$new_props) $$invalidate(82, highlightedDurations = $$new_props.highlightedDurations);
    if ("highlightColor" in $$new_props) $$invalidate(83, highlightColor = $$new_props.highlightColor);
    if ("taskElementHook" in $$new_props) $$invalidate(84, taskElementHook = $$new_props.taskElementHook);
    if ("layout" in $$new_props) $$invalidate(85, layout = $$new_props.layout);
    if ("enableCreateTask" in $$new_props) $$invalidate(9, enableCreateTask = $$new_props.enableCreateTask);
    if ("onCreateTask" in $$new_props) $$invalidate(108, onCreateTask = $$new_props.onCreateTask);
    if ("onCreatedTask" in $$new_props) $$invalidate(109, onCreatedTask = $$new_props.onCreatedTask);
  };
  $$self.$capture_state = () => ({
    onMount,
    setContext,
    tick,
    onDestroy,
    writable,
    derived,
    ganttElement,
    mainHeaderContainer,
    mainContainer,
    rowContainer,
    scrollables,
    mounted,
    createDataStore,
    Task: Task_default,
    Row: Row_default,
    TimeRange: TimeRange_default,
    TimeRangeHeader: TimeRangeHeader_default,
    Columns: Columns_default,
    ColumnHeader: ColumnHeader_default,
    Resizer: Resizer_default,
    createUtils,
    getIndicesOnly,
    getPositionByDate,
    getRelativePos,
    isLeftClick,
    provideGanttApi,
    createTaskFactory,
    collapseRow,
    expandRow,
    createRows,
    TimeRangeFactory,
    DraggableGroup: DraggableGroup_default,
    SelectionManager,
    createColumnService,
    createDelegatedEventDispatcher,
    getDuration,
    getAllPeriods,
    DefaultSvelteGanttDateAdapter,
    layouts: layouts_exports,
    useCreateTask,
    Draggable: Draggable_default,
    assertSet,
    rows,
    tasks,
    timeRanges,
    rowPadding,
    rowHeight,
    _rowHeight,
    _rowPadding,
    toDateNum,
    from,
    to,
    _from,
    _to,
    minWidth,
    fitWidth,
    _minWidth,
    _fitWidth,
    classes,
    headers,
    zoomLevels,
    taskContent,
    tableWidth,
    resizeHandleWidth,
    onTaskButtonClick,
    dateAdapter,
    magnetUnit,
    magnetOffset,
    magnetDuration,
    setMagnetDuration,
    columnUnit,
    columnOffset,
    ganttTableModules,
    ganttBodyModules,
    reflectOnParentRows,
    reflectOnChildRows,
    useCanvasColumns,
    columnStrokeColor,
    columnStrokeWidth,
    highlightedDurations,
    highlightColor,
    taskElementHook,
    layout,
    _layout,
    visibleWidth,
    visibleHeight,
    headerHeight,
    _width,
    dataStore,
    rowStore,
    taskStore,
    timeRangeStore,
    allTasks,
    allRows,
    allTimeRanges,
    rowTaskCache,
    columnService,
    disableTransition,
    tickWithoutCSSTransition,
    columns,
    getColumnsV2,
    offsetWidth,
    offsetHeight,
    bottomScrollbarVisible,
    rightScrollbarVisible,
    hoveredRow,
    selectedRow,
    ganttContext,
    invalidatedTasks,
    invalidatedRows,
    invalidateFull,
    invalidatePosition,
    onDelegatedEvent,
    offDelegatedEvent,
    onEvent,
    __scrollTop,
    __scrollLeft,
    scrollable,
    horizontalScrollListener,
    onResize,
    zoomLevel,
    zooming,
    onwheel,
    onDateSelected,
    initRows,
    createTask: createTask2,
    reflectTask: reflectTask2,
    initTasks,
    _reflectedTasksCache,
    initTimeRanges,
    api,
    selectionManager,
    timeRangeFactory,
    utils,
    refreshTimeRanges,
    refreshTasks,
    getRowContainer,
    selectTask,
    unselectTasks,
    scrollToRow,
    scrollToTask,
    updateTask,
    updateTasks,
    removeTask,
    removeTasks,
    updateRow,
    updateRows,
    getRow,
    getTask,
    getTasks,
    filteredRows,
    rowsAreOfSameHeight,
    rowContainerHeight,
    startIndex,
    endIndex,
    paddingTop,
    visibleRows,
    visibleTasks,
    previousOrder,
    layoutChanged,
    refreshLayout,
    updateLayoutSync,
    updateLayout,
    enableCreateTask,
    onCreateTask,
    onCreatedTask,
    draggingTasks,
    _creatingTask,
    onCreateTaskMove,
    onCreateTaskEnd,
    dragCreateTasks,
    onChange,
    onItemsChange,
    $allRows,
    $rowTaskCache,
    $rowStore,
    $taskStore,
    $visibleHeight,
    $allTasks,
    $_width,
    $_to,
    $_from,
    $_fitWidth,
    $_minWidth,
    $hoveredRow,
    $selectedRow,
    $visibleWidth,
    $rightScrollbarVisible,
    $bottomScrollbarVisible,
    $_layout,
    $_rowPadding,
    $_rowHeight,
    $headerHeight,
    $allTimeRanges
  });
  $$self.$inject_state = ($$new_props) => {
    if ("ganttElement" in $$props) $$invalidate(18, ganttElement = $$new_props.ganttElement);
    if ("mainHeaderContainer" in $$props) $$invalidate(19, mainHeaderContainer = $$new_props.mainHeaderContainer);
    if ("mainContainer" in $$props) $$invalidate(20, mainContainer = $$new_props.mainContainer);
    if ("rowContainer" in $$props) $$invalidate(21, rowContainer = $$new_props.rowContainer);
    if ("scrollables" in $$props) scrollables = $$new_props.scrollables;
    if ("mounted" in $$props) $$invalidate(110, mounted = $$new_props.mounted);
    if ("rows" in $$props) $$invalidate(64, rows = $$new_props.rows);
    if ("tasks" in $$props) $$invalidate(65, tasks = $$new_props.tasks);
    if ("timeRanges" in $$props) $$invalidate(66, timeRanges = $$new_props.timeRanges);
    if ("rowPadding" in $$props) $$invalidate(67, rowPadding = $$new_props.rowPadding);
    if ("rowHeight" in $$props) $$invalidate(68, rowHeight = $$new_props.rowHeight);
    if ("from" in $$props) $$invalidate(69, from = $$new_props.from);
    if ("to" in $$props) $$invalidate(70, to = $$new_props.to);
    if ("minWidth" in $$props) $$invalidate(71, minWidth = $$new_props.minWidth);
    if ("fitWidth" in $$props) $$invalidate(72, fitWidth = $$new_props.fitWidth);
    if ("classes" in $$props) $$invalidate(3, classes = $$new_props.classes);
    if ("headers" in $$props) $$invalidate(1, headers = $$new_props.headers);
    if ("zoomLevels" in $$props) $$invalidate(73, zoomLevels = $$new_props.zoomLevels);
    if ("taskContent" in $$props) $$invalidate(74, taskContent = $$new_props.taskContent);
    if ("tableWidth" in $$props) $$invalidate(2, tableWidth = $$new_props.tableWidth);
    if ("resizeHandleWidth" in $$props) $$invalidate(75, resizeHandleWidth = $$new_props.resizeHandleWidth);
    if ("onTaskButtonClick" in $$props) $$invalidate(76, onTaskButtonClick = $$new_props.onTaskButtonClick);
    if ("dateAdapter" in $$props) $$invalidate(77, dateAdapter = $$new_props.dateAdapter);
    if ("magnetUnit" in $$props) $$invalidate(78, magnetUnit = $$new_props.magnetUnit);
    if ("magnetOffset" in $$props) $$invalidate(79, magnetOffset = $$new_props.magnetOffset);
    if ("magnetDuration" in $$props) magnetDuration = $$new_props.magnetDuration;
    if ("columnUnit" in $$props) $$invalidate(0, columnUnit = $$new_props.columnUnit);
    if ("columnOffset" in $$props) $$invalidate(63, columnOffset = $$new_props.columnOffset);
    if ("ganttTableModules" in $$props) $$invalidate(4, ganttTableModules = $$new_props.ganttTableModules);
    if ("ganttBodyModules" in $$props) $$invalidate(5, ganttBodyModules = $$new_props.ganttBodyModules);
    if ("reflectOnParentRows" in $$props) $$invalidate(80, reflectOnParentRows = $$new_props.reflectOnParentRows);
    if ("reflectOnChildRows" in $$props) $$invalidate(81, reflectOnChildRows = $$new_props.reflectOnChildRows);
    if ("useCanvasColumns" in $$props) $$invalidate(6, useCanvasColumns = $$new_props.useCanvasColumns);
    if ("columnStrokeColor" in $$props) $$invalidate(7, columnStrokeColor = $$new_props.columnStrokeColor);
    if ("columnStrokeWidth" in $$props) $$invalidate(8, columnStrokeWidth = $$new_props.columnStrokeWidth);
    if ("highlightedDurations" in $$props) $$invalidate(82, highlightedDurations = $$new_props.highlightedDurations);
    if ("highlightColor" in $$props) $$invalidate(83, highlightColor = $$new_props.highlightColor);
    if ("taskElementHook" in $$props) $$invalidate(84, taskElementHook = $$new_props.taskElementHook);
    if ("layout" in $$props) $$invalidate(85, layout = $$new_props.layout);
    if ("disableTransition" in $$props) $$invalidate(22, disableTransition = $$new_props.disableTransition);
    if ("columns" in $$props) $$invalidate(23, columns = $$new_props.columns);
    if ("offsetWidth" in $$props) $$invalidate(10, offsetWidth = $$new_props.offsetWidth);
    if ("offsetHeight" in $$props) $$invalidate(11, offsetHeight = $$new_props.offsetHeight);
    if ("bottomScrollbarVisible" in $$props) $$invalidate(47, bottomScrollbarVisible = $$new_props.bottomScrollbarVisible);
    if ("rightScrollbarVisible" in $$props) $$invalidate(48, rightScrollbarVisible = $$new_props.rightScrollbarVisible);
    if ("invalidatedTasks" in $$props) $$invalidate(111, invalidatedTasks = $$new_props.invalidatedTasks);
    if ("invalidatedRows" in $$props) $$invalidate(112, invalidatedRows = $$new_props.invalidatedRows);
    if ("invalidateFull" in $$props) $$invalidate(113, invalidateFull = $$new_props.invalidateFull);
    if ("__scrollTop" in $$props) $$invalidate(114, __scrollTop = $$new_props.__scrollTop);
    if ("__scrollLeft" in $$props) __scrollLeft = $$new_props.__scrollLeft;
    if ("zoomLevel" in $$props) zoomLevel = $$new_props.zoomLevel;
    if ("zooming" in $$props) $$invalidate(24, zooming = $$new_props.zooming);
    if ("_reflectedTasksCache" in $$props) $$invalidate(115, _reflectedTasksCache = $$new_props._reflectedTasksCache);
    if ("filteredRows" in $$props) $$invalidate(116, filteredRows = $$new_props.filteredRows);
    if ("rowsAreOfSameHeight" in $$props) $$invalidate(117, rowsAreOfSameHeight = $$new_props.rowsAreOfSameHeight);
    if ("rowContainerHeight" in $$props) $$invalidate(12, rowContainerHeight = $$new_props.rowContainerHeight);
    if ("startIndex" in $$props) $$invalidate(118, startIndex = $$new_props.startIndex);
    if ("endIndex" in $$props) $$invalidate(119, endIndex = $$new_props.endIndex);
    if ("paddingTop" in $$props) $$invalidate(25, paddingTop = $$new_props.paddingTop);
    if ("visibleRows" in $$props) $$invalidate(13, visibleRows = $$new_props.visibleRows);
    if ("visibleTasks" in $$props) $$invalidate(26, visibleTasks = $$new_props.visibleTasks);
    if ("previousOrder" in $$props) $$invalidate(120, previousOrder = $$new_props.previousOrder);
    if ("layoutChanged" in $$props) $$invalidate(121, layoutChanged = $$new_props.layoutChanged);
    if ("refreshLayout" in $$props) $$invalidate(122, refreshLayout = $$new_props.refreshLayout);
    if ("enableCreateTask" in $$props) $$invalidate(9, enableCreateTask = $$new_props.enableCreateTask);
    if ("onCreateTask" in $$props) $$invalidate(108, onCreateTask = $$new_props.onCreateTask);
    if ("onCreatedTask" in $$props) $$invalidate(109, onCreatedTask = $$new_props.onCreatedTask);
    if ("draggingTasks" in $$props) $$invalidate(14, draggingTasks = $$new_props.draggingTasks);
    if ("_creatingTask" in $$props) _creatingTask = $$new_props._creatingTask;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[2] & /*rows*/
    4 | $$self.$$.dirty[3] & /*mounted*/
    131072) {
      $: if (mounted) initRows(rows);
    }
    if ($$self.$$.dirty[2] & /*tasks*/
    8 | $$self.$$.dirty[3] & /*mounted*/
    131072) {
      $: if (mounted) initTasks(tasks);
    }
    if ($$self.$$.dirty[2] & /*timeRanges*/
    16 | $$self.$$.dirty[3] & /*mounted*/
    131072) {
      $: if (mounted) initTimeRanges(timeRanges);
    }
    if ($$self.$$.dirty[2] & /*rowHeight*/
    64) {
      $: set_store_value(_rowHeight, $_rowHeight = rowHeight, $_rowHeight);
    }
    if ($$self.$$.dirty[2] & /*rowPadding*/
    32) {
      $: set_store_value(_rowPadding, $_rowPadding = rowPadding, $_rowPadding);
    }
    if ($$self.$$.dirty[2] & /*from*/
    128) {
      $: set_store_value(_from, $_from = toDateNum(from), $_from);
    }
    if ($$self.$$.dirty[2] & /*to*/
    256) {
      $: set_store_value(_to, $_to = toDateNum(to), $_to);
    }
    if ($$self.$$.dirty[2] & /*minWidth, fitWidth*/
    1536) {
      $: {
        set_store_value(_minWidth, $_minWidth = minWidth, $_minWidth);
        set_store_value(_fitWidth, $_fitWidth = fitWidth, $_fitWidth);
      }
    }
    if ($$self.$$.dirty[2] & /*magnetUnit, magnetOffset*/
    196608) {
      $: setMagnetDuration(magnetUnit, magnetOffset);
    }
    if ($$self.$$.dirty[2] & /*layout*/
    8388608) {
      $: set_store_value(_layout, $_layout = layout, $_layout);
    }
    if ($$self.$$.dirty[0] & /*columnUnit, $_width*/
    65537 | $$self.$$.dirty[2] & /*columnOffset*/
    2 | $$self.$$.dirty[4] & /*$_from, $_to*/
    48) {
      $: {
        $$invalidate(23, columns = getColumnsV2($_from, $_to, columnUnit, columnOffset, $_width));
        tickWithoutCSSTransition();
        refreshTimeRanges();
        refreshTasks();
      }
    }
    if ($$self.$$.dirty[0] & /*offsetHeight, $visibleHeight*/
    34816) {
      $: set_store_value(bottomScrollbarVisible, $bottomScrollbarVisible = offsetHeight - $visibleHeight, $bottomScrollbarVisible);
    }
    if ($$self.$$.dirty[0] & /*offsetWidth, $visibleWidth*/
    132096) {
      $: set_store_value(rightScrollbarVisible, $rightScrollbarVisible = offsetWidth - $visibleWidth, $rightScrollbarVisible);
    }
    if ($$self.$$.dirty[2] & /*reflectOnChildRows, reflectOnParentRows*/
    786432 | $$self.$$.dirty[3] & /*_reflectedTasksCache*/
    4194304 | $$self.$$.dirty[4] & /*$allTasks, $rowStore*/
    10) {
      $: {
        $$invalidate(115, _reflectedTasksCache = {});
        for (const task of $allTasks) {
          const row = $rowStore.entities[task.model.resourceId];
          if (!row) {
            continue;
          }
          if (reflectOnChildRows && row.allChildren) {
            row.allChildren.forEach((r) => {
              const reflectedTask = reflectTask2(task, r);
              if (!_reflectedTasksCache[r.model.id]) {
                $$invalidate(115, _reflectedTasksCache[r.model.id] = [], _reflectedTasksCache);
              }
              _reflectedTasksCache[r.model.id].push(reflectedTask);
            });
          }
          if (reflectOnParentRows && row.allParents) {
            row.allParents.forEach((r) => {
              const reflectedTask = reflectTask2(task, r);
              if (!_reflectedTasksCache[r.model.id]) {
                $$invalidate(115, _reflectedTasksCache[r.model.id] = [], _reflectedTasksCache);
              }
              _reflectedTasksCache[r.model.id].push(reflectedTask);
            });
          }
        }
      }
    }
    if ($$self.$$.dirty[2] & /*rowHeight, rowPadding, layout*/
    8388704 | $$self.$$.dirty[3] & /*refreshLayout, _reflectedTasksCache, invalidatedRows, invalidatedTasks, invalidateFull*/
    542900224 | $$self.$$.dirty[4] & /*$taskStore, $rowStore, $rowTaskCache*/
    7) {
      $: {
        refreshLayout;
        const params = {
          taskStore: $taskStore,
          rowStore: $rowStore,
          rowTasks: $rowTaskCache,
          rowHeight,
          rowPadding,
          rowReflectedTasks: _reflectedTasksCache,
          invalidatedRows,
          invalidatedTasks,
          invalidateFull
        };
        if (layout === "overlap") {
          overlap(params);
        }
        if (layout === "pack") {
          pack(params);
        }
        if (layout === "expand") {
          expand(params);
        }
        $$invalidate(121, layoutChanged = {});
        $$invalidate(113, invalidateFull = false);
        $$invalidate(111, invalidatedTasks = {});
        $$invalidate(112, invalidatedRows = {});
      }
    }
    if ($$self.$$.dirty[0] & /*rowContainerHeight*/
    4096 | $$self.$$.dirty[2] & /*rowHeight*/
    64 | $$self.$$.dirty[3] & /*layoutChanged, $allRows, filteredRows*/
    1350565888) {
      $: {
        $$invalidate(116, filteredRows = []);
        $$invalidate(12, rowContainerHeight = 0);
        layoutChanged;
        const firstRow = $allRows[0];
        for (const row of $allRows) {
          if (!row.hidden) {
            filteredRows.push(row);
            if (firstRow && firstRow.height !== row.height) {
              $$invalidate(117, rowsAreOfSameHeight = false);
            }
            $$invalidate(12, rowContainerHeight += row.height || rowHeight);
          }
        }
      }
    }
    if ($$self.$$.dirty[0] & /*rowContainerHeight*/
    4096 | $$self.$$.dirty[3] & /*rowsAreOfSameHeight, filteredRows, __scrollTop*/
    27262976) {
      $: {
        if (rowsAreOfSameHeight) {
          const rowHeight2 = rowContainerHeight / filteredRows.length;
          $$invalidate(118, startIndex = Math.floor(__scrollTop / rowHeight2));
        } else {
          $$invalidate(118, startIndex = getIndicesOnly(filteredRows, __scrollTop, (row) => row.y)[0]);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*$visibleHeight*/
    32768 | $$self.$$.dirty[2] & /*rowHeight*/
    64 | $$self.$$.dirty[3] & /*rowsAreOfSameHeight, startIndex, filteredRows, __scrollTop*/
    60817408) {
      $: {
        if (rowsAreOfSameHeight) {
          $$invalidate(119, endIndex = Math.min(startIndex + Math.ceil($visibleHeight / rowHeight), filteredRows.length - 1));
        } else {
          $$invalidate(119, endIndex = getIndicesOnly(filteredRows, __scrollTop + $visibleHeight, (row) => row.y)[0]);
        }
      }
    }
    if ($$self.$$.dirty[3] & /*filteredRows, startIndex*/
    41943040) {
      $: {
        $$invalidate(25, paddingTop = filteredRows[startIndex] ? filteredRows[startIndex].y : 0);
      }
    }
    if ($$self.$$.dirty[3] & /*filteredRows, startIndex, endIndex*/
    109051904) {
      $: $$invalidate(13, visibleRows = filteredRows.slice(startIndex, endIndex + 1));
    }
    if ($$self.$$.dirty[0] & /*visibleRows, draggingTasks*/
    24576 | $$self.$$.dirty[3] & /*previousOrder, _reflectedTasksCache*/
    138412032 | $$self.$$.dirty[4] & /*$rowTaskCache, $taskStore*/
    5) {
      $: {
        let tryRestorePosition = function(task) {
          if (!task) return;
          tasks2.push(task);
          const id = task.model.id;
          if (previousOrder[id] != null) {
            tasksOrdered[previousOrder[id]] = task;
          } else {
            ordered = false;
          }
          order[id] = ordinal++;
        };
        const tasks2 = [];
        const rendered = {};
        const tasksOrdered = [];
        const order = {};
        let ordered = true;
        let ordinal = 0;
        for (let i = 0; i < visibleRows.length; i++) {
          const row = visibleRows[i];
          if ($rowTaskCache[row.model.id]) {
            for (let j = 0; j < $rowTaskCache[row.model.id].length; j++) {
              const id = $rowTaskCache[row.model.id][j];
              rendered[id] = true;
              tryRestorePosition($taskStore.entities[id]);
            }
          }
          if (_reflectedTasksCache[row.model.id]) {
            for (const task of _reflectedTasksCache[row.model.id]) {
              tryRestorePosition(task);
            }
          }
        }
        for (const id in draggingTasks) {
          if (!rendered[id]) {
            rendered[id] = true;
            tryRestorePosition($taskStore.entities[id]);
          }
        }
        if (tasksOrdered.length !== tasks2.length) {
          ordered = false;
        }
        $$invalidate(120, previousOrder = ordered ? previousOrder : order);
        $$invalidate(26, visibleTasks = ordered ? tasksOrdered : tasks2);
      }
    }
    if ($$self.$$.dirty[2] & /*layout, tasks, rows*/
    8388620) {
      $: {
        layout;
        tasks;
        rows;
        updateLayout();
      }
    }
  };
  return [
    columnUnit,
    headers,
    tableWidth,
    classes,
    ganttTableModules,
    ganttBodyModules,
    useCanvasColumns,
    columnStrokeColor,
    columnStrokeWidth,
    enableCreateTask,
    offsetWidth,
    offsetHeight,
    rowContainerHeight,
    visibleRows,
    draggingTasks,
    $visibleHeight,
    $_width,
    $visibleWidth,
    ganttElement,
    mainHeaderContainer,
    mainContainer,
    rowContainer,
    disableTransition,
    columns,
    zooming,
    paddingTop,
    visibleTasks,
    $rightScrollbarVisible,
    $headerHeight,
    $allTimeRanges,
    _rowHeight,
    _rowPadding,
    _from,
    _to,
    _minWidth,
    _fitWidth,
    _layout,
    visibleWidth,
    visibleHeight,
    headerHeight,
    _width,
    rowStore,
    taskStore,
    allTasks,
    allRows,
    allTimeRanges,
    rowTaskCache,
    bottomScrollbarVisible,
    rightScrollbarVisible,
    hoveredRow,
    selectedRow,
    onEvent,
    scrollable,
    horizontalScrollListener,
    onResize,
    onwheel,
    onDateSelected,
    onCreateTaskMove,
    onCreateTaskEnd,
    dragCreateTasks,
    onChange,
    onItemsChange,
    $$restProps,
    columnOffset,
    rows,
    tasks,
    timeRanges,
    rowPadding,
    rowHeight,
    from,
    to,
    minWidth,
    fitWidth,
    zoomLevels,
    taskContent,
    resizeHandleWidth,
    onTaskButtonClick,
    dateAdapter,
    magnetUnit,
    magnetOffset,
    reflectOnParentRows,
    reflectOnChildRows,
    highlightedDurations,
    highlightColor,
    taskElementHook,
    layout,
    columnService,
    api,
    timeRangeFactory,
    utils,
    refreshTimeRanges,
    refreshTasks,
    getRowContainer,
    selectTask,
    unselectTasks,
    scrollToRow,
    scrollToTask,
    updateTask,
    updateTasks,
    removeTask,
    removeTasks,
    updateRow,
    updateRows,
    getRow,
    getTask,
    getTasks,
    updateLayoutSync,
    updateLayout,
    onCreateTask,
    onCreatedTask,
    mounted,
    invalidatedTasks,
    invalidatedRows,
    invalidateFull,
    __scrollTop,
    _reflectedTasksCache,
    filteredRows,
    rowsAreOfSameHeight,
    startIndex,
    endIndex,
    previousOrder,
    layoutChanged,
    refreshLayout,
    $allRows,
    $rowTaskCache,
    $rowStore,
    $taskStore,
    $allTasks,
    $_to,
    $_from,
    div2_binding,
    div2_elementresize_handler,
    div4_binding,
    div7_binding,
    div7_elementresize_handler,
    div9_binding
  ];
}
var Gantt = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance11,
      create_fragment11,
      safe_not_equal,
      {
        rows: 64,
        tasks: 65,
        timeRanges: 66,
        rowPadding: 67,
        rowHeight: 68,
        from: 69,
        to: 70,
        minWidth: 71,
        fitWidth: 72,
        classes: 3,
        headers: 1,
        zoomLevels: 73,
        taskContent: 74,
        tableWidth: 2,
        resizeHandleWidth: 75,
        onTaskButtonClick: 76,
        dateAdapter: 77,
        magnetUnit: 78,
        magnetOffset: 79,
        columnUnit: 0,
        columnOffset: 63,
        ganttTableModules: 4,
        ganttBodyModules: 5,
        reflectOnParentRows: 80,
        reflectOnChildRows: 81,
        useCanvasColumns: 6,
        columnStrokeColor: 7,
        columnStrokeWidth: 8,
        highlightedDurations: 82,
        highlightColor: 83,
        taskElementHook: 84,
        layout: 85,
        columnService: 86,
        api: 87,
        timeRangeFactory: 88,
        utils: 89,
        refreshTimeRanges: 90,
        refreshTasks: 91,
        getRowContainer: 92,
        selectTask: 93,
        unselectTasks: 94,
        scrollToRow: 95,
        scrollToTask: 96,
        updateTask: 97,
        updateTasks: 98,
        removeTask: 99,
        removeTasks: 100,
        updateRow: 101,
        updateRows: 102,
        getRow: 103,
        getTask: 104,
        getTasks: 105,
        updateLayoutSync: 106,
        updateLayout: 107,
        enableCreateTask: 9,
        onCreateTask: 108,
        onCreatedTask: 109
      },
      add_css8,
      [-1, -1, -1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Gantt",
      options,
      id: create_fragment11.name
    });
  }
  get rows() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rows(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tasks() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tasks(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get timeRanges() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set timeRanges(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rowPadding() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rowPadding(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rowHeight() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rowHeight(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get from() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set from(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get to() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set to(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minWidth() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minWidth(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fitWidth() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fitWidth(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classes() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classes(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headers() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headers(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomLevels() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomLevels(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get taskContent() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set taskContent(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tableWidth() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tableWidth(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizeHandleWidth() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizeHandleWidth(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTaskButtonClick() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTaskButtonClick(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dateAdapter() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dateAdapter(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get magnetUnit() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set magnetUnit(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get magnetOffset() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set magnetOffset(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get columnUnit() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set columnUnit(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get columnOffset() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set columnOffset(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ganttTableModules() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ganttTableModules(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ganttBodyModules() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ganttBodyModules(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reflectOnParentRows() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reflectOnParentRows(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reflectOnChildRows() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reflectOnChildRows(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useCanvasColumns() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useCanvasColumns(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get columnStrokeColor() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set columnStrokeColor(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get columnStrokeWidth() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set columnStrokeWidth(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get highlightedDurations() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set highlightedDurations(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get highlightColor() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set highlightColor(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get taskElementHook() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set taskElementHook(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get layout() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set layout(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get columnService() {
    return this.$$.ctx[86];
  }
  set columnService(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get api() {
    return this.$$.ctx[87];
  }
  set api(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get timeRangeFactory() {
    return this.$$.ctx[88];
  }
  set timeRangeFactory(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get utils() {
    return this.$$.ctx[89];
  }
  set utils(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get refreshTimeRanges() {
    return this.$$.ctx[90];
  }
  set refreshTimeRanges(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get refreshTasks() {
    return this.$$.ctx[91];
  }
  set refreshTasks(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getRowContainer() {
    return this.$$.ctx[92];
  }
  set getRowContainer(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectTask() {
    return this.$$.ctx[93];
  }
  set selectTask(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get unselectTasks() {
    return this.$$.ctx[94];
  }
  set unselectTasks(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollToRow() {
    return this.$$.ctx[95];
  }
  set scrollToRow(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollToTask() {
    return this.$$.ctx[96];
  }
  set scrollToTask(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateTask() {
    return this.$$.ctx[97];
  }
  set updateTask(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateTasks() {
    return this.$$.ctx[98];
  }
  set updateTasks(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get removeTask() {
    return this.$$.ctx[99];
  }
  set removeTask(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get removeTasks() {
    return this.$$.ctx[100];
  }
  set removeTasks(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateRow() {
    return this.$$.ctx[101];
  }
  set updateRow(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateRows() {
    return this.$$.ctx[102];
  }
  set updateRows(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getRow() {
    return this.$$.ctx[103];
  }
  set getRow(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getTask() {
    return this.$$.ctx[104];
  }
  set getTask(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getTasks() {
    return this.$$.ctx[105];
  }
  set getTasks(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateLayoutSync() {
    return this.$$.ctx[106];
  }
  set updateLayoutSync(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateLayout() {
    return this.$$.ctx[107];
  }
  set updateLayout(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enableCreateTask() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enableCreateTask(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onCreateTask() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onCreateTask(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onCreatedTask() {
    throw new Error_1("<Gantt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onCreatedTask(value) {
    throw new Error_1("<Gantt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Gantt_default = Gantt;

// node_modules/svelte-gantt/svelte/modules/table/TableTreeCell.svelte
var file9 = "node_modules\\svelte-gantt\\svelte\\modules\\table\\TableTreeCell.svelte";
function add_css9(target) {
  append_styles(target, "svelte-hdnrvp", ".sg-tree-expander.svelte-hdnrvp{cursor:pointer;min-width:1.4em;display:flex;justify-content:center;align-items:center}.sg-cell-inner.svelte-hdnrvp{display:flex}.sg-tree-icon.svelte-hdnrvp{width:1rem;height:1rem}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFibGVUcmVlQ2VsbC5zdmVsdGUiLCJzb3VyY2VzIjpbIlRhYmxlVHJlZUNlbGwuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+aW1wb3J0IHsgd2hlbkVudGVyUHJlc3MgfSBmcm9tICcuLi8uLi91dGlscy9kb20nO1xuaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnc3ZlbHRlJztcbmV4cG9ydCBsZXQgcm93O1xuZXhwb3J0IGxldCBleHBhbmRJY29uSHRtbCA9IG51bGw7XG5leHBvcnQgbGV0IGNvbGxhcHNlSWNvbkh0bWwgPSBudWxsO1xuY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcbmZ1bmN0aW9uIG9uRXhwYW5kVG9nZ2xlKCkge1xuICAgIGlmIChyb3cubW9kZWwuZXhwYW5kZWQgfHwgcm93Lm1vZGVsLmV4cGFuZGVkID09IG51bGwpIHtcbiAgICAgICAgZGlzcGF0Y2goJ3Jvd0NvbGxhcHNlZCcsIHsgcm93IH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGlzcGF0Y2goJ3Jvd0V4cGFuZGVkJywgeyByb3cgfSk7XG4gICAgfVxufVxuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJzZy1jZWxsLWlubmVyXCIgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6IHtyb3cuY2hpbGRMZXZlbCAqIDN9ZW1cIj5cbiAgICB7I2lmIHJvdy5jaGlsZHJlbn1cbiAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3M9XCJzZy10cmVlLWV4cGFuZGVyXCJcbiAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgIG9uOmNsaWNrPXtvbkV4cGFuZFRvZ2dsZX1cbiAgICAgICAgICAgIG9uOmtleWRvd249e3doZW5FbnRlclByZXNzKG9uRXhwYW5kVG9nZ2xlKX1cbiAgICAgICAgPlxuICAgICAgICAgICAgeyNpZiByb3cubW9kZWwuZXhwYW5kZWR9XG4gICAgICAgICAgICAgICAgeyNpZiBleHBhbmRJY29uSHRtbH1cbiAgICAgICAgICAgICAgICAgICAge0BodG1sIGV4cGFuZEljb25IdG1sfVxuICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiMS41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJzZy10cmVlLWljb25cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJtMTkuNSA4LjI1LTcuNSA3LjUtNy41LTcuNVwiIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgeyNpZiBjb2xsYXBzZUljb25IdG1sfVxuICAgICAgICAgICAgICAgICAgICB7QGh0bWwgY29sbGFwc2VJY29uSHRtbH1cbiAgICAgICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwic2ctdHJlZS1pY29uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwibTguMjUgNC41IDcuNSA3LjUtNy41IDcuNVwiIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICA8L2Rpdj5cbiAgICB7L2lmfVxuICAgIDxzbG90IC8+XG48L2Rpdj5cblxuPHN0eWxlPlxuICAgIC5zZy10cmVlLWV4cGFuZGVyIHtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBtaW4td2lkdGg6IDEuNGVtO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICB9XG5cbiAgICAuc2ctY2VsbC1pbm5lciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgfVxuXG4gICAgLnNnLXRyZWUtaWNvbiB7XG4gICAgICAgIHdpZHRoOiAxcmVtO1xuICAgICAgICBoZWlnaHQ6IDFyZW07XG4gICAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFnREksK0JBQWtCLENBQ2QsTUFBTSxDQUFFLE9BQU8sQ0FDZixTQUFTLENBQUUsS0FBSyxDQUNoQixPQUFPLENBQUUsSUFBSSxDQUNiLGVBQWUsQ0FBRSxNQUFNLENBQ3ZCLFdBQVcsQ0FBRSxNQUNqQixDQUVBLDRCQUFlLENBQ1gsT0FBTyxDQUFFLElBQ2IsQ0FFQSwyQkFBYyxDQUNWLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQ1oifQ== */");
}
function create_if_block5(ctx) {
  let div;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*row*/
      ctx2[0].model.expanded
    ) return create_if_block_12;
    if (
      /*collapseIconHtml*/
      ctx2[2]
    ) return create_if_block_32;
    return create_else_block_1;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      attr_dev(div, "class", "sg-tree-expander svelte-hdnrvp");
      attr_dev(div, "role", "button");
      attr_dev(div, "tabindex", "0");
      add_location(div, file9, 18, 8, 547);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if_block.m(div, null);
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*onExpandToggle*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(div, "keydown", whenEnterPress(
            /*onExpandToggle*/
            ctx[3]
          ), false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(18:4) {#if row.children}",
    ctx
  });
  return block;
}
function create_else_block_1(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr_dev(path, "stroke-linecap", "round");
      attr_dev(path, "stroke-linejoin", "round");
      attr_dev(path, "d", "m8.25 4.5 7.5 7.5-7.5 7.5");
      add_location(path, file9, 38, 24, 1507);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke-width", "1.5");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(svg, "class", "sg-tree-icon svelte-hdnrvp");
      add_location(svg, file9, 37, 20, 1348);
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(37:16) {:else}",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let html_tag;
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(
        /*collapseIconHtml*/
        ctx[2],
        target,
        anchor
      );
      insert_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*collapseIconHtml*/
      4) html_tag.p(
        /*collapseIconHtml*/
        ctx2[2]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(35:16) {#if collapseIconHtml}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*expandIconHtml*/
      ctx2[1]
    ) return create_if_block_22;
    return create_else_block3;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(26:12) {#if row.model.expanded}",
    ctx
  });
  return block;
}
function create_else_block3(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr_dev(path, "stroke-linecap", "round");
      attr_dev(path, "stroke-linejoin", "round");
      attr_dev(path, "d", "m19.5 8.25-7.5 7.5-7.5-7.5");
      add_location(path, file9, 30, 24, 1064);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke-width", "1.5");
      attr_dev(svg, "stroke", "currentColor");
      attr_dev(svg, "class", "sg-tree-icon svelte-hdnrvp");
      add_location(svg, file9, 29, 20, 905);
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(29:16) {:else}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let html_tag;
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(
        /*expandIconHtml*/
        ctx[1],
        target,
        anchor
      );
      insert_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*expandIconHtml*/
      2) html_tag.p(
        /*expandIconHtml*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(27:16) {#if expandIconHtml}",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let div;
  let t;
  let current;
  let if_block = (
    /*row*/
    ctx[0].children && create_if_block5(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block) if_block.c();
      t = space();
      if (default_slot) default_slot.c();
      attr_dev(div, "class", "sg-cell-inner svelte-hdnrvp");
      set_style(
        div,
        "padding-left",
        /*row*/
        ctx[0].childLevel * 3 + "em"
      );
      add_location(div, file9, 16, 0, 443);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block) if_block.m(div, null);
      append_dev(div, t);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*row*/
        ctx2[0].children
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*row*/
      1) {
        set_style(
          div,
          "padding-left",
          /*row*/
          ctx2[0].childLevel * 3 + "em"
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block) if_block.d();
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableTreeCell", slots, ["default"]);
  let { row } = $$props;
  let { expandIconHtml = null } = $$props;
  let { collapseIconHtml = null } = $$props;
  const dispatch = createEventDispatcher();
  function onExpandToggle() {
    if (row.model.expanded || row.model.expanded == null) {
      dispatch("rowCollapsed", { row });
    } else {
      dispatch("rowExpanded", { row });
    }
  }
  $$self.$$.on_mount.push(function() {
    if (row === void 0 && !("row" in $$props || $$self.$$.bound[$$self.$$.props["row"]])) {
      console.warn("<TableTreeCell> was created without expected prop 'row'");
    }
  });
  const writable_props = ["row", "expandIconHtml", "collapseIconHtml"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<TableTreeCell> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("row" in $$props2) $$invalidate(0, row = $$props2.row);
    if ("expandIconHtml" in $$props2) $$invalidate(1, expandIconHtml = $$props2.expandIconHtml);
    if ("collapseIconHtml" in $$props2) $$invalidate(2, collapseIconHtml = $$props2.collapseIconHtml);
    if ("$$scope" in $$props2) $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    whenEnterPress,
    createEventDispatcher,
    row,
    expandIconHtml,
    collapseIconHtml,
    dispatch,
    onExpandToggle
  });
  $$self.$inject_state = ($$props2) => {
    if ("row" in $$props2) $$invalidate(0, row = $$props2.row);
    if ("expandIconHtml" in $$props2) $$invalidate(1, expandIconHtml = $$props2.expandIconHtml);
    if ("collapseIconHtml" in $$props2) $$invalidate(2, collapseIconHtml = $$props2.collapseIconHtml);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [row, expandIconHtml, collapseIconHtml, onExpandToggle, $$scope, slots];
}
var TableTreeCell = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance12,
      create_fragment12,
      safe_not_equal,
      {
        row: 0,
        expandIconHtml: 1,
        collapseIconHtml: 2
      },
      add_css9
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableTreeCell",
      options,
      id: create_fragment12.name
    });
  }
  get row() {
    throw new Error("<TableTreeCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set row(value) {
    throw new Error("<TableTreeCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandIconHtml() {
    throw new Error("<TableTreeCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandIconHtml(value) {
    throw new Error("<TableTreeCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get collapseIconHtml() {
    throw new Error("<TableTreeCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set collapseIconHtml(value) {
    throw new Error("<TableTreeCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TableTreeCell_default = TableTreeCell;

// node_modules/svelte-gantt/svelte/modules/table/TableRow.svelte
var file10 = "node_modules\\svelte-gantt\\svelte\\modules\\table\\TableRow.svelte";
function add_css10(target) {
  append_styles(target, "svelte-13of3p9", ".sg-table-row.svelte-13of3p9.svelte-13of3p9{display:inline-flex;min-width:100%;align-items:stretch;position:relative;font-weight:400;font-size:14px;transition:height 0.2s}.sg-table-cell.svelte-13of3p9.svelte-13of3p9{border-right:1px solid var(--sg-table-cell-border-color)}.sg-table-cell.svelte-13of3p9.svelte-13of3p9:last-child{border-right:0}.sg-table-body-cell.svelte-13of3p9.svelte-13of3p9{border-bottom:1px solid var(--sg-table-cell-border-color);font-weight:bold}.sg-table-row.svelte-13of3p9:last-child>.sg-table-body-cell.svelte-13of3p9{border-bottom:0}.sg-resource-image.svelte-13of3p9.svelte-13of3p9{width:2.4em;height:2.4em;border-radius:50%;margin-right:0.6em;background:#047c69}.sg-resource-info.svelte-13of3p9.svelte-13of3p9{flex:1;height:100%;display:flex;flex-direction:row;align-items:center}.sg-table-icon.svelte-13of3p9.svelte-13of3p9{margin-right:0.5em}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFibGVSb3cuc3ZlbHRlIiwic291cmNlcyI6WyJUYWJsZVJvdy5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5pbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcbmltcG9ydCBUYWJsZVRyZWVDZWxsIGZyb20gJy4vVGFibGVUcmVlQ2VsbC5zdmVsdGUnO1xuaW1wb3J0IHsgbm9ybWFsaXplQ2xhc3NBdHRyIH0gZnJvbSAnLi4vLi4vdXRpbHMvZG9tJztcbmV4cG9ydCBsZXQgaGVhZGVycyA9IG51bGw7XG5leHBvcnQgbGV0IHJvdyA9IG51bGw7XG5jb25zdCB7IGhvdmVyZWRSb3csIHNlbGVjdGVkUm93IH0gPSBnZXRDb250ZXh0KCdnYW50dCcpO1xubGV0IHRyZWVJbmRlbnRhdGlvblN0eWxlID0gJyc7XG4kOiB7XG4gICAgdHJlZUluZGVudGF0aW9uU3R5bGUgPSByb3cucGFyZW50ID8gYHBhZGRpbmctbGVmdDogJHtyb3cuY2hpbGRMZXZlbCAqIDN9ZW07YCA6ICcnO1xufVxuJDogY2xhc3NlcyA9IG5vcm1hbGl6ZUNsYXNzQXR0cihyb3cubW9kZWwuY2xhc3Nlcyk7XG48L3NjcmlwdD5cblxuPGRpdlxuICAgIGRhdGEtcm93LWlkPXtyb3cubW9kZWwuaWR9XG4gICAgc3R5bGU9XCJoZWlnaHQ6e3Jvdy5oZWlnaHR9cHhcIlxuICAgIGNsYXNzPVwic2ctdGFibGUtcm93IHtjbGFzc2VzfSBzZy10YWJsZS1yb3ctbGV2ZWwte3Jvdy5jaGlsZExldmVsfVwiXG4gICAgY2xhc3M6c2ctcm93LWV4cGFuZGVkPXtyb3cubW9kZWwuZXhwYW5kZWR9XG4gICAgY2xhc3M6c2ctaG92ZXI9eyRob3ZlcmVkUm93ID09IHJvdy5tb2RlbC5pZH1cbiAgICBjbGFzczpzZy1zZWxlY3RlZD17JHNlbGVjdGVkUm93ID09IHJvdy5tb2RlbC5pZH1cbj5cbiAgICB7I2VhY2ggaGVhZGVycyBhcyBoZWFkZXJ9XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzZy10YWJsZS1ib2R5LWNlbGwgc2ctdGFibGUtY2VsbFwiIHN0eWxlPVwid2lkdGg6e2hlYWRlci53aWR0aH1weFwiPlxuICAgICAgICAgICAgeyNpZiBoZWFkZXIudHlwZSA9PSAndHJlZSd9XG4gICAgICAgICAgICAgICAgPFRhYmxlVHJlZUNlbGwgb246cm93Q29sbGFwc2VkIG9uOnJvd0V4cGFuZGVkIHtyb3d9PlxuICAgICAgICAgICAgICAgICAgICB7I2lmIHJvdy5tb2RlbC5pY29uQ2xhc3N9XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic2ctdGFibGUtaWNvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPXtyb3cubW9kZWwuaWNvbkNsYXNzfT48L2k+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgey9pZn1cblxuICAgICAgICAgICAgICAgICAgICB7I2lmIHJvdy5tb2RlbC5oZWFkZXJIdG1sfVxuICAgICAgICAgICAgICAgICAgICAgICAge0BodG1sIHJvdy5tb2RlbC5oZWFkZXJIdG1sfVxuICAgICAgICAgICAgICAgICAgICB7OmVsc2UgaWYgaGVhZGVyLnJlbmRlcmVyfVxuICAgICAgICAgICAgICAgICAgICAgICAge0BodG1sIGhlYWRlci5yZW5kZXJlcihyb3cpfVxuICAgICAgICAgICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICB7cm93Lm1vZGVsW2hlYWRlci5wcm9wZXJ0eV19XG4gICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgPC9UYWJsZVRyZWVDZWxsPlxuICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgIHsjaWYgcm93Lm1vZGVsLmljb25DbGFzc31cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNnLXRhYmxlLWljb25cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPXtyb3cubW9kZWwuaWNvbkNsYXNzfT48L2k+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIHsvaWZ9XG5cbiAgICAgICAgICAgICAgICB7I2lmIHJvdy5tb2RlbC5oZWFkZXJIdG1sfVxuICAgICAgICAgICAgICAgICAgICB7QGh0bWwgcm93Lm1vZGVsLmhlYWRlckh0bWx9XG4gICAgICAgICAgICAgICAgezplbHNlIGlmIGhlYWRlci5yZW5kZXJlcn1cbiAgICAgICAgICAgICAgICAgICAge0BodG1sIGhlYWRlci5yZW5kZXJlcihyb3cpfVxuICAgICAgICAgICAgICAgIHs6ZWxzZSBpZiBoZWFkZXIudHlwZSA9PT0gJ3Jlc291cmNlSW5mbyd9XG4gICAgICAgICAgICAgICAgICAgIDxpbWcgY2xhc3M9XCJzZy1yZXNvdXJjZS1pbWFnZVwiIHNyYz17cm93Lm1vZGVsLmltYWdlU3JjfSBhbHQ9XCJcIiAvPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic2ctcmVzb3VyY2UtdGl0bGVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtyb3cubW9kZWxbaGVhZGVyLnByb3BlcnR5XX1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICB7cm93Lm1vZGVsW2hlYWRlci5wcm9wZXJ0eV19XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgIDwvZGl2PlxuICAgIHsvZWFjaH1cbjwvZGl2PlxuXG48c3R5bGU+XG4gICAgLnNnLXRhYmxlLXJvdyB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgICBtaW4td2lkdGg6IDEwMCU7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcblxuICAgICAgICBmb250LXdlaWdodDogNDAwO1xuICAgICAgICBmb250LXNpemU6IDE0cHg7ICBcbiAgICAgICAgdHJhbnNpdGlvbjogaGVpZ2h0IDAuMnM7XG4gICAgfVxuXG4gICAgLnNnLXRhYmxlLWNlbGwge1xuICAgICAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCB2YXIoLS1zZy10YWJsZS1jZWxsLWJvcmRlci1jb2xvcik7XG4gICAgfVxuXG4gICAgLnNnLXRhYmxlLWNlbGw6bGFzdC1jaGlsZCB7XG4gICAgICAgIGJvcmRlci1yaWdodDogMDtcbiAgICB9XG5cbiAgICAuc2ctdGFibGUtYm9keS1jZWxsIHtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHZhcigtLXNnLXRhYmxlLWNlbGwtYm9yZGVyLWNvbG9yKTtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgfVxuXG4gICAgLnNnLXRhYmxlLXJvdzpsYXN0LWNoaWxkID4gLnNnLXRhYmxlLWJvZHktY2VsbCB7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDA7XG4gICAgfVxuXG4gICAgLnNnLXJlc291cmNlLWltYWdlIHtcbiAgICAgICAgd2lkdGg6IDIuNGVtO1xuICAgICAgICBoZWlnaHQ6IDIuNGVtO1xuICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICAgIG1hcmdpbi1yaWdodDogMC42ZW07XG5cbiAgICAgICAgYmFja2dyb3VuZDogIzA0N2M2OTtcbiAgICB9XG5cbiAgICAuc2ctcmVzb3VyY2UtaW5mbyB7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICB9XG5cbiAgICAuc2ctdGFibGUtaWNvbiB7XG4gICAgICAgIG1hcmdpbi1yaWdodDogMC41ZW07XG4gICAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFnRUksMkNBQWMsQ0FDVixPQUFPLENBQUUsV0FBVyxDQUNwQixTQUFTLENBQUUsSUFBSSxDQUNmLFdBQVcsQ0FBRSxPQUFPLENBRXBCLFFBQVEsQ0FBRSxRQUFRLENBRWxCLFdBQVcsQ0FBRSxHQUFHLENBQ2hCLFNBQVMsQ0FBRSxJQUFJLENBQ2YsVUFBVSxDQUFFLE1BQU0sQ0FBQyxJQUN2QixDQUVBLDRDQUFlLENBQ1gsWUFBWSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSw0QkFBNEIsQ0FDNUQsQ0FFQSw0Q0FBYyxXQUFZLENBQ3RCLFlBQVksQ0FBRSxDQUNsQixDQUVBLGlEQUFvQixDQUNoQixhQUFhLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLDRCQUE0QixDQUFDLENBQzFELFdBQVcsQ0FBRSxJQUNqQixDQUVBLDRCQUFhLFdBQVcsQ0FBRyxrQ0FBb0IsQ0FDM0MsYUFBYSxDQUFFLENBQ25CLENBRUEsZ0RBQW1CLENBQ2YsS0FBSyxDQUFFLEtBQUssQ0FDWixNQUFNLENBQUUsS0FBSyxDQUNiLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLFlBQVksQ0FBRSxLQUFLLENBRW5CLFVBQVUsQ0FBRSxPQUNoQixDQUVBLCtDQUFrQixDQUNkLElBQUksQ0FBRSxDQUFDLENBQ1AsTUFBTSxDQUFFLElBQUksQ0FDWixPQUFPLENBQUUsSUFBSSxDQUNiLGNBQWMsQ0FBRSxHQUFHLENBQ25CLFdBQVcsQ0FBRSxNQUNqQixDQUVBLDRDQUFlLENBQ1gsWUFBWSxDQUFFLEtBQ2xCIn0= */");
}
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function create_else_block_12(ctx) {
  let t;
  let if_block1_anchor;
  let if_block0 = (
    /*row*/
    ctx[1].model.iconClass && create_if_block_7(ctx)
  );
  function select_block_type_2(ctx2, dirty) {
    if (
      /*row*/
      ctx2[1].model.headerHtml
    ) return create_if_block_42;
    if (
      /*header*/
      ctx2[10].renderer
    ) return create_if_block_52;
    if (
      /*header*/
      ctx2[10].type === "resourceInfo"
    ) return create_if_block_6;
    return create_else_block_2;
  }
  let current_block_type = select_block_type_2(ctx, -1);
  let if_block1 = current_block_type(ctx);
  const block = {
    c: function create() {
      if (if_block0) if_block0.c();
      t = space();
      if_block1.c();
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert_dev(target, t, anchor);
      if_block1.m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*row*/
        ctx2[1].model.iconClass
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_7(ctx2);
          if_block0.c();
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type_2(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block1_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_12.name,
    type: "else",
    source: "(40:12) {:else}",
    ctx
  });
  return block;
}
function create_if_block6(ctx) {
  let tabletreecell;
  let current;
  tabletreecell = new TableTreeCell_default({
    props: {
      row: (
        /*row*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tabletreecell.$on(
    "rowCollapsed",
    /*rowCollapsed_handler*/
    ctx[7]
  );
  tabletreecell.$on(
    "rowExpanded",
    /*rowExpanded_handler*/
    ctx[8]
  );
  const block = {
    c: function create() {
      create_component(tabletreecell.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(tabletreecell, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tabletreecell_changes = {};
      if (dirty & /*row*/
      2) tabletreecell_changes.row = /*row*/
      ctx2[1];
      if (dirty & /*$$scope, row, headers*/
      8195) {
        tabletreecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabletreecell.$set(tabletreecell_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(tabletreecell.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabletreecell.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tabletreecell, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(24:12) {#if header.type == 'tree'}",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let div;
  let i;
  let i_class_value;
  const block = {
    c: function create() {
      div = element("div");
      i = element("i");
      attr_dev(i, "class", i_class_value = null_to_empty(
        /*row*/
        ctx[1].model.iconClass
      ) + " svelte-13of3p9");
      add_location(i, file10, 42, 24, 1657);
      attr_dev(div, "class", "sg-table-icon svelte-13of3p9");
      add_location(div, file10, 41, 20, 1605);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, i);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*row*/
      2 && i_class_value !== (i_class_value = null_to_empty(
        /*row*/
        ctx2[1].model.iconClass
      ) + " svelte-13of3p9")) {
        attr_dev(i, "class", i_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(41:16) {#if row.model.iconClass}",
    ctx
  });
  return block;
}
function create_else_block_2(ctx) {
  let t_value = (
    /*row*/
    ctx[1].model[
      /*header*/
      ctx[10].property
    ] + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*row, headers*/
      3 && t_value !== (t_value = /*row*/
      ctx2[1].model[
        /*header*/
        ctx2[10].property
      ] + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_2.name,
    type: "else",
    source: "(56:16) {:else}",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let img;
  let img_src_value;
  let t0;
  let div;
  let t1_value = (
    /*row*/
    ctx[1].model[
      /*header*/
      ctx[10].property
    ] + ""
  );
  let t1;
  const block = {
    c: function create() {
      img = element("img");
      t0 = space();
      div = element("div");
      t1 = text(t1_value);
      attr_dev(img, "class", "sg-resource-image svelte-13of3p9");
      if (!src_url_equal(img.src, img_src_value = /*row*/
      ctx[1].model.imageSrc)) attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "");
      add_location(img, file10, 51, 20, 2005);
      attr_dev(div, "class", "sg-resource-title");
      add_location(div, file10, 52, 20, 2091);
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
      insert_dev(target, t0, anchor);
      insert_dev(target, div, anchor);
      append_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*row*/
      2 && !src_url_equal(img.src, img_src_value = /*row*/
      ctx2[1].model.imageSrc)) {
        attr_dev(img, "src", img_src_value);
      }
      if (dirty & /*row, headers*/
      3 && t1_value !== (t1_value = /*row*/
      ctx2[1].model[
        /*header*/
        ctx2[10].property
      ] + "")) set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(img);
        detach_dev(t0);
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(51:57) ",
    ctx
  });
  return block;
}
function create_if_block_52(ctx) {
  let html_tag;
  let raw_value = (
    /*header*/
    ctx[10].renderer(
      /*row*/
      ctx[1]
    ) + ""
  );
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*headers, row*/
      3 && raw_value !== (raw_value = /*header*/
      ctx2[10].renderer(
        /*row*/
        ctx2[1]
      ) + "")) html_tag.p(raw_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_52.name,
    type: "if",
    source: "(49:42) ",
    ctx
  });
  return block;
}
function create_if_block_42(ctx) {
  let html_tag;
  let raw_value = (
    /*row*/
    ctx[1].model.headerHtml + ""
  );
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*row*/
      2 && raw_value !== (raw_value = /*row*/
      ctx2[1].model.headerHtml + "")) html_tag.p(raw_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_42.name,
    type: "if",
    source: "(47:16) {#if row.model.headerHtml}",
    ctx
  });
  return block;
}
function create_if_block_33(ctx) {
  let div;
  let i;
  let i_class_value;
  const block = {
    c: function create() {
      div = element("div");
      i = element("i");
      attr_dev(i, "class", i_class_value = null_to_empty(
        /*row*/
        ctx[1].model.iconClass
      ) + " svelte-13of3p9");
      add_location(i, file10, 27, 28, 1089);
      attr_dev(div, "class", "sg-table-icon svelte-13of3p9");
      add_location(div, file10, 26, 24, 1033);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, i);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*row*/
      2 && i_class_value !== (i_class_value = null_to_empty(
        /*row*/
        ctx2[1].model.iconClass
      ) + " svelte-13of3p9")) {
        attr_dev(i, "class", i_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_33.name,
    type: "if",
    source: "(26:20) {#if row.model.iconClass}",
    ctx
  });
  return block;
}
function create_else_block4(ctx) {
  let t_value = (
    /*row*/
    ctx[1].model[
      /*header*/
      ctx[10].property
    ] + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*row, headers*/
      3 && t_value !== (t_value = /*row*/
      ctx2[1].model[
        /*header*/
        ctx2[10].property
      ] + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(36:20) {:else}",
    ctx
  });
  return block;
}
function create_if_block_23(ctx) {
  let html_tag;
  let raw_value = (
    /*header*/
    ctx[10].renderer(
      /*row*/
      ctx[1]
    ) + ""
  );
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*headers, row*/
      3 && raw_value !== (raw_value = /*header*/
      ctx2[10].renderer(
        /*row*/
        ctx2[1]
      ) + "")) html_tag.p(raw_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_23.name,
    type: "if",
    source: "(34:46) ",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let html_tag;
  let raw_value = (
    /*row*/
    ctx[1].model.headerHtml + ""
  );
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*row*/
      2 && raw_value !== (raw_value = /*row*/
      ctx2[1].model.headerHtml + "")) html_tag.p(raw_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(32:20) {#if row.model.headerHtml}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let t;
  let if_block1_anchor;
  let if_block0 = (
    /*row*/
    ctx[1].model.iconClass && create_if_block_33(ctx)
  );
  function select_block_type_1(ctx2, dirty) {
    if (
      /*row*/
      ctx2[1].model.headerHtml
    ) return create_if_block_13;
    if (
      /*header*/
      ctx2[10].renderer
    ) return create_if_block_23;
    return create_else_block4;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block1 = current_block_type(ctx);
  const block = {
    c: function create() {
      if (if_block0) if_block0.c();
      t = space();
      if_block1.c();
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert_dev(target, t, anchor);
      if_block1.m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*row*/
        ctx2[1].model.iconClass
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_33(ctx2);
          if_block0.c();
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block1_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(25:16) <TableTreeCell on:rowCollapsed on:rowExpanded {row}>",
    ctx
  });
  return block;
}
function create_each_block5(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let t;
  let current;
  const if_block_creators = [create_if_block6, create_else_block_12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*header*/
      ctx2[10].type == "tree"
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      t = space();
      attr_dev(div, "class", "sg-table-body-cell sg-table-cell svelte-13of3p9");
      set_style(
        div,
        "width",
        /*header*/
        ctx[10].width + "px"
      );
      add_location(div, file10, 22, 8, 776);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append_dev(div, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, t);
      }
      if (!current || dirty & /*headers*/
      1) {
        set_style(
          div,
          "width",
          /*header*/
          ctx2[10].width + "px"
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(22:4) {#each headers as header}",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let div;
  let div_data_row_id_value;
  let div_class_value;
  let current;
  let each_value = ensure_array_like_dev(
    /*headers*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "data-row-id", div_data_row_id_value = /*row*/
      ctx[1].model.id);
      set_style(
        div,
        "height",
        /*row*/
        ctx[1].height + "px"
      );
      attr_dev(div, "class", div_class_value = "sg-table-row " + /*classes*/
      ctx[2] + " sg-table-row-level-" + /*row*/
      ctx[1].childLevel + " svelte-13of3p9");
      toggle_class(
        div,
        "sg-row-expanded",
        /*row*/
        ctx[1].model.expanded
      );
      toggle_class(
        div,
        "sg-hover",
        /*$hoveredRow*/
        ctx[3] == /*row*/
        ctx[1].model.id
      );
      toggle_class(
        div,
        "sg-selected",
        /*$selectedRow*/
        ctx[4] == /*row*/
        ctx[1].model.id
      );
      add_location(div, file10, 13, 0, 446);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*headers, row*/
      3) {
        each_value = ensure_array_like_dev(
          /*headers*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*row*/
      2 && div_data_row_id_value !== (div_data_row_id_value = /*row*/
      ctx2[1].model.id)) {
        attr_dev(div, "data-row-id", div_data_row_id_value);
      }
      if (!current || dirty & /*row*/
      2) {
        set_style(
          div,
          "height",
          /*row*/
          ctx2[1].height + "px"
        );
      }
      if (!current || dirty & /*classes, row*/
      6 && div_class_value !== (div_class_value = "sg-table-row " + /*classes*/
      ctx2[2] + " sg-table-row-level-" + /*row*/
      ctx2[1].childLevel + " svelte-13of3p9")) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*classes, row, row*/
      6) {
        toggle_class(
          div,
          "sg-row-expanded",
          /*row*/
          ctx2[1].model.expanded
        );
      }
      if (!current || dirty & /*classes, row, $hoveredRow, row*/
      14) {
        toggle_class(
          div,
          "sg-hover",
          /*$hoveredRow*/
          ctx2[3] == /*row*/
          ctx2[1].model.id
        );
      }
      if (!current || dirty & /*classes, row, $selectedRow, row*/
      22) {
        toggle_class(
          div,
          "sg-selected",
          /*$selectedRow*/
          ctx2[4] == /*row*/
          ctx2[1].model.id
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let classes;
  let $hoveredRow;
  let $selectedRow;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableRow", slots, []);
  let { headers = null } = $$props;
  let { row = null } = $$props;
  const { hoveredRow, selectedRow } = getContext("gantt");
  validate_store(hoveredRow, "hoveredRow");
  component_subscribe($$self, hoveredRow, (value) => $$invalidate(3, $hoveredRow = value));
  validate_store(selectedRow, "selectedRow");
  component_subscribe($$self, selectedRow, (value) => $$invalidate(4, $selectedRow = value));
  let treeIndentationStyle = "";
  const writable_props = ["headers", "row"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<TableRow> was created with unknown prop '${key}'`);
  });
  function rowCollapsed_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rowExpanded_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("headers" in $$props2) $$invalidate(0, headers = $$props2.headers);
    if ("row" in $$props2) $$invalidate(1, row = $$props2.row);
  };
  $$self.$capture_state = () => ({
    getContext,
    TableTreeCell: TableTreeCell_default,
    normalizeClassAttr,
    headers,
    row,
    hoveredRow,
    selectedRow,
    treeIndentationStyle,
    classes,
    $hoveredRow,
    $selectedRow
  });
  $$self.$inject_state = ($$props2) => {
    if ("headers" in $$props2) $$invalidate(0, headers = $$props2.headers);
    if ("row" in $$props2) $$invalidate(1, row = $$props2.row);
    if ("treeIndentationStyle" in $$props2) treeIndentationStyle = $$props2.treeIndentationStyle;
    if ("classes" in $$props2) $$invalidate(2, classes = $$props2.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*row*/
    2) {
      $: {
        treeIndentationStyle = row.parent ? `padding-left: ${row.childLevel * 3}em;` : "";
      }
    }
    if ($$self.$$.dirty & /*row*/
    2) {
      $: $$invalidate(2, classes = normalizeClassAttr(row.model.classes));
    }
  };
  return [
    headers,
    row,
    classes,
    $hoveredRow,
    $selectedRow,
    hoveredRow,
    selectedRow,
    rowCollapsed_handler,
    rowExpanded_handler
  ];
}
var TableRow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { headers: 0, row: 1 }, add_css10);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableRow",
      options,
      id: create_fragment13.name
    });
  }
  get headers() {
    throw new Error("<TableRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headers(value) {
    throw new Error("<TableRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get row() {
    throw new Error("<TableRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set row(value) {
    throw new Error("<TableRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TableRow_default = TableRow;

// node_modules/svelte-gantt/svelte/modules/table/Table.svelte
var file11 = "node_modules\\svelte-gantt\\svelte\\modules\\table\\Table.svelte";
function add_css11(target) {
  append_styles(target, "svelte-5g5a5h", ".sg-table.svelte-5g5a5h{overflow-x:auto;display:flex;flex-direction:column}.sg-table-scroller.svelte-5g5a5h{width:100%;overflow-y:hidden}.sg-table-header.svelte-5g5a5h{display:flex;align-items:stretch;overflow:hidden;border-bottom:1px solid var(--sg-table-header-cell-border-color);background:var(--sg-table-header-cell-bg)}.sg-table-body.svelte-5g5a5h{display:flex;flex:1 1 0;width:100%;overflow-y:hidden}.sg-table-header-cell.svelte-5g5a5h{font-size:14px;font-weight:400}.sg-table-cell{white-space:nowrap;overflow:hidden;display:flex;align-items:center;flex-shrink:0;padding:0 0.5em;height:100%}.sg-table-cell:last-child{flex-grow:1}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFibGUuc3ZlbHRlIiwic291cmNlcyI6WyJUYWJsZS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCI+XG4gICAgZXhwb3J0IGNvbnN0IHR5cGUgPSAndGFibGUnO1xuPC9zY3JpcHQ+XG5cbjxzY3JpcHQ+aW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBvbk1vdW50LCBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcbmNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5pbXBvcnQgVGFibGVSb3cgZnJvbSAnLi9UYWJsZVJvdy5zdmVsdGUnO1xuZXhwb3J0IGxldCB0YWJsZVdpZHRoO1xuZXhwb3J0IGxldCBwYWRkaW5nVG9wO1xuZXhwb3J0IGxldCByb3dDb250YWluZXJIZWlnaHQ7XG5leHBvcnQgbGV0IHZpc2libGVSb3dzO1xuLy8gbGlzdCBvZiBjb2x1bW5zIHVzZWQgaW4gdGhlIHRhYmxlXG4vLyB0aXRsZTogbGFiZWwgdG8gZGlzcGxheSBpbiB0aGUgaGVhZGVyXG4vLyBwcm9wZXJ0eTogcHJvcGVydHkgb2Ygcm93IHRvIGRpc3BsYXkgaW4gdGhlIGNlbGxcbi8vIHdpZHRoOiB3aWR0aCBvZiBjb2x1bW5cbmV4cG9ydCBsZXQgdGFibGVIZWFkZXJzID0gW3sgdGl0bGU6ICdOYW1lJywgcHJvcGVydHk6ICdsYWJlbCcsIHdpZHRoOiAxMDAgfV07XG5jb25zdCB7IGhlYWRlckhlaWdodCwgYm90dG9tU2Nyb2xsYmFyVmlzaWJsZSB9ID0gZ2V0Q29udGV4dCgnZGltZW5zaW9ucycpO1xuY29uc3QgeyByb3dQYWRkaW5nLCByb3dIZWlnaHQgfSA9IGdldENvbnRleHQoJ29wdGlvbnMnKTtcbmNvbnN0IHsgcm93U3RvcmUsIHRhc2tTdG9yZSB9ID0gZ2V0Q29udGV4dCgnZGF0YVN0b3JlJyk7XG5jb25zdCB7IHNjcm9sbGFibGVzLCB1cGRhdGVMYXlvdXQgfSA9IGdldENvbnRleHQoJ2dhbnR0Jyk7XG5vbk1vdW50KCgpID0+IHtcbiAgICBkaXNwYXRjaCgnaW5pdCcsIHsgbW9kdWxlOiB0aGlzIH0pO1xufSk7XG5sZXQgaGVhZGVyQ29udGFpbmVyO1xuZnVuY3Rpb24gc2Nyb2xsTGlzdGVuZXIobm9kZSkge1xuICAgIHNjcm9sbGFibGVzLnB1c2goeyBub2RlLCBvcmllbnRhdGlvbjogJ3ZlcnRpY2FsJyB9KTtcbiAgICBmdW5jdGlvbiBvblNjcm9sbChldmVudCkge1xuICAgICAgICBoZWFkZXJDb250YWluZXIuc2Nyb2xsTGVmdCA9IG5vZGUuc2Nyb2xsTGVmdDtcbiAgICB9XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmxldCBzY3JvbGxXaWR0aDtcbiQ6IHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICB0YWJsZUhlYWRlcnMuZm9yRWFjaChoZWFkZXIgPT4ge1xuICAgICAgICBzdW0gKz0gaGVhZGVyLndpZHRoO1xuICAgIH0pO1xuICAgIHNjcm9sbFdpZHRoID0gc3VtO1xufVxuZnVuY3Rpb24gb25Sb3dFeHBhbmRlZChldmVudCkge1xuICAgIGNvbnN0IHJvdyA9IGV2ZW50LmRldGFpbC5yb3c7XG4gICAgcm93Lm1vZGVsLmV4cGFuZGVkID0gdHJ1ZTtcbiAgICBpZiAocm93LmNoaWxkcmVuKVxuICAgICAgICBzaG93KHJvdy5jaGlsZHJlbik7XG4gICAgdXBkYXRlTGF5b3V0KCk7XG59XG5mdW5jdGlvbiBvblJvd0NvbGxhcHNlZChldmVudCkge1xuICAgIGNvbnN0IHJvdyA9IGV2ZW50LmRldGFpbC5yb3c7XG4gICAgcm93Lm1vZGVsLmV4cGFuZGVkID0gZmFsc2U7XG4gICAgaWYgKHJvdy5jaGlsZHJlbilcbiAgICAgICAgaGlkZShyb3cuY2hpbGRyZW4pO1xuICAgIHVwZGF0ZUxheW91dCgpO1xufVxuZnVuY3Rpb24gaGlkZShjaGlsZHJlbikge1xuICAgIGZvciAoY29uc3Qgcm93IG9mIGNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChyb3cuY2hpbGRyZW4pXG4gICAgICAgICAgICBoaWRlKHJvdy5jaGlsZHJlbik7XG4gICAgICAgIHJvdy5oaWRkZW4gPSB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNob3coY2hpbGRyZW4sIGhpZGRlbiA9IGZhbHNlKSB7XG4gICAgZm9yIChjb25zdCByb3cgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKHJvdy5jaGlsZHJlbilcbiAgICAgICAgICAgIHNob3cocm93LmNoaWxkcmVuLCAhcm93Lm1vZGVsLmV4cGFuZGVkKTtcbiAgICAgICAgcm93LmhpZGRlbiA9IGhpZGRlbjtcbiAgICB9XG59XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cInNnLXRhYmxlIHNnLXZpZXdcIiBzdHlsZT1cIndpZHRoOnt0YWJsZVdpZHRofXB4O1wiPlxuICAgIDxkaXYgY2xhc3M9XCJzZy10YWJsZS1oZWFkZXJcIiBzdHlsZT1cImhlaWdodDp7JGhlYWRlckhlaWdodH1weFwiIGJpbmQ6dGhpcz17aGVhZGVyQ29udGFpbmVyfT5cbiAgICAgICAgeyNlYWNoIHRhYmxlSGVhZGVycyBhcyBoZWFkZXJ9XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwic2ctdGFibGUtaGVhZGVyLWNlbGwgc2ctdGFibGUtY2VsbFwiIHN0eWxlPVwid2lkdGg6e2hlYWRlci53aWR0aH1weFwiPlxuICAgICAgICAgICAgICAgIHtoZWFkZXIudGl0bGV9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgey9lYWNofVxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInNnLXRhYmxlLWJvZHlcIiBzdHlsZT17YHBhZGRpbmctYm90dG9tOiAkeyRib3R0b21TY3JvbGxiYXJWaXNpYmxlfXB4O2B9PlxuICAgICAgICA8ZGl2IGNsYXNzPVwic2ctdGFibGUtc2Nyb2xsZXJcIiB1c2U6c2Nyb2xsTGlzdGVuZXI+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgY2xhc3M9XCJzZy10YWJsZS1yb3dzXCJcbiAgICAgICAgICAgICAgICBzdHlsZT1cInBhZGRpbmctdG9wOntwYWRkaW5nVG9wfXB4O2hlaWdodDp7cm93Q29udGFpbmVySGVpZ2h0fXB4O1wiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgeyNlYWNoIHZpc2libGVSb3dzIGFzIHJvd31cbiAgICAgICAgICAgICAgICAgICAgPFRhYmxlUm93XG4gICAgICAgICAgICAgICAgICAgICAgICB7cm93fVxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycz17dGFibGVIZWFkZXJzfVxuICAgICAgICAgICAgICAgICAgICAgICAgb246cm93RXhwYW5kZWQ9e29uUm93RXhwYW5kZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbjpyb3dDb2xsYXBzZWQ9e29uUm93Q29sbGFwc2VkfVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuXG48c3R5bGU+XG4gICAgLnNnLXRhYmxlIHtcbiAgICAgICAgb3ZlcmZsb3cteDogYXV0bztcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICB9XG5cbiAgICAuc2ctdGFibGUtc2Nyb2xsZXIge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgLyogYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlZmVmZWY7IC8vIGluc3RlYWQgb2YgcGFkZGluZy1ib3R0b20gdXNlIGFuIGVsZW1lbnQgKHdpdGggYm9yZGVycykgKi9cbiAgICAgICAgb3ZlcmZsb3cteTogaGlkZGVuO1xuICAgIH1cblxuICAgIC5zZy10YWJsZS1oZWFkZXIge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogc3RyZXRjaDtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHZhcigtLXNnLXRhYmxlLWhlYWRlci1jZWxsLWJvcmRlci1jb2xvcik7XG4gICAgICAgIGJhY2tncm91bmQ6IHZhcigtLXNnLXRhYmxlLWhlYWRlci1jZWxsLWJnKTtcbiAgICB9XG5cbiAgICAuc2ctdGFibGUtYm9keSB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXg6IDEgMSAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgb3ZlcmZsb3cteTogaGlkZGVuO1xuICAgIH1cblxuICAgIC5zZy10YWJsZS1oZWFkZXItY2VsbCB7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDQwMDtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5zZy10YWJsZS1jZWxsKSB7XG4gICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG5cbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgZmxleC1zaHJpbms6IDA7XG5cbiAgICAgICAgcGFkZGluZzogMCAwLjVlbTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLnNnLXRhYmxlLWNlbGw6bGFzdC1jaGlsZCkge1xuICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUF1R0ksdUJBQVUsQ0FDTixVQUFVLENBQUUsSUFBSSxDQUNoQixPQUFPLENBQUUsSUFBSSxDQUNiLGNBQWMsQ0FBRSxNQUNwQixDQUVBLGdDQUFtQixDQUNmLEtBQUssQ0FBRSxJQUFJLENBRVgsVUFBVSxDQUFFLE1BQ2hCLENBRUEsOEJBQWlCLENBQ2IsT0FBTyxDQUFFLElBQUksQ0FDYixXQUFXLENBQUUsT0FBTyxDQUNwQixRQUFRLENBQUUsTUFBTSxDQUNoQixhQUFhLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLG1DQUFtQyxDQUFDLENBQ2pFLFVBQVUsQ0FBRSxJQUFJLHlCQUF5QixDQUM3QyxDQUVBLDRCQUFlLENBQ1gsT0FBTyxDQUFFLElBQUksQ0FDYixJQUFJLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQ1gsS0FBSyxDQUFFLElBQUksQ0FDWCxVQUFVLENBQUUsTUFDaEIsQ0FFQSxtQ0FBc0IsQ0FDbEIsU0FBUyxDQUFFLElBQUksQ0FDZixXQUFXLENBQUUsR0FDakIsQ0FFUSxjQUFnQixDQUNwQixXQUFXLENBQUUsTUFBTSxDQUNuQixRQUFRLENBQUUsTUFBTSxDQUVoQixPQUFPLENBQUUsSUFBSSxDQUNiLFdBQVcsQ0FBRSxNQUFNLENBQ25CLFdBQVcsQ0FBRSxDQUFDLENBRWQsT0FBTyxDQUFFLENBQUMsQ0FBQyxLQUFLLENBQ2hCLE1BQU0sQ0FBRSxJQUNaLENBRVEseUJBQTJCLENBQy9CLFNBQVMsQ0FBRSxDQUNmIn0= */");
}
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i];
  return child_ctx;
}
function create_each_block_12(ctx) {
  let div;
  let t0_value = (
    /*header*/
    ctx[25].title + ""
  );
  let t0;
  let t1;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      attr_dev(div, "class", "sg-table-header-cell sg-table-cell svelte-5g5a5h");
      set_style(
        div,
        "width",
        /*header*/
        ctx[25].width + "px"
      );
      add_location(div, file11, 77, 12, 2273);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*tableHeaders*/
      16 && t0_value !== (t0_value = /*header*/
      ctx2[25].title + "")) set_data_dev(t0, t0_value);
      if (dirty & /*tableHeaders*/
      16) {
        set_style(
          div,
          "width",
          /*header*/
          ctx2[25].width + "px"
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_12.name,
    type: "each",
    source: "(77:8) {#each tableHeaders as header}",
    ctx
  });
  return block;
}
function create_each_block6(ctx) {
  let tablerow;
  let current;
  tablerow = new TableRow_default({
    props: {
      row: (
        /*row*/
        ctx[22]
      ),
      headers: (
        /*tableHeaders*/
        ctx[4]
      )
    },
    $$inline: true
  });
  tablerow.$on(
    "rowExpanded",
    /*onRowExpanded*/
    ctx[11]
  );
  tablerow.$on(
    "rowCollapsed",
    /*onRowCollapsed*/
    ctx[12]
  );
  const block = {
    c: function create() {
      create_component(tablerow.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(tablerow, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tablerow_changes = {};
      if (dirty & /*visibleRows*/
      8) tablerow_changes.row = /*row*/
      ctx2[22];
      if (dirty & /*tableHeaders*/
      16) tablerow_changes.headers = /*tableHeaders*/
      ctx2[4];
      tablerow.$set(tablerow_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(tablerow.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tablerow.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tablerow, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block6.name,
    type: "each",
    source: "(90:16) {#each visibleRows as row}",
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let div4;
  let div0;
  let t;
  let div3;
  let div2;
  let div1;
  let scrollListener_action;
  let div3_style_value;
  let current;
  let mounted;
  let dispose;
  let each_value_1 = ensure_array_like_dev(
    /*tableHeaders*/
    ctx[4]
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_12(get_each_context_12(ctx, each_value_1, i));
  }
  let each_value = ensure_array_like_dev(
    /*visibleRows*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div4 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t = space();
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div0, "class", "sg-table-header svelte-5g5a5h");
      set_style(
        div0,
        "height",
        /*$headerHeight*/
        ctx[6] + "px"
      );
      add_location(div0, file11, 75, 4, 2131);
      attr_dev(div1, "class", "sg-table-rows");
      set_style(
        div1,
        "padding-top",
        /*paddingTop*/
        ctx[1] + "px"
      );
      set_style(
        div1,
        "height",
        /*rowContainerHeight*/
        ctx[2] + "px"
      );
      add_location(div1, file11, 85, 12, 2590);
      attr_dev(div2, "class", "sg-table-scroller svelte-5g5a5h");
      add_location(div2, file11, 84, 8, 2527);
      attr_dev(div3, "class", "sg-table-body svelte-5g5a5h");
      attr_dev(div3, "style", div3_style_value = `padding-bottom: ${/*$bottomScrollbarVisible*/
      ctx[7]}px;`);
      add_location(div3, file11, 83, 4, 2435);
      attr_dev(div4, "class", "sg-table sg-view svelte-5g5a5h");
      set_style(
        div4,
        "width",
        /*tableWidth*/
        ctx[0] + "px"
      );
      add_location(div4, file11, 74, 0, 2066);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div4, anchor);
      append_dev(div4, div0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div0, null);
        }
      }
      ctx[13](div0);
      append_dev(div4, t);
      append_dev(div4, div3);
      append_dev(div3, div2);
      append_dev(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(scrollListener_action = /*scrollListener*/
        ctx[10].call(null, div2));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*tableHeaders*/
      16) {
        each_value_1 = ensure_array_like_dev(
          /*tableHeaders*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_12(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_12(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(div0, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (!current || dirty & /*$headerHeight*/
      64) {
        set_style(
          div0,
          "height",
          /*$headerHeight*/
          ctx2[6] + "px"
        );
      }
      if (dirty & /*visibleRows, tableHeaders, onRowExpanded, onRowCollapsed*/
      6168) {
        each_value = ensure_array_like_dev(
          /*visibleRows*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*paddingTop*/
      2) {
        set_style(
          div1,
          "padding-top",
          /*paddingTop*/
          ctx2[1] + "px"
        );
      }
      if (!current || dirty & /*rowContainerHeight*/
      4) {
        set_style(
          div1,
          "height",
          /*rowContainerHeight*/
          ctx2[2] + "px"
        );
      }
      if (!current || dirty & /*$bottomScrollbarVisible*/
      128 && div3_style_value !== (div3_style_value = `padding-bottom: ${/*$bottomScrollbarVisible*/
      ctx2[7]}px;`)) {
        attr_dev(div3, "style", div3_style_value);
      }
      if (!current || dirty & /*tableWidth*/
      1) {
        set_style(
          div4,
          "width",
          /*tableWidth*/
          ctx2[0] + "px"
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div4);
      }
      destroy_each(each_blocks_1, detaching);
      ctx[13](null);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var type = "table";
function hide2(children) {
  for (const row of children) {
    if (row.children) hide2(row.children);
    row.hidden = true;
  }
}
function show2(children, hidden = false) {
  for (const row of children) {
    if (row.children) show2(row.children, !row.model.expanded);
    row.hidden = hidden;
  }
}
function instance14($$self, $$props, $$invalidate) {
  let $headerHeight;
  let $bottomScrollbarVisible;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Table", slots, []);
  const dispatch = createEventDispatcher();
  let { tableWidth } = $$props;
  let { paddingTop } = $$props;
  let { rowContainerHeight } = $$props;
  let { visibleRows } = $$props;
  let { tableHeaders = [
    {
      title: "Name",
      property: "label",
      width: 100
    }
  ] } = $$props;
  const { headerHeight, bottomScrollbarVisible } = getContext("dimensions");
  validate_store(headerHeight, "headerHeight");
  component_subscribe($$self, headerHeight, (value) => $$invalidate(6, $headerHeight = value));
  validate_store(bottomScrollbarVisible, "bottomScrollbarVisible");
  component_subscribe($$self, bottomScrollbarVisible, (value) => $$invalidate(7, $bottomScrollbarVisible = value));
  const { rowPadding, rowHeight } = getContext("options");
  const { rowStore, taskStore } = getContext("dataStore");
  const { scrollables, updateLayout } = getContext("gantt");
  onMount(() => {
    dispatch("init", { module: this });
  });
  let headerContainer;
  function scrollListener(node) {
    scrollables.push({ node, orientation: "vertical" });
    function onScroll(event) {
      $$invalidate(5, headerContainer.scrollLeft = node.scrollLeft, headerContainer);
    }
    node.addEventListener("scroll", onScroll);
    return {
      destroy() {
        node.removeEventListener("scroll", onScroll);
      }
    };
  }
  let scrollWidth;
  function onRowExpanded(event) {
    const row = event.detail.row;
    row.model.expanded = true;
    if (row.children) show2(row.children);
    updateLayout();
  }
  function onRowCollapsed(event) {
    const row = event.detail.row;
    row.model.expanded = false;
    if (row.children) hide2(row.children);
    updateLayout();
  }
  $$self.$$.on_mount.push(function() {
    if (tableWidth === void 0 && !("tableWidth" in $$props || $$self.$$.bound[$$self.$$.props["tableWidth"]])) {
      console.warn("<Table> was created without expected prop 'tableWidth'");
    }
    if (paddingTop === void 0 && !("paddingTop" in $$props || $$self.$$.bound[$$self.$$.props["paddingTop"]])) {
      console.warn("<Table> was created without expected prop 'paddingTop'");
    }
    if (rowContainerHeight === void 0 && !("rowContainerHeight" in $$props || $$self.$$.bound[$$self.$$.props["rowContainerHeight"]])) {
      console.warn("<Table> was created without expected prop 'rowContainerHeight'");
    }
    if (visibleRows === void 0 && !("visibleRows" in $$props || $$self.$$.bound[$$self.$$.props["visibleRows"]])) {
      console.warn("<Table> was created without expected prop 'visibleRows'");
    }
  });
  const writable_props = [
    "tableWidth",
    "paddingTop",
    "rowContainerHeight",
    "visibleRows",
    "tableHeaders"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Table> was created with unknown prop '${key}'`);
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      headerContainer = $$value;
      $$invalidate(5, headerContainer);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("tableWidth" in $$props2) $$invalidate(0, tableWidth = $$props2.tableWidth);
    if ("paddingTop" in $$props2) $$invalidate(1, paddingTop = $$props2.paddingTop);
    if ("rowContainerHeight" in $$props2) $$invalidate(2, rowContainerHeight = $$props2.rowContainerHeight);
    if ("visibleRows" in $$props2) $$invalidate(3, visibleRows = $$props2.visibleRows);
    if ("tableHeaders" in $$props2) $$invalidate(4, tableHeaders = $$props2.tableHeaders);
  };
  $$self.$capture_state = () => ({
    type,
    createEventDispatcher,
    onMount,
    getContext,
    dispatch,
    TableRow: TableRow_default,
    tableWidth,
    paddingTop,
    rowContainerHeight,
    visibleRows,
    tableHeaders,
    headerHeight,
    bottomScrollbarVisible,
    rowPadding,
    rowHeight,
    rowStore,
    taskStore,
    scrollables,
    updateLayout,
    headerContainer,
    scrollListener,
    scrollWidth,
    onRowExpanded,
    onRowCollapsed,
    hide: hide2,
    show: show2,
    $headerHeight,
    $bottomScrollbarVisible
  });
  $$self.$inject_state = ($$props2) => {
    if ("tableWidth" in $$props2) $$invalidate(0, tableWidth = $$props2.tableWidth);
    if ("paddingTop" in $$props2) $$invalidate(1, paddingTop = $$props2.paddingTop);
    if ("rowContainerHeight" in $$props2) $$invalidate(2, rowContainerHeight = $$props2.rowContainerHeight);
    if ("visibleRows" in $$props2) $$invalidate(3, visibleRows = $$props2.visibleRows);
    if ("tableHeaders" in $$props2) $$invalidate(4, tableHeaders = $$props2.tableHeaders);
    if ("headerContainer" in $$props2) $$invalidate(5, headerContainer = $$props2.headerContainer);
    if ("scrollWidth" in $$props2) scrollWidth = $$props2.scrollWidth;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*tableHeaders*/
    16) {
      $: {
        let sum = 0;
        tableHeaders.forEach((header) => {
          sum += header.width;
        });
        scrollWidth = sum;
      }
    }
  };
  return [
    tableWidth,
    paddingTop,
    rowContainerHeight,
    visibleRows,
    tableHeaders,
    headerContainer,
    $headerHeight,
    $bottomScrollbarVisible,
    headerHeight,
    bottomScrollbarVisible,
    scrollListener,
    onRowExpanded,
    onRowCollapsed,
    div0_binding
  ];
}
var Table = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance14,
      create_fragment14,
      safe_not_equal,
      {
        tableWidth: 0,
        paddingTop: 1,
        rowContainerHeight: 2,
        visibleRows: 3,
        tableHeaders: 4
      },
      add_css11
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table",
      options,
      id: create_fragment14.name
    });
  }
  get tableWidth() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tableWidth(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get paddingTop() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set paddingTop(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rowContainerHeight() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rowContainerHeight(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visibleRows() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visibleRows(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tableHeaders() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tableHeaders(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Table_default = Table;

// node_modules/svelte-gantt/svelte/modules/dependencies/Dependency.svelte
var file12 = "node_modules\\svelte-gantt\\svelte\\modules\\dependencies\\Dependency.svelte";
function add_css12(target) {
  append_styles(target, "svelte-1e2sb8m", ".sg-dependency.svelte-1e2sb8m{position:absolute;width:100%;height:100%}.sg-arrow.svelte-1e2sb8m{position:absolute;left:0px;pointer-events:none}path.sg-arrow-path{stroke:var(--sg-dependency-arrow-color);fill:transparent;stroke-width:2px}.sg-arrow-head{fill:var(--sg-dependency-arrow-color)}.select-area.svelte-1e2sb8m{pointer-events:visible;position:absolute}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGVwZW5kZW5jeS5zdmVsdGUiLCJzb3VyY2VzIjpbIkRlcGVuZGVuY3kuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+aW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5jb25zdCB7IHJvd1N0b3JlLCB0YXNrU3RvcmUgfSA9IGdldENvbnRleHQoJ2RhdGFTdG9yZScpO1xuZXhwb3J0IGxldCBpZDtcbmV4cG9ydCBsZXQgZnJvbUlkO1xuZXhwb3J0IGxldCB0b0lkO1xuZXhwb3J0IGxldCBzdHJva2UgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IHN0cm9rZVdpZHRoID0gdW5kZWZpbmVkO1xuY29uc3QgTUlOX0xFTiA9IDEyO1xuY29uc3QgQVJST1dfU0laRSA9IDU7XG5sZXQgYXJyb3dQYXRoO1xubGV0IHBhdGg7XG5sZXQgZnJvbVRhc2s7XG5sZXQgaXNGcm9tUm93SGlkZGVuO1xubGV0IHRvVGFzaztcbmxldCBpc1RvUm93SGlkZGVuO1xuJDoge1xuICAgIGZyb21UYXNrID0gJHRhc2tTdG9yZS5lbnRpdGllc1tmcm9tSWRdO1xuICAgIGlzRnJvbVJvd0hpZGRlbiA9ICRyb3dTdG9yZS5lbnRpdGllc1tmcm9tVGFzay5tb2RlbC5yZXNvdXJjZUlkXS5oaWRkZW47XG4gICAgdG9UYXNrID0gJHRhc2tTdG9yZS5lbnRpdGllc1t0b0lkXTtcbiAgICBpc1RvUm93SGlkZGVuID0gJHJvd1N0b3JlLmVudGl0aWVzW3RvVGFzay5tb2RlbC5yZXNvdXJjZUlkXS5oaWRkZW47XG4gICAgbGV0IHN0YXJ0WSA9IGZyb21UYXNrLnRvcCArIGZyb21UYXNrLmhlaWdodCAvIDI7XG4gICAgbGV0IHN0YXJ0WCA9IGZyb21UYXNrLmxlZnQgKyBmcm9tVGFzay53aWR0aDtcbiAgICBsZXQgZW5kWSA9IHRvVGFzay50b3AgKyB0b1Rhc2suaGVpZ2h0IC8gMjtcbiAgICBsZXQgZW5kWCA9IHRvVGFzay5sZWZ0O1xuICAgIGxldCB3aWR0aCA9IGVuZFggLSBzdGFydFg7XG4gICAgbGV0IGhlaWdodCA9IGVuZFkgLSBzdGFydFk7XG4gICAgaWYgKGlzRnJvbVJvd0hpZGRlbikge1xuICAgICAgICBwYXRoID0gYE0ke2VuZFh9ICR7ZW5kWX1gO1xuICAgICAgICBpZiAoc3RhcnRYICsgTUlOX0xFTiA+PSBlbmRYICYmIHN0YXJ0WSAhPSBlbmRZKSB7XG4gICAgICAgICAgICBwYXRoICs9IGBMICR7ZW5kWCArIDEuNSAtIE1JTl9MRU59ICR7ZW5kWX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF0aCArPSBgTCAke2VuZFggKyAxLjUgLSB3aWR0aCAvIDJ9ICR7ZW5kWX1gO1xuICAgICAgICB9XG4gICAgICAgIHBhdGggKz0gYG0gLTIgLTIgYSAyIDIgMCAxIDEgMCA0IGEgMiAyIDAgMSAxIDAgLTRgO1xuICAgICAgICBhcnJvd1BhdGggPSBgTSR7dG9UYXNrLmxlZnQgLSBBUlJPV19TSVpFfSAgJHt0b1Rhc2sudG9wICsgdG9UYXNrLmhlaWdodCAvIDIgLSBBUlJPV19TSVpFfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMJHt0b1Rhc2subGVmdH0gJHt0b1Rhc2sudG9wICsgdG9UYXNrLmhlaWdodCAvIDJ9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEwke3RvVGFzay5sZWZ0IC0gQVJST1dfU0laRX0gJHt0b1Rhc2sudG9wICsgdG9UYXNrLmhlaWdodCAvIDIgKyBBUlJPV19TSVpFfSBaYDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNUb1Jvd0hpZGRlbikge1xuICAgICAgICBwYXRoID0gYE0ke3N0YXJ0WH0gJHtzdGFydFl9YDtcbiAgICAgICAgaWYgKHN0YXJ0WCArIE1JTl9MRU4gPj0gZW5kWCAmJiBzdGFydFkgIT0gZW5kWSkge1xuICAgICAgICAgICAgcGF0aCArPSBgTCAke3N0YXJ0WCArIDEuNSArIE1JTl9MRU59ICR7c3RhcnRZfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRoICs9IGBMICR7c3RhcnRYICsgMS41ICsgd2lkdGggLyAyfSAke3N0YXJ0WX1gO1xuICAgICAgICB9XG4gICAgICAgIHBhdGggKz0gYG0gLTIgLTIgYSAyIDIgMCAxIDEgMCA0IGEgMiAyIDAgMSAxIDAgLTRgO1xuICAgICAgICBhcnJvd1BhdGggPSBgYDtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzRnJvbVJvd0hpZGRlbiAmJiAhaXNUb1Jvd0hpZGRlbikge1xuICAgICAgICBwYXRoID0gYE0ke3N0YXJ0WH0gJHtzdGFydFl9YDtcbiAgICAgICAgaWYgKHN0YXJ0WCArIE1JTl9MRU4gPj0gZW5kWCAmJiBzdGFydFkgIT0gZW5kWSkge1xuICAgICAgICAgICAgcGF0aCArPSBgTCAke3N0YXJ0WCArIE1JTl9MRU59ICR7c3RhcnRZfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMICR7c3RhcnRYICsgTUlOX0xFTn0gJHtzdGFydFkgKyBoZWlnaHQgLyAyfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEwgJHtlbmRYIC0gTUlOX0xFTn0gJHtzdGFydFkgKyBoZWlnaHQgLyAyfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEwgJHtlbmRYIC0gTUlOX0xFTn0gJHtlbmRZfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEwgJHtlbmRYIC0gMn0gJHtlbmRZfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRoICs9IGBMICR7c3RhcnRYICsgd2lkdGggLyAyfSAke3N0YXJ0WX0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTCAke3N0YXJ0WCArIHdpZHRoIC8gMn0gJHtlbmRZfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEwgJHtlbmRYIC0gMn0gJHtlbmRZfWA7XG4gICAgICAgIH1cbiAgICAgICAgYXJyb3dQYXRoID0gYE0ke3RvVGFzay5sZWZ0IC0gQVJST1dfU0laRX0gJHt0b1Rhc2sudG9wICsgdG9UYXNrLmhlaWdodCAvIDIgLSBBUlJPV19TSVpFfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMJHt0b1Rhc2subGVmdH0gJHt0b1Rhc2sudG9wICsgdG9UYXNrLmhlaWdodCAvIDJ9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEwke3RvVGFzay5sZWZ0IC0gQVJST1dfU0laRX0gJHt0b1Rhc2sudG9wICsgdG9UYXNrLmhlaWdodCAvIDIgKyBBUlJPV19TSVpFfSBaYDtcbiAgICB9XG59XG48L3NjcmlwdD5cblxueyNpZiAoIWlzRnJvbVJvd0hpZGRlbiAmJiAhaXNUb1Jvd0hpZGRlbikgfHwgaXNGcm9tUm93SGlkZGVuICE9PSBpc1RvUm93SGlkZGVufVxuICAgIDxkaXYgY2xhc3M9XCJzZy1kZXBlbmRlbmN5XCIgc3R5bGU9XCJsZWZ0OjA7dG9wOjBcIiBkYXRhLWRlcGVuZGVuY3ktaWQ9e2lkfT5cbiAgICAgICAgPHN2Z1xuICAgICAgICAgICAgY2xhc3M9XCJzZy1hcnJvd1wiXG4gICAgICAgICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgICAgICAgIHNoYXBlLXJlbmRlcmluZz1cImNyaXNwRWRnZXNcIlxuICAgICAgICAgICAgaGVpZ2h0PVwiMTAwJVwiXG4gICAgICAgICAgICB3aWR0aD1cIjEwMCVcIlxuICAgICAgICA+XG4gICAgICAgICAgICA8cGF0aCBjbGFzcz1cInNnLWFycm93LXBhdGggc2VsZWN0LWFyZWFcIiBkPXtwYXRofSBzdHlsZTpzdHJva2U9e3N0cm9rZX0gc3R5bGU6c3Ryb2tlLXdpZHRoPXtzdHJva2VXaWR0aCAhPSBudWxsID8gYCR7c3Ryb2tlV2lkdGh9cHhgIDogbnVsbH0gLz5cbiAgICAgICAgICAgIDxwYXRoIGNsYXNzPVwic2ctYXJyb3ctaGVhZFwiIGQ9e2Fycm93UGF0aH0gc3R5bGU6ZmlsbD17c3Ryb2tlfSAvPlxuICAgICAgICA8L3N2Zz5cbiAgICA8L2Rpdj5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICAuc2ctZGVwZW5kZW5jeSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICB9XG5cbiAgICAuc2ctYXJyb3cge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IDBweDtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgfVxuXG4gICAgOmdsb2JhbChwYXRoLnNnLWFycm93LXBhdGgpIHtcbiAgICAgICAgc3Ryb2tlOiB2YXIoLS1zZy1kZXBlbmRlbmN5LWFycm93LWNvbG9yKTtcbiAgICAgICAgZmlsbDogdHJhbnNwYXJlbnQ7XG4gICAgICAgIHN0cm9rZS13aWR0aDogMnB4O1xuICAgIH1cblxuICAgIDpnbG9iYWwoLnNnLWFycm93LWhlYWQpIHtcbiAgICAgICAgZmlsbDogdmFyKC0tc2ctZGVwZW5kZW5jeS1hcnJvdy1jb2xvcik7XG4gICAgfVxuXG4gICAgLnNlbGVjdC1hcmVhIHtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IHZpc2libGU7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXVGSSw2QkFBZSxDQUNYLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQ1osQ0FFQSx3QkFBVSxDQUNOLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLElBQUksQ0FBRSxHQUFHLENBQ1QsY0FBYyxDQUFFLElBQ3BCLENBRVEsa0JBQW9CLENBQ3hCLE1BQU0sQ0FBRSxJQUFJLDJCQUEyQixDQUFDLENBQ3hDLElBQUksQ0FBRSxXQUFXLENBQ2pCLFlBQVksQ0FBRSxHQUNsQixDQUVRLGNBQWdCLENBQ3BCLElBQUksQ0FBRSxJQUFJLDJCQUEyQixDQUN6QyxDQUVBLDJCQUFhLENBQ1QsY0FBYyxDQUFFLE9BQU8sQ0FDdkIsUUFBUSxDQUFFLFFBQ2QifQ== */");
}
function create_if_block7(ctx) {
  let div;
  let svg;
  let path0;
  let path1;
  const block = {
    c: function create() {
      div = element("div");
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr_dev(path0, "class", "sg-arrow-path select-area svelte-1e2sb8m");
      attr_dev(
        path0,
        "d",
        /*path*/
        ctx[6]
      );
      set_style(
        path0,
        "stroke",
        /*stroke*/
        ctx[1]
      );
      set_style(
        path0,
        "stroke-width",
        /*strokeWidth*/
        ctx[2] != null ? `${/*strokeWidth*/
        ctx[2]}px` : null
      );
      add_location(path0, file12, 80, 12, 3150);
      attr_dev(path1, "class", "sg-arrow-head");
      attr_dev(
        path1,
        "d",
        /*arrowPath*/
        ctx[5]
      );
      set_style(
        path1,
        "fill",
        /*stroke*/
        ctx[1]
      );
      add_location(path1, file12, 81, 12, 3305);
      attr_dev(svg, "class", "sg-arrow svelte-1e2sb8m");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "shape-rendering", "crispEdges");
      attr_dev(svg, "height", "100%");
      attr_dev(svg, "width", "100%");
      add_location(svg, file12, 73, 8, 2955);
      attr_dev(div, "class", "sg-dependency svelte-1e2sb8m");
      set_style(div, "left", "0");
      set_style(div, "top", "0");
      attr_dev(
        div,
        "data-dependency-id",
        /*id*/
        ctx[0]
      );
      add_location(div, file12, 72, 4, 2874);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, svg);
      append_dev(svg, path0);
      append_dev(svg, path1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*path*/
      64) {
        attr_dev(
          path0,
          "d",
          /*path*/
          ctx2[6]
        );
      }
      if (dirty & /*stroke*/
      2) {
        set_style(
          path0,
          "stroke",
          /*stroke*/
          ctx2[1]
        );
      }
      if (dirty & /*strokeWidth*/
      4) {
        set_style(
          path0,
          "stroke-width",
          /*strokeWidth*/
          ctx2[2] != null ? `${/*strokeWidth*/
          ctx2[2]}px` : null
        );
      }
      if (dirty & /*arrowPath*/
      32) {
        attr_dev(
          path1,
          "d",
          /*arrowPath*/
          ctx2[5]
        );
      }
      if (dirty & /*stroke*/
      2) {
        set_style(
          path1,
          "fill",
          /*stroke*/
          ctx2[1]
        );
      }
      if (dirty & /*id*/
      1) {
        attr_dev(
          div,
          "data-dependency-id",
          /*id*/
          ctx2[0]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(72:0) {#if (!isFromRowHidden && !isToRowHidden) || isFromRowHidden !== isToRowHidden}",
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let if_block_anchor;
  let if_block = (!/*isFromRowHidden*/
  ctx[3] && !/*isToRowHidden*/
  ctx[4] || /*isFromRowHidden*/
  ctx[3] !== /*isToRowHidden*/
  ctx[4]) && create_if_block7(ctx);
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (!/*isFromRowHidden*/
      ctx2[3] && !/*isToRowHidden*/
      ctx2[4] || /*isFromRowHidden*/
      ctx2[3] !== /*isToRowHidden*/
      ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block7(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var MIN_LEN = 12;
var ARROW_SIZE = 5;
function instance15($$self, $$props, $$invalidate) {
  let $rowStore;
  let $taskStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dependency", slots, []);
  const { rowStore, taskStore } = getContext("dataStore");
  validate_store(rowStore, "rowStore");
  component_subscribe($$self, rowStore, (value) => $$invalidate(13, $rowStore = value));
  validate_store(taskStore, "taskStore");
  component_subscribe($$self, taskStore, (value) => $$invalidate(14, $taskStore = value));
  let { id } = $$props;
  let { fromId } = $$props;
  let { toId } = $$props;
  let { stroke = void 0 } = $$props;
  let { strokeWidth = void 0 } = $$props;
  let arrowPath;
  let path;
  let fromTask;
  let isFromRowHidden;
  let toTask;
  let isToRowHidden;
  $$self.$$.on_mount.push(function() {
    if (id === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console.warn("<Dependency> was created without expected prop 'id'");
    }
    if (fromId === void 0 && !("fromId" in $$props || $$self.$$.bound[$$self.$$.props["fromId"]])) {
      console.warn("<Dependency> was created without expected prop 'fromId'");
    }
    if (toId === void 0 && !("toId" in $$props || $$self.$$.bound[$$self.$$.props["toId"]])) {
      console.warn("<Dependency> was created without expected prop 'toId'");
    }
  });
  const writable_props = ["id", "fromId", "toId", "stroke", "strokeWidth"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Dependency> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("fromId" in $$props2) $$invalidate(9, fromId = $$props2.fromId);
    if ("toId" in $$props2) $$invalidate(10, toId = $$props2.toId);
    if ("stroke" in $$props2) $$invalidate(1, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2) $$invalidate(2, strokeWidth = $$props2.strokeWidth);
  };
  $$self.$capture_state = () => ({
    getContext,
    rowStore,
    taskStore,
    id,
    fromId,
    toId,
    stroke,
    strokeWidth,
    MIN_LEN,
    ARROW_SIZE,
    arrowPath,
    path,
    fromTask,
    isFromRowHidden,
    toTask,
    isToRowHidden,
    $rowStore,
    $taskStore
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2) $$invalidate(0, id = $$props2.id);
    if ("fromId" in $$props2) $$invalidate(9, fromId = $$props2.fromId);
    if ("toId" in $$props2) $$invalidate(10, toId = $$props2.toId);
    if ("stroke" in $$props2) $$invalidate(1, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2) $$invalidate(2, strokeWidth = $$props2.strokeWidth);
    if ("arrowPath" in $$props2) $$invalidate(5, arrowPath = $$props2.arrowPath);
    if ("path" in $$props2) $$invalidate(6, path = $$props2.path);
    if ("fromTask" in $$props2) $$invalidate(11, fromTask = $$props2.fromTask);
    if ("isFromRowHidden" in $$props2) $$invalidate(3, isFromRowHidden = $$props2.isFromRowHidden);
    if ("toTask" in $$props2) $$invalidate(12, toTask = $$props2.toTask);
    if ("isToRowHidden" in $$props2) $$invalidate(4, isToRowHidden = $$props2.isToRowHidden);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$taskStore, fromId, $rowStore, fromTask, toId, toTask, isFromRowHidden, path, isToRowHidden*/
    32344) {
      $: {
        $$invalidate(11, fromTask = $taskStore.entities[fromId]);
        $$invalidate(3, isFromRowHidden = $rowStore.entities[fromTask.model.resourceId].hidden);
        $$invalidate(12, toTask = $taskStore.entities[toId]);
        $$invalidate(4, isToRowHidden = $rowStore.entities[toTask.model.resourceId].hidden);
        let startY = fromTask.top + fromTask.height / 2;
        let startX = fromTask.left + fromTask.width;
        let endY = toTask.top + toTask.height / 2;
        let endX = toTask.left;
        let width = endX - startX;
        let height = endY - startY;
        if (isFromRowHidden) {
          $$invalidate(6, path = `M${endX} ${endY}`);
          if (startX + MIN_LEN >= endX && startY != endY) {
            $$invalidate(6, path += `L ${endX + 1.5 - MIN_LEN} ${endY}`);
          } else {
            $$invalidate(6, path += `L ${endX + 1.5 - width / 2} ${endY}`);
          }
          $$invalidate(6, path += `m -2 -2 a 2 2 0 1 1 0 4 a 2 2 0 1 1 0 -4`);
          $$invalidate(5, arrowPath = `M${toTask.left - ARROW_SIZE}  ${toTask.top + toTask.height / 2 - ARROW_SIZE} 
                            L${toTask.left} ${toTask.top + toTask.height / 2} 
                            L${toTask.left - ARROW_SIZE} ${toTask.top + toTask.height / 2 + ARROW_SIZE} Z`);
        } else if (isToRowHidden) {
          $$invalidate(6, path = `M${startX} ${startY}`);
          if (startX + MIN_LEN >= endX && startY != endY) {
            $$invalidate(6, path += `L ${startX + 1.5 + MIN_LEN} ${startY}`);
          } else {
            $$invalidate(6, path += `L ${startX + 1.5 + width / 2} ${startY}`);
          }
          $$invalidate(6, path += `m -2 -2 a 2 2 0 1 1 0 4 a 2 2 0 1 1 0 -4`);
          $$invalidate(5, arrowPath = ``);
        } else if (!isFromRowHidden && !isToRowHidden) {
          $$invalidate(6, path = `M${startX} ${startY}`);
          if (startX + MIN_LEN >= endX && startY != endY) {
            $$invalidate(6, path += `L ${startX + MIN_LEN} ${startY} 
                            L ${startX + MIN_LEN} ${startY + height / 2}
                            L ${endX - MIN_LEN} ${startY + height / 2}
                            L ${endX - MIN_LEN} ${endY}
                            L ${endX - 2} ${endY}`);
          } else {
            $$invalidate(6, path += `L ${startX + width / 2} ${startY} 
                            L ${startX + width / 2} ${endY}
                            L ${endX - 2} ${endY}`);
          }
          $$invalidate(5, arrowPath = `M${toTask.left - ARROW_SIZE} ${toTask.top + toTask.height / 2 - ARROW_SIZE} 
                            L${toTask.left} ${toTask.top + toTask.height / 2} 
                            L${toTask.left - ARROW_SIZE} ${toTask.top + toTask.height / 2 + ARROW_SIZE} Z`);
        }
      }
    }
  };
  return [
    id,
    stroke,
    strokeWidth,
    isFromRowHidden,
    isToRowHidden,
    arrowPath,
    path,
    rowStore,
    taskStore,
    fromId,
    toId,
    fromTask,
    toTask,
    $rowStore,
    $taskStore
  ];
}
var Dependency = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance15,
      create_fragment15,
      safe_not_equal,
      {
        id: 0,
        fromId: 9,
        toId: 10,
        stroke: 1,
        strokeWidth: 2
      },
      add_css12
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dependency",
      options,
      id: create_fragment15.name
    });
  }
  get id() {
    throw new Error("<Dependency>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Dependency>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fromId() {
    throw new Error("<Dependency>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fromId(value) {
    throw new Error("<Dependency>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toId() {
    throw new Error("<Dependency>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toId(value) {
    throw new Error("<Dependency>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stroke() {
    throw new Error("<Dependency>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stroke(value) {
    throw new Error("<Dependency>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<Dependency>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<Dependency>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Dependency_default = Dependency;

// node_modules/svelte-gantt/svelte/modules/dependencies/GanttDependencies.svelte
var file13 = "node_modules\\svelte-gantt\\svelte\\modules\\dependencies\\GanttDependencies.svelte";
function add_css13(target) {
  append_styles(target, "svelte-epxabx", ".dependency-container.svelte-epxabx{position:absolute;width:100%;height:100%;pointer-events:none;top:0;float:left;overflow:hidden;z-index:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2FudHREZXBlbmRlbmNpZXMuc3ZlbHRlIiwic291cmNlcyI6WyJHYW50dERlcGVuZGVuY2llcy5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5pbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcbmltcG9ydCBEZXBlbmRlbmN5IGZyb20gJy4vRGVwZW5kZW5jeS5zdmVsdGUnO1xuY29uc3QgeyB2aXNpYmxlSGVpZ2h0IH0gPSBnZXRDb250ZXh0KCdkaW1lbnNpb25zJyk7XG5jb25zdCB7IHRhc2tTdG9yZSB9ID0gZ2V0Q29udGV4dCgnZGF0YVN0b3JlJyk7XG5leHBvcnQgbGV0IHBhZGRpbmdUb3A7XG5leHBvcnQgbGV0IGRlcGVuZGVuY2llcyA9IFtdO1xubGV0IHZpc2libGVEZXBlbmRlbmNpZXMgPSBbXTtcbiQ6IHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuICAgICAgICBjb25zdCBtYXAgPSAkdGFza1N0b3JlLmVudGl0aWVzO1xuICAgICAgICBjb25zdCBmcm9tVGFzayA9IG1hcFtkZXBlbmRlbmN5LmZyb21JZF07XG4gICAgICAgIGNvbnN0IHRvVGFzayA9IG1hcFtkZXBlbmRlbmN5LnRvSWRdO1xuICAgICAgICBpZiAoZnJvbVRhc2sgJiZcbiAgICAgICAgICAgIHRvVGFzayAmJlxuICAgICAgICAgICAgTWF0aC5taW4oZnJvbVRhc2sudG9wLCB0b1Rhc2sudG9wKSA8PSBwYWRkaW5nVG9wICsgJHZpc2libGVIZWlnaHQgJiZcbiAgICAgICAgICAgIE1hdGgubWF4KGZyb21UYXNrLnRvcCwgdG9UYXNrLnRvcCkgPj0gcGFkZGluZ1RvcCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVwZW5kZW5jeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaWJsZURlcGVuZGVuY2llcyA9IHJlc3VsdDtcbn1cbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwiZGVwZW5kZW5jeS1jb250YWluZXJcIj5cbiAgICB7I2VhY2ggdmlzaWJsZURlcGVuZGVuY2llcyBhcyBkZXBlbmRlbmN5IChkZXBlbmRlbmN5LmlkKX1cbiAgICAgICAgPERlcGVuZGVuY3kgey4uLmRlcGVuZGVuY3l9IC8+XG4gICAgey9lYWNofVxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgICAuZGVwZW5kZW5jeS1jb250YWluZXIge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG5cbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgZmxvYXQ6IGxlZnQ7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgIHotaW5kZXg6IDA7XG4gICAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFnQ0ksbUNBQXNCLENBQ2xCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQ0FFWixjQUFjLENBQUUsSUFBSSxDQUNwQixHQUFHLENBQUUsQ0FBQyxDQUNOLEtBQUssQ0FBRSxJQUFJLENBQ1gsUUFBUSxDQUFFLE1BQU0sQ0FDaEIsT0FBTyxDQUFFLENBQ2IifQ== */");
}
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_each_block7(key_1, ctx) {
  let first;
  let dependency_1;
  let current;
  const dependency_1_spread_levels = [
    /*dependency*/
    ctx[7]
  ];
  let dependency_1_props = {};
  for (let i = 0; i < dependency_1_spread_levels.length; i += 1) {
    dependency_1_props = assign(dependency_1_props, dependency_1_spread_levels[i]);
  }
  dependency_1 = new Dependency_default({
    props: dependency_1_props,
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(dependency_1.$$.fragment);
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(dependency_1, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const dependency_1_changes = dirty & /*visibleDependencies*/
      1 ? get_spread_update(dependency_1_spread_levels, [get_spread_object(
        /*dependency*/
        ctx[7]
      )]) : {};
      dependency_1.$set(dependency_1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(dependency_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dependency_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(dependency_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block7.name,
    type: "each",
    source: "(27:4) {#each visibleDependencies as dependency (dependency.id)}",
    ctx
  });
  return block;
}
function create_fragment16(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ensure_array_like_dev(
    /*visibleDependencies*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*dependency*/
    ctx2[7].id
  );
  validate_each_keys(ctx, each_value, get_each_context7, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context7(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block7(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "class", "dependency-container svelte-epxabx");
      add_location(div, file13, 25, 0, 823);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*visibleDependencies*/
      1) {
        each_value = ensure_array_like_dev(
          /*visibleDependencies*/
          ctx2[0]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context7, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block7, null, get_each_context7);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let $visibleHeight;
  let $taskStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GanttDependencies", slots, []);
  const { visibleHeight } = getContext("dimensions");
  validate_store(visibleHeight, "visibleHeight");
  component_subscribe($$self, visibleHeight, (value) => $$invalidate(5, $visibleHeight = value));
  const { taskStore } = getContext("dataStore");
  validate_store(taskStore, "taskStore");
  component_subscribe($$self, taskStore, (value) => $$invalidate(6, $taskStore = value));
  let { paddingTop } = $$props;
  let { dependencies = [] } = $$props;
  let visibleDependencies = [];
  $$self.$$.on_mount.push(function() {
    if (paddingTop === void 0 && !("paddingTop" in $$props || $$self.$$.bound[$$self.$$.props["paddingTop"]])) {
      console.warn("<GanttDependencies> was created without expected prop 'paddingTop'");
    }
  });
  const writable_props = ["paddingTop", "dependencies"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<GanttDependencies> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("paddingTop" in $$props2) $$invalidate(3, paddingTop = $$props2.paddingTop);
    if ("dependencies" in $$props2) $$invalidate(4, dependencies = $$props2.dependencies);
  };
  $$self.$capture_state = () => ({
    getContext,
    Dependency: Dependency_default,
    visibleHeight,
    taskStore,
    paddingTop,
    dependencies,
    visibleDependencies,
    $visibleHeight,
    $taskStore
  });
  $$self.$inject_state = ($$props2) => {
    if ("paddingTop" in $$props2) $$invalidate(3, paddingTop = $$props2.paddingTop);
    if ("dependencies" in $$props2) $$invalidate(4, dependencies = $$props2.dependencies);
    if ("visibleDependencies" in $$props2) $$invalidate(0, visibleDependencies = $$props2.visibleDependencies);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*dependencies, $taskStore, paddingTop, $visibleHeight*/
    120) {
      $: {
        const result = [];
        for (let i = 0; i < dependencies.length; i++) {
          const dependency = dependencies[i];
          const map = $taskStore.entities;
          const fromTask = map[dependency.fromId];
          const toTask = map[dependency.toId];
          if (fromTask && toTask && Math.min(fromTask.top, toTask.top) <= paddingTop + $visibleHeight && Math.max(fromTask.top, toTask.top) >= paddingTop) {
            result.push(dependency);
          }
        }
        $$invalidate(0, visibleDependencies = result);
      }
    }
  };
  return [
    visibleDependencies,
    visibleHeight,
    taskStore,
    paddingTop,
    dependencies,
    $visibleHeight,
    $taskStore
  ];
}
var GanttDependencies = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, { paddingTop: 3, dependencies: 4 }, add_css13);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GanttDependencies",
      options,
      id: create_fragment16.name
    });
  }
  get paddingTop() {
    throw new Error("<GanttDependencies>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set paddingTop(value) {
    throw new Error("<GanttDependencies>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dependencies() {
    throw new Error("<GanttDependencies>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dependencies(value) {
    throw new Error("<GanttDependencies>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GanttDependencies_default = GanttDependencies;

// node_modules/svelte-gantt/svelte/modules/external/external.js
var defaults = {
  enabled: true,
  elementContent: () => {
    const element2 = document.createElement("div");
    element2.innerHTML = "New Task";
    Object.assign(element2.style, {
      position: "absolute",
      background: "#eee",
      padding: "0.5em 1em",
      fontSize: "12px",
      pointerEvents: "none"
    });
    return element2;
  }
};
var SvelteGanttExternal = class {
  constructor(node, options) {
    __publicField(this, "draggable");
    __publicField(this, "element");
    __publicField(this, "options");
    this.options = Object.assign({}, defaults, options);
    this.draggable = useDraggable(node, {
      onDrag: this.onDrag.bind(this),
      dragAllowed: () => this.options.enabled,
      resizeAllowed: false,
      onDrop: this.onDrop.bind(this),
      container: document.body,
      getX: (event) => event.pageX,
      getY: (event) => event.pageY,
      getWidth: () => 0
    });
  }
  onDrag({ x, y }) {
    if (!this.element) {
      this.element = this.options.elementContent();
      document.body.appendChild(this.element);
      this.options.dragging = true;
    }
    this.element.style.top = y + "px";
    this.element.style.left = x + "px";
  }
  onDrop(event) {
    var _a, _b, _c, _d;
    const gantt = this.options.gantt;
    const rowId = getRowAtPoint(event.mouseEvent);
    const targetRow = gantt.getRow(rowId);
    if (targetRow && isDraggable(targetRow.model)) {
      const mousePos = getRelativePos(gantt.getRowContainer(), event.mouseEvent);
      const date = gantt.utils.getDateByPosition(mousePos.x);
      (_b = (_a = this.options).onsuccess) == null ? void 0 : _b.call(_a, targetRow, date, gantt);
    } else {
      (_d = (_c = this.options).onfail) == null ? void 0 : _d.call(_c);
    }
    document.body.removeChild(this.element);
    this.options.dragging = false;
    this.element = null;
  }
};

// node_modules/svelte-gantt/svelte/utils/momentDateAdapter.js
var MomentSvelteGanttDateAdapter = class {
  constructor(moment) {
    __publicField(this, "moment");
    this.moment = moment;
  }
  format(date, format) {
    return this.moment(date).format(format);
  }
  roundTo(date, unit, offset) {
    const m = this.moment(date);
    roundMoment(m, offset, unit);
    return m.valueOf();
  }
};
var aliases = {
  hour: "hours",
  minute: "minutes",
  second: "seconds",
  millisecond: "milliseconds"
};
function roundMoment(m, precision, key, direction = "round") {
  if (precision === 1 && key === "day") {
    precision = 24;
    key = "hours";
  }
  if (aliases[key]) {
    key = aliases[key];
  }
  const methods = {
    hours: 24,
    minutes: 60,
    seconds: 60,
    milliseconds: 1e3
  };
  if (!methods[key]) {
    console.warn(`Rounding dates by ${key} is not supported`);
  }
  let value = 0;
  let rounded = false;
  let subRatio = 1;
  let maxValue;
  for (const k in methods) {
    if (k === key) {
      value = m.get(key);
      maxValue = methods[k];
      rounded = true;
    } else if (rounded) {
      subRatio *= methods[k];
      value += m.get(k) / subRatio;
      m.set(k, 0);
    }
  }
  value = Math[direction](value / precision) * precision;
  value = Math.min(value, maxValue);
  m.set(key, value);
  return m;
}
export {
  MomentSvelteGanttDateAdapter,
  Gantt_default as SvelteGantt,
  GanttDependencies_default as SvelteGanttDependencies,
  SvelteGanttExternal,
  Table_default as SvelteGanttTable
};
//# sourceMappingURL=svelte-gantt_svelte.js.map
